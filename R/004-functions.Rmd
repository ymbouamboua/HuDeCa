plot_theme <- function(theme_type = c("minimal", "bw", "classic", "test","void"), 
                       font_size = 10, 
                       xyval = TRUE, 
                       x_angle = 0, 
                       x_hjust = NULL,
                       x_vjust = NULL, 
                       x_lab = TRUE,
                       y_lab = TRUE,
                       xy_lab = TRUE,
                       facet_title = "bold",
                       legend_position = "right",
                       legend_direction = "vertical"){ 
  
  # Validate theme selection
  theme_type <- match.arg(theme_type)
  
  # Automatically set hjust and vjust based on x_angle
  if (is.null(x_hjust) | is.null(x_vjust)) {
    x_angle <- as.numeric(x_angle)  # Ensure it's numeric
    
    if (x_angle == 0) {
      x_hjust <- 0.5
      x_vjust <- 1
    } else if (x_angle == 45) {
      x_hjust <- 1
      x_vjust <- 1
    } else if (x_angle == 90) {
      x_hjust <- 1
      x_vjust <- 0.5
    } else if (x_angle == 270) {
      x_hjust <- 0
      x_vjust <- 0.5
    } else {
      x_hjust <- 1
      x_vjust <- 1
    }
  }
  
  # Base theme structure
  base_theme <- theme(
    plot.title = element_text(hjust = 0.5, size = font_size+2, face = facet_title),
    text = element_text(size = font_size, color = "black"), 
    axis.title = element_text(face = "plain", size = font_size, color = "black"), 
    axis.text = element_text(size = font_size, color = "black"), 
    axis.text.x = element_text(angle = x_angle, 
                               hjust = x_hjust, 
                               vjust = x_vjust, 
                               color = "black"), 
    strip.text = element_text(face = "plain", color = "black"), 
    legend.title = element_text(size = font_size),
    legend.text  = element_text(size = font_size),
    legend.position.inside = if (is.numeric(legend_position)) legend_position else NULL,
    legend.position = if (!is.numeric(legend_position)) legend_position else NULL,
    legend.justification = "center",
    legend.direction = legend_direction,
    legend.background = element_blank(),
    legend.key.height = unit(0.3, 'cm'),
    legend.key.width = unit(0.3, 'cm'),
    legend.key = element_rect(colour = NA, fill = NA) 
  )
  
  minimal_theme <- function(x) { 
    min_thm <-  theme(
      axis.line.x = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.major.x = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.minor.y = element_blank(),
      axis.ticks.x = element_line(colour = "grey", linewidth = 0.15),
      axis.ticks.y = element_line(colour = "grey", linewidth = 0.15)
    )
    return(min_thm)
  } 

  #' save_plot: Save a Plot in Multiple Formats
#'
#' @description
#' This function saves a given plot to a specified file in one or more formats.
#' It allows for saving the plot in multiple formats (e.g., PNG, PDF, JPEG) at once, 
#' with customizable dimensions and resolution.
#'
#' @param plot A ggplot object. The plot to be saved.
#' @param filename Character, base name for the output file. The function appends the appropriate file extension(s).
#' @param formats Character vector specifying the file formats to save the plot in (default is `c("png", "pdf", "jpeg")`).
#' @param width Numeric, width of the saved plot in inches (default is `8`).
#' @param height Numeric, height of the saved plot in inches (default is `6`).
#' @param dpi Numeric, resolution of the saved plot in dots per inch (default is `300`).
#'
#' @details
#' The `save_plot` function automates the process of saving a ggplot object in multiple formats by looping over the specified
#' formats and using `ggsave` to save the plot. The output file names are generated by appending the format extension
#' (e.g., ".png", ".pdf") to the provided base filename.
#'
#' The dimensions (`width` and `height`) and resolution (`dpi`) can be customized. The `limitsize = FALSE` argument is used to 
#' allow saving plots with larger dimensions than usual.
#'
#' @examples
#' # Save a plot in default formats (PNG, PDF, and JPEG)
#' save_plot(plot = my_plot, filename = "my_plot")
#'
#' # Save a plot in PNG and SVG formats with custom dimensions
#' save_plot(plot = my_plot, filename = "custom_plot", formats = c("png", "svg"), width = 10, height = 7, dpi = 400)
#'
#' @export
save_plot <- function(plot, filename, formats = c("png", "pdf", "jpeg"), width = 8, height = 6, dpi = 300) {
  for (format in formats) {
    ggsave(
      filename = paste0(filename, ".", format),
      plot = plot,
      device = format,
      width = width,
      height = height,
      dpi = dpi, 
      limitsize = FALSE
    )
  }
}


#' Summarize Seurat Object Metadata
#'
#' This function summarizes metadata from a Seurat object and generates a bar plot 
#' for visualization. It allows grouping and conditioning by metadata columns, 
#' supports color customization, and provides options for reordering bars.
#'
#' @param object A Seurat object containing single-cell RNA-seq data.
#' @param group.by A string specifying the metadata column to group by (default: "sample").
#' @param condition.by A string specifying a second metadata column for conditional grouping (default: NULL).
#' @param pal.setup A string specifying the color palette from RColorBrewer (default: "Set1").
#' @param custom.colors A vector of custom colors to use instead of the default palette (default: NULL).
#' @param use.discrete.colors Logical; if TRUE, uses discrete colors from Set1 (default: FALSE).
#' @param angle.x An integer specifying the angle of x-axis labels (default: 90).
#' @param vjust.x Vertical justification of x-axis labels (default: NULL).
#' @param hjust.x Horizontal justification of x-axis labels (default: NULL).
#' @param x.title A string for the x-axis title (default: same as `group.by`).
#' @param remove.axis.x.text Logical; if TRUE, removes x-axis text (default: FALSE).
#' @param reorder.bars Logical; if TRUE, reorders bars based on a specified column (default: FALSE).
#' @param reorder.column A string specifying the column to reorder bars by (default: NULL).
#' @param plot.variable A string specifying the metric to plot: "total_counts", "total_transcripts", 
#'  "mean_transcripts", "median_transcripts", or "proportion" (default: "total_counts").
#' @param title A string specifying the plot title (default: same as `plot.variable`).
#' @param legend Logical; if FALSE, removes the legend (default: TRUE).
#' @param text.size An integer specifying the text size in the plot (default: 10).
#'
#' @return A list containing:
#'   \item{summary_table}{A summary table with calculated statistics.}
#'   \item{plot}{A ggplot2 object representing the bar plot.}
#'
#' @import Seurat dplyr ggplot2 RColorBrewer
#' @export
#'
#' @examples
#' \dontrun{
#'   result <- Summarize_Seurat(object = seurat_obj, group.by = "cell_type", plot.variable = "total_counts")
#'   print(result$plot)
#' }
Summarize_Seurat <- function(object, 
                             group.by = "sample",
                             assay = "RNA",
                             slot = "counts",
                             condition.by = NULL,  
                             pal.setup = "Set1",
                             custom.colors = NULL,
                             use.discrete.colors = FALSE,
                             theme_type = "classic", 
                             x_angle = 45, 
                             x.title = group.by,
                             remove.axis.x.text = FALSE,
                             reorder.bars = FALSE,
                             reorder.column = NULL,
                             plot.variable = c("total_transcripts", "mean_transcripts", "median_transcripts", 
                                               "num_expressed_genes", "mean_genes_per_cell", "num_cells"),
                             plot.title = plot.variable,
                             legend = TRUE,
                             legend.title = NULL,
                             legend.key.size = 0.3,
                             legend.position = "right",
                             legend.ncol = 1,
                             legend.alpha = 1,
                             text.size = 10,
                             remove.x.labels = FALSE,
                             remove.x.title = FALSE,
                             remove.y.title = FALSE,
                             y.title = NULL) {
  
  # Load required libraries
  require(Seurat)
  require(dplyr)
  require(ggplot2)
  require(RColorBrewer)
  
  # Validate the plotting method choice
  plot.variable <- match.arg(plot.variable)
  
  # Extract metadata and gene expression matrix
  metadata <- object@meta.data
  gene_counts <- object[[assay]][slot]
  
  # Ensure group.by exists
  if (!group.by %in% colnames(metadata)) {
    stop(paste("The specified group.by column", group.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Ensure condition.by exists if provided
  if (!is.null(condition.by) && !condition.by %in% colnames(metadata)) {
    stop(paste("The specified condition.by column", condition.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Compute expressed genes per cell
  expressed_genes_per_cell <- Matrix::colSums(gene_counts > 0)  # Number of genes expressed per cell
  metadata$num_expressed_genes <- expressed_genes_per_cell
  
  # Group data
  if (!is.null(condition.by)) {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by), !!sym(condition.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      ) %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::mutate(proportion = total_counts / sum(total_counts)) %>%  
      dplyr::ungroup()
  } else {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      )
  }
  
  # Add the number of cells per group (corrected)
  num_cells_per_group <- metadata %>%
    dplyr::group_by(!!sym(group.by)) %>%
    dplyr::summarise(num_cells = n(), .groups = 'drop')
  summary_stats <- left_join(summary_stats, num_cells_per_group, by = group.by)
  
  # Ensure plot.variable exists
  if (!(plot.variable %in% colnames(summary_stats))) {
    stop(paste("The specified plot.variable", plot.variable, "does not exist in the summary statistics table."))
  }
  
  # Define colors
  unique_groups <- unique(summary_stats[[ifelse(is.null(condition.by), group.by, condition.by)]])
  num_groups <- length(unique_groups)
  
  if (!is.null(custom.colors)) {
    if (length(custom.colors) < num_groups) {
      stop(paste("Insufficient colors in custom.colors. Needed:", num_groups, "Provided:", length(custom.colors)))
    }
    colors_to_use <- custom.colors
  } else if (use.discrete.colors) {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set1"))(num_groups)
  } else {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_groups), pal.setup))(num_groups)
  }
  
  # Reorder bars globally if required
  if (reorder.bars) {
    if (is.null(reorder.column)) {
      reorder.column <- plot.variable  # Default to reordering by the plot variable
    }
    if (!reorder.column %in% colnames(summary_stats)) {
      stop(paste("The specified reorder.column", reorder.column, "does not exist in the summary statistics table."))
    }
    
    # Ensure reorder.column is evaluated correctly
    summary_stats <- summary_stats %>%
      dplyr::mutate(!!reorder.column := as.numeric(summary_stats[[reorder.column]])) %>%
      dplyr::arrange(dplyr::desc(!!sym(reorder.column))) %>%
      dplyr::mutate(!!sym(group.by) := factor(!!sym(group.by), levels = unique(!!sym(group.by))))
  }
  
  # Create base bar plot
  p <- ggplot(summary_stats, aes(x = !!sym(group.by), y = !!sym(plot.variable))) +
    geom_bar(stat = "identity", position = "stack", color = "black", size = 0.3) +  
    plot_theme(theme_type = theme_type, x_angle = x_angle, font_size = text.size) +
    theme(legend.position = legend.position,
          legend.key.size = unit(legend.key.size, "cm")) +
    guides(color = guide_legend(ncol = legend.ncol, alpha = legend.alpha, title = legend.title)) +
    labs(title = plot.title, y = plot.variable, x = x.title, colour = paste(legend.title)) 
  
  # Add fill aesthetic
  if (!is.null(condition.by)) {
    p <- p + aes(fill = !!sym(condition.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  } else {
    p <- p + aes(fill = !!sym(group.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  }
  
  if (remove.x.title) {
    p <- p + theme(axis.title.x = element_blank())
  }
  
  if (remove.y.title) {
    p <- p + theme(axis.title.y = element_blank())
  }
  
  if (remove.x.labels) {
    p <- p + theme(axis.text.x = element_blank(),
                   axis.ticks.x = element_blank())
  }
  
  if (!is.null(y.title)) {
    p <- p + ylab(y.title)
  }
  
  # Hide legend if specified
  if (!legend) {
    p <- p & NoLegend()
  }
  
  # Return results
  return(list(summary_table = summary_stats, plot = p))
}

Seurat_Subset <- function(object, cluster_id, 
                          npcs = 30,
                          features = NULL,
                          ndims = 20, 
                          reduction = "pca",
                          resolution = 0.2,
                          min.dist = 0.5) {
  sub <- subset(object, idents = cluster_id)
  #DefaultAssay(sub) <- "integrated"
  #features <- VariableFeatures(sub)
  sub <- ScaleData(sub)
  sub <- RunPCA(sub, npcs = npcs, features = features)
  sub <- RunUMAP(sub, dims = 1:ndims, reduction = reduction,min.dist = min.dist)
  sub <- FindNeighbors(sub, dims = 1:ndims, reduction = reduction)
  sub <- FindClusters(sub, resolution = resolution)
  DefaultAssay(sub) <- "RNA"
  sub <- NormalizeData(sub)
  sub <- FindVariableFeatures(sub)
  sub <- ScaleData(sub)
  return(sub)
}

#' Plot Cell Fractions Over Time
#'
#' This function creates various types of visualizations to display the distribution 
#' of cell types over time using Seurat metadata.
#'
#' @param seurat_obj A Seurat object containing cell metadata.
#' @param x.col Character. The column name in metadata representing the x-axis (e.g., "Age").
#' @param fill.col Character. The column name in metadata representing cell types (e.g., "CellType").
#' @param plot.type Character. Type of plot to generate. Choose from:
#'   - "stacked_area" (default)
#'   - "stacked_bar"
#'   - "grouped_bar"
#'   - "point_smooth"
#'   - "heatmap"
#'   - "ridgeline"
#'   - "line"
#' @param text.size Numeric. Text size for axis labels and titles (default: 10).
#' @param legend.title Character. Custom title for the legend (default: NULL).
#' @param legend.position Character. Position of legend ("right", "bottom", "top", "left") (default: "right").
#' @param legend.ncol Numeric. Number of columns in the legend (default: 1).
#' @param custom.colors Character vector. Custom colors for cell types (default: NULL).
#' @param x.title Character. Custom x-axis title (default: same as `x.col`).
#' 
#' @return A ggplot object.
#' @import ggplot2 dplyr RColorBrewer ggridges scales
#' @export
#' 
#' @examples
#' # Example usage:
#' Plot_Cell_Fractions(seurat_obj, plot.type = "ridgeline")
#' Plot_Cell_Fractions(seurat_obj, plot.type = "stacked_area", text.size = 12)
Plot_Cell_Fractions <- function(seurat_obj, 
                                x.col = "Age", 
                                fill.col = "CellType",
                                plot.type = "stacked_area",
                                text.size = 10,
                                pt.size = 2,
                                line.size = 0.5,
                                legend.title = NULL,
                                legend.position = "right",
                                legend.ncol = 1,
                                custom.colors = NULL,
                                x.title = x.col
) {
  
  # Load necessary libraries
  library(ggplot2)
  library(dplyr)
  library(RColorBrewer)
  library(ggridges)
  library(scales)
  
  # Ensure metadata contains the required columns
  metadata <- seurat_obj@meta.data %>%
    dplyr::select(all_of(c(x.col, fill.col))) %>%
    dplyr::group_by(!!sym(x.col), !!sym(fill.col)) %>%
    dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
    dplyr::group_by(!!sym(x.col)) %>%
    dplyr::mutate(fraction = count / sum(count)) %>%
    dplyr::ungroup()
  
  # Ensure x.col is numeric
  metadata[[x.col]] <- as.numeric(as.character(metadata[[x.col]]))
  
  # Define colors
  num_categories <- length(unique(metadata[[fill.col]]))
  if (is.null(custom.colors)) {
    custom.colors <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_categories), "Set3"))(num_categories)
  }
  
  # Create the plot based on plot type
  if (plot.type == "stacked_area") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_area(position = "stack", alpha = 1, colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "stacked_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "fill", colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "grouped_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = count, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "dodge", colour = "black", size = 0.2) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell Count") +
      theme_classic()
  }
  
  else if (plot.type == "point_smooth") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col))) +
      geom_point(size = pt.size) +
      geom_smooth(method = "loess", se = FALSE, size = line.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "heatmap") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), fill = fraction)) +
      geom_tile() +
      viridis::scale_fill_viridis_c(option = "plasma") +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_minimal()
  }
  
  else if (plot.type == "ridgeline") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), height = fraction, fill = !!sym(fill.col))) +
      geom_density_ridges(stat = "identity", scale = 1.5, alpha = 0.7) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_classic()
  } else if (plot.type == "line") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col), group = !!sym(fill.col))) +
      geom_line(size = line.size) + 
      geom_point(size = pt.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  } else {
    stop("Invalid plot type. Choose from: stacked_area, stacked_bar, grouped_bar, point_smooth, heatmap, line, ridgeline.")
  }
  
  # Adjust theme settings
  p <- p +
    theme(
      plot.title = element_text(size = text.size + 2, face = "bold", hjust = 0.5),
      axis.title = element_text(size = text.size),
      axis.text = element_text(size = text.size, color = "black"),
      legend.key.size = unit(0.3, 'cm'),
      legend.position = legend.position,
      legend.spacing.y = unit(0.05, 'cm'),  # Reduce space between legend items
      legend.margin = margin(t = -10, b = 0, unit = 'pt') # Reduce space between plot and legend
    ) +
    guides(fill = guide_legend(
      ncol = legend.ncol, 
      override.aes = list(color = "black", size = 0.2) 
    ))
  
  return(p)
}




plot_gene_set_expression <- function(object,
                               features,
                               threshold = 0.5,
                               plot_log = TRUE,
                               x_angle = 0,
                               theme_type = "classic",
                               font_size = 10,
                               legend_position = c(0.25, 0.9)) {

  # Subset the Seurat object for the selected genes
  filt <- subset(object, features = features)
  filt <- filt[rowSums(filt@assays$RNA@counts > 0) > 0, ]

  # Extract normalized expression data for these genes
  expr_data <- FetchData(filt, vars = rownames(filt))

  # Calculate the mean expression for each receptor across all cells
  mean_expression <- colMeans(expr_data)

  # Create a data frame for plotting
  expr_df <- data.frame(Receptor = names(mean_expression),
                        Expression = mean_expression)

  # Order by expression levels
  expr_df <- expr_df[order(expr_df$Expression), ]

  # Calculate the number of olfactory receptors (excluding VN1R1 and VN1R2)
  num_olfactory_receptors <- sum(!expr_df$Receptor %in% c("VN1R1", "VN1R2"))

  # Create a label for the olfactory receptors that includes the count
  olfactory_label <- paste0("Olfactory receptors (", num_olfactory_receptors, ")")

  # Modify the Receptor_Group to include specific labels
  expr_df$Receptor_Group <- ifelse(expr_df$Receptor %in% c("VN1R1", "VN1R2"),
                                   expr_df$Receptor, olfactory_label)

  # Set colors for the plot
  fill_colors <- c("VN1R1" = "red", "VN1R2" = "orange", "Olfactory receptors (0)" = "#20679B")
  fill_colors[olfactory_label] <- "#20679B"

  # Count the number of cells expressing each receptor
  expressing_cells <- expr_data > threshold
  cell_counts <- colSums(expressing_cells)
  expr_df$Cell_Count <- cell_counts[match(expr_df$Receptor, names(cell_counts))]

  # Optionally calculate -log10(expression) for better visualization
  if (plot_log) {
    expr_df$Log_Expression <- -log10(expr_df$Expression)
    y_var <- "Log_Expression"
    y_label <- "-Log10(Normalized Expression)"
  } else {
    expr_df$Log_Expression <- expr_df$Expression
    y_var <- "Expression"
    y_label <- "Normalized Expression"
  }

  # Plot the expression levels
  p <- ggplot(expr_df, aes(x = reorder(Receptor, !!sym(y_var)), y = !!sym(y_var), fill = Receptor_Group)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = fill_colors, name = "Receptor types") +
    labs(x = "Receptors", y = y_label) +
    plot_theme(theme_type = theme_type,
               legend_position = legend_position,
               font_size = font_size,
               x_angle = x_angle) +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

  return(p)
}


# Function to analyze and visualize OR gene expression
plot_common_genes <- function(seurat_obj, 
                            gene_list, 
                            cell_type_col, 
                            legend_position = c(0.90, 0.8),
                            theme_type = "classic",
                            font_size = 10,
                            x_angle = 90,
                            colors = NULL) {
  
  require(Seurat)
  require(ggplot2)
  require(dplyr)
  require(tidyr)
  require(forcats)
  require(rlang)
  
  # Step 1: Extract OR gene expression data
  features <- intersect(gene_list, rownames(seurat_obj[["RNA"]]@counts))
  sub <- subset(seurat_obj, features = features)
  OR_counts <- GetAssayData(sub, assay = "RNA", slot = "counts")
  
  # Step 2: Filter for OR genes
  OR_genes <- intersect(rownames(OR_counts), features)
  OR_counts <- OR_counts[OR_genes, ]
  
  # Step 3: Identify expressed ORs in each cell
  expressed_ORs <- OR_counts > 0  # Boolean matrix: TRUE if an OR is expressed
  
  # Step 4: Combine with metadata for cell type
  cell_data <- data.frame(
    Cell_Barcode = colnames(sub),
    Cell_Type = sub@meta.data[[cell_type_col]]  # Use specified metadata column
  )
  
  # Convert OR expression matrix to long format
  OR_long <- as.data.frame(t(expressed_ORs)) %>%
    dplyr::mutate(Cell_Barcode = rownames(.)) %>%
    pivot_longer(
      cols = -Cell_Barcode,
      names_to = "OR_Gene",
      values_to = "Expressed"
    ) %>%
    filter(Expressed)  # Only keep expressed ORs
  
  # Step 5: Join cell type information with OR expression
  OR_long <- OR_long %>%
    dplyr::left_join(cell_data, by = "Cell_Barcode")
  
  # Step 6: Count cells expressing each OR, grouped by cell type
  OR_summary <- OR_long %>%
    dplyr::group_by(OR_Gene, Cell_Type) %>%
    dplyr::summarize(Number_of_Cells = n(), .groups = "drop")
  
  # Step 7: Filter ORs expressed in at least two cell types
  OR_summary_filtered <- OR_summary %>%
    dplyr::group_by(OR_Gene) %>%
    dplyr::filter(n_distinct(Cell_Type) >= 2) %>%
    dplyr::ungroup()
  
  # Step 8: Reorder OR_Gene by total number of cells expressing each OR
  OR_summary_filtered <- OR_summary_filtered %>%
    dplyr::group_by(OR_Gene) %>%
    dplyr::mutate(Total_Cells = sum(Number_of_Cells)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(OR_Gene = forcats::fct_reorder(OR_Gene, Total_Cells, .desc = TRUE))
  
  # Set default colors if none provided
  if (is.null(colors)) {
    unique_cell_types <- unique(OR_summary_filtered$Cell_Type)
    colors <- setNames(rainbow(length(unique_cell_types)), unique_cell_types)
  }
  
  # Step 9: Generate the plot
  p <- ggplot(OR_summary_filtered, aes(x = OR_Gene, y = Number_of_Cells, fill = Cell_Type)) +
    geom_bar(stat = "identity", position = "stack", color = "black", size = 0.1) +
    labs(
      x = "",
      y = "Number of ORs"
    ) +
    plot_theme(theme_type = theme_type, 
               legend_position = legend_position, 
               font_size = font_size, x_angle = x_angle) +
    scale_fill_manual(values = colors, name = "") 
    
  
  return(p)
}

analyze_OR_distribution <- function(seurat_obj, gene_list, meta_column, expr_cutoff = 1, 
                                    breaks = c(-1, 0, 1, 2, Inf),
                                    bin_labels = c("0", "1", "2", "3+"),
                                    fill_colors = NULL,
                                    theme_type = "minimal",
                                    legend_pos = c(0.25, 0.90)) {
  
  require(dplyr)
  require(ggplot2)
  require(tidyr)
  
  # Extract genes expressed above cutoff
  genes <- intersect(gene_list, rownames(seurat_obj@assays$RNA@counts))
  expr <- as.matrix(seurat_obj@assays$RNA@counts[genes, ])
  expr_counts <- Matrix::colSums(expr > expr_cutoff)
  
  # Create metadata df
  df <- data.frame(
    OR_count = expr_counts,
    Stage = seurat_obj@meta.data[[meta_column]]
  )
  
  # Bin OR counts
  df$OR_bin <- cut(df$OR_count, breaks = breaks, labels = bin_labels, right = TRUE)
  
  # Build contingency table
  table_OR <- table(df$Stage, df$OR_bin)
  chi_test <- chisq.test(table_OR)
  
  # Extract residuals
  residuals_df <- as.data.frame(chi_test$stdres)
  colnames(residuals_df) <- c("Stage", "OR_bin", "Std_Resid")
  residuals_df$Sig <- case_when(
    abs(residuals_df$Std_Resid) >= 3.29 ~ "***",
    abs(residuals_df$Std_Resid) >= 2.58 ~ "**",
    abs(residuals_df$Std_Resid) >= 1.96 ~ "*",
    TRUE ~ ""
  )
  
  # Count and percentage per group
  count_df <- df %>%
    dplyr::group_by(Stage, OR_bin) %>%
    dplyr::summarise(n = n(), .groups = "drop") %>%
    dplyr::group_by(Stage) %>%
    dplyr::mutate(Percentage = n / sum(n) * 100) %>%
    dplyr::ungroup()
  
  # Merge
  plot_df <- left_join(residuals_df, count_df, by = c("Stage", "OR_bin"))
  
  # Color palette fallback
  if (is.null(fill_colors)) {
    unique_stages <- unique(df$Stage)
    fill_colors <- setNames(RColorBrewer::brewer.pal(length(unique_stages), "Set2"), unique_stages)
  }
  
  # Plot
  p <- ggplot(plot_df, aes(x = OR_bin, y = Percentage, fill = Stage)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black", size = 0.1) +
    geom_text(aes(label = Sig), position = position_dodge(width = 0.9), vjust = -0.5, size = 4) +
    labs(x = "Olfactory receptors", y = "Proportion (%)", fill = "") +
    scale_fill_manual(values = fill_colors) +
    plot_theme(theme_type = theme_type, legend_position = legend_pos)
  
  return(list(
    plot = p,
    chi_result = chi_test,
    residuals = residuals_df
  ))
}



# Function to plot unique ORs detected per cell
plot_unique_gene_per_cell <- function(seurat_obj, gene_list, font_size = 10, theme_type = "classic",
                                      x_title = "Number of cells", y_title = "Number of ORs") {
  # Find common genes between gene_list and Seurat object
  features <- intersect(gene_list, rownames(seurat_obj[["RNA"]]@counts))
  
  # Subset the Seurat object to include only the selected features
  filt <- subset(seurat_obj, features = features)
  
  # Filter out genes that are not expressed in any cell
  filt <- filt[rowSums(filt@assays$RNA@counts > 0) > 0, ]
  
  # Extract normalized expression data
  expr_data <- FetchData(filt, vars = rownames(filt))
  
  # Count the number of unique ORs detected per cell (above threshold)
  unique_OR_counts <- apply(expr_data, 1, function(cell_expr) sum(cell_expr > 0))
  
  # Create a data frame for plotting
  plot_data <- data.frame(
    Cell = names(unique_OR_counts),
    Unique_ORs = unique_OR_counts
  )
  
  # Filter out cells with no ORs
  plot_data <- subset(plot_data, Unique_ORs != 0)
  plot_data$Unique_ORs <- factor(plot_data$Unique_ORs)
  
  # Create the plot
  p <- ggplot(plot_data, aes(x = Cell, y = Unique_ORs)) +
    geom_bar(stat = "identity", position = position_dodge(), colour = "#20679B") +
    labs(
      x = x_title,
      y = y_title
    ) +
    plot_theme(theme_type = theme_type, 
               legend_position = "none", 
               font_size = font_size) +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Create a table to show the number of OSNs expressing each gene
  # Count non-zero entries per column (number of cells expressing each gene)
  count_non_zero <- colSums(expr_data > 0)
  
  # Convert to a data frame
  gene_expr_table <- data.frame(features = names(count_non_zero), count_non_zero = count_non_zero)
  
  # Order by count_non_zero in ascending order
  gene_expr_table <- gene_expr_table[order(gene_expr_table$count_non_zero, decreasing = FALSE), ]
  
  # Return the plot and the expression table
  return(list(Plot = p, Expression_Table = gene_expr_table))
}

#' Test variable genes along pseudotime using GAM (Generalized Additive Model)
#'
#' This function tests the association between gene expression and pseudotime for the most variable genes,
#' using a generalized additive model (GAM) on a subset of selected cell types.
#'
#' @param seurat_obj A Seurat object containing expression data.
#' @param sce_obj A SingleCellExperiment object containing expression data and pseudotime.
#' @param pseudotime_col Name of the column containing pseudotime values in \code{sce_obj}. Default is "slingPseudotime_1".
#' @param annotation_level Name of the cell type annotation column. Default is "ann_level_2".
#' @param selected_celltypes Vector of cell types to include in the analysis. Default is c("Olf. HBCs", "GBCs", "preOSNs", "iOSNs", "mOSNs").
#' @param n_variable_genes Number of variable genes to test. Default is 500.
#' @param verbose Whether to display progress messages. Default is TRUE.
#'
#' @return A list containing:
#' \describe{
#'   \item{sce}{The subsetted SCE object.}
#'   \item{result}{A sorted data.frame of tested genes with p-value and q-value.}
#'   \item{ptime}{Vector of pseudotime values used.}
#'   \item{lineage_cells}{Names of cells included in the analysis.}
#' }
#'
#' @details
#' Genes are individually tested for association with pseudotime using a GAM (gam::gam).
#' P-values are adjusted using the FDR method.
#'
#' @import gam
#' @import SingleCellExperiment
#' @import Seurat
#' @importFrom tibble tibble
#' @importFrom dplyr arrange
#' @export
#' 
test_pseudotime_genes_gam <- function(seurat_obj,
                                      sce_obj,
                                      pseudotime_col = "slingPseudotime_1",
                                      annotation_level = "ann_level_2",
                                      selected_celltypes = c("Olf. HBCs", "GBCs", "preOSNs", "iOSNs", "mOSNs"),
                                      n_variable_genes = 500,
                                      verbose = TRUE) {
  require(gam)
  require(SingleCellExperiment)
  require(Seurat)
  
  # Subset the SCE by selected annotation
  if (verbose) message("Subsetting SCE object by selected cell types...")
  selected_cells <- sce_obj[[annotation_level]] %in% selected_celltypes
  subset_sce <- sce_obj[, selected_cells]
  
  # Extract pseudotime and keep only cells in the lineage
  if (verbose) message("Extracting pseudotime values and filtering NA...")
  ptime <- subset_sce[[pseudotime_col]]
  lineage_cells <- colnames(subset_sce)[!is.na(ptime)]
  ptime <- ptime[!is.na(ptime)]
  
  # Match Seurat object to same cell subset
  if (verbose) message("Subsetting Seurat object to match cell types...")
  Idents(seurat_obj) <- annotation_level
  seurat_sub <- Seurat_Subset(seurat_obj, cluster_id = selected_celltypes)
  seurat_sub <- Filter_Unwanted_Genes(seurat_sub, scale_data = TRUE)
  
  # Select top variable genes
  if (verbose) message(paste0("Selecting top ", n_variable_genes, " variable genes..."))
  genes_to_test <- head(VariableFeatures(seurat_sub), n_variable_genes)
  
  # Get logcounts from SCE
  if (verbose) message("Extracting log-normalized counts...")
  cnts <- logcounts(subset_sce)[genes_to_test, lineage_cells]
  
  # Fit GAM for each gene
  if (verbose) message("Fitting GAM models...")
  gam_pval <- apply(cnts, 1, function(z) {
    d <- data.frame(z = z, ptime = ptime)
    tmp <- suppressWarnings(gam::gam(z ~ gam::lo(ptime), data = d))
    p <- summary(tmp)[4][[1]][1, 5]
    p
  })
  
  gam_pval <- na.omit(gam_pval)
  
  # Return results as a sorted data frame
  if (verbose) message("Returning sorted results...")
  # result <- data.frame(
  #   gene = names(gam_pval),
  #   pval = gam_pval
  # )
  
  result <- tibble(id = names(gam_pval), pvals = gam_pval, qval = p.adjust(gam_pval, method = "fdr")) %>%
  arrange(qval)
  
  #result <- result[order(result$pval), ]
  return(list("sce" = subset_sce, "result" = result, "ptime" = ptime, "lineage_cells" = lineage_cells))
}


#' Plot a heatmap of gene expression along pseudotime
#'
#' This function generates a heatmap of scaled gene expression for a set of genes along pseudotime,
#' with cell type and pseudotime annotations, using the ComplexHeatmap package.
#'
#' @param sce A SingleCellExperiment object containing expression data.
#' @param pseudotime_col Name of the column in \code{colData(sce)} with pseudotime values. Default is "slingPseudotime_1".
#' @param annotation_col Name of the column in \code{colData(sce)} with cell type annotations. Default is "ann_level_2".
#' @param lineage_cells Character vector of cell names to include in the heatmap.
#' @param ptime_order Character vector specifying the order of cells along pseudotime.
#' @param gene_list Character vector of gene names to include in the heatmap.
#' @param celltype_order Character vector specifying the order of cell types in the annotation.
#' @param celltype_colors Named vector of colors for each cell type.
#' @param pseudotime_palette Name of the RColorBrewer palette for pseudotime annotation. Default is "YlGnBu".
#' @param zscore_limits Numeric vector of length 3 for the color scale limits (e.g., c(-2, 0, 2)).
#' @param output_pdf File path to save the heatmap as a PDF. If NULL, the plot is shown in the current device.
#' @param show_legend Logical, whether to show the heatmap legend. Default is TRUE.
#' @param show_annotation_legend Logical, whether to show the annotation legend. Default is TRUE.
#' @param cluster_rows Logical, whether to cluster the rows (genes). Default is TRUE.
#' @param font_size Integer, font size for row names and annotations. Default is 10.
#' @param pdf_width Numeric, width of the PDF output (if used). Default is 6.
#' @param pdf_height Numeric, height of the PDF output (if used). Default is 10.
#' @param plot_title Optional title for the heatmap.
#'
#' @return No return value. The function generates a heatmap plot, either displayed or saved as a PDF.
#'
#' @details
#' The function scales gene expression (row-wise Z-score), orders cells by pseudotime, and annotates columns by cell type and pseudotime.
#' Colors and clustering options are customizable.
#'
#' @import ComplexHeatmap
#' @import circlize
#' @import RColorBrewer
#' @import SingleCellExperiment
#' @export
#' 
plot_heatmap_pseudotime <- function(sce,
                                    pseudotime_col = "slingPseudotime_1",
                                    annotation_col = "ann_level_2",
                                    lineage_cells,
                                    ptime_order,
                                    gene_list,
                                    celltype_order,
                                    celltype_colors,
                                    pseudotime_palette = "YlGnBu",
                                    zscore_limits = c(-2, 0, 2),
                                    output_pdf = NULL,
                                    show_legend = TRUE,
                                    show_annotation_legend = TRUE,
                                    cluster_rows = TRUE,
                                    font_size = 10,
                                    pdf_width = 6,
                                    pdf_height = 10,
                                    plot_title = NULL) {
  
  require(ComplexHeatmap)
  require(circlize)
  require(RColorBrewer)
  require(SingleCellExperiment)

  # Filter and order expression matrix
  expr_mat <- logcounts(sce)[gene_list, lineage_cells, drop = FALSE]
  expr_mat <- expr_mat[, ptime_order]
  expr_mat_scaled <- as.matrix(t(scale(t(expr_mat))))  # Row-wise Z-score

  # Annotations
  annotations <- as.data.frame(colData(sce)[lineage_cells, c(pseudotime_col, annotation_col)])
  colnames(annotations) <- c("Pseudotime", "Cell types")
  annotations <- annotations[colnames(expr_mat_scaled), ]
  rownames(annotations) <- colnames(expr_mat_scaled)
  annotations$`Cell types` <- factor(annotations$`Cell types`, levels = celltype_order)

  # Pseudotime color function
  ptime_vector <- annotations$Pseudotime
  if (any(is.na(ptime_vector))) {
    stop("Pseudotime vector contains NA values. Filter or impute them before plotting.")
  }
  ptime_breaks <- seq(min(ptime_vector), max(ptime_vector), length.out = 100)
  ptime_colors <- colorRampPalette(rev(brewer.pal(n = 7, name = pseudotime_palette)))(100)
  ptime_color_fun <- circlize::colorRamp2(ptime_breaks, ptime_colors)

  # Annotation bar
  top_annot <- HeatmapAnnotation(
    "Cell types" = annotations$`Cell types`,
    "Pseudotime" = annotations$Pseudotime,
    col = list(
      "Cell types" = celltype_colors,
      "Pseudotime" = ptime_color_fun
    ),
    annotation_legend_param = list(
      "Cell types" = list(ncol = 1, border = "black", legend_direction = "vertical"),
      "Pseudotime" = list(border = "black")
    ),
    show_legend = show_annotation_legend,
    annotation_name_gp = gpar(fontsize = font_size)
  )

  # Heatmap
  ht <- ComplexHeatmap::Heatmap(expr_mat_scaled,
                name = "Z-score",
                show_column_names = FALSE,
                show_row_names = TRUE,
                cluster_rows = cluster_rows,
                cluster_columns = FALSE,
                show_row_dend = FALSE,
                column_dend_reorder = FALSE,
                col = colorRamp2(zscore_limits, c("blue", "white", "red")),
                border = TRUE,
                rect_gp = gpar(col = NA),
                heatmap_legend_param = list(
                  title = "Z-score",
                  title_position = "topcenter",
                  legend_direction = "horizontal",
                  legend_height = unit(0.3, 'cm'), 
                  legend_width = unit(3, 'cm'),
                  #legend_height = unit(1, 'cm'),
                  #legend_width = unit(2.7, 'cm'),
                  border = 'black'),
                row_names_gp = gpar(fontface = "italic", fontsize = font_size),
                top_annotation = top_annot)

  # Export or show with optional title
  options(ComplexHeatmap.raster_device = NULL)
  
  if (!is.null(output_pdf)) {
    pdf(output_pdf, useDingbats = FALSE, width = pdf_width, height = pdf_height)
    ComplexHeatmap::draw(ht,
                         use_raster = FALSE,
                         raster_device = NULL,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "right",
                         column_title = plot_title,
                         column_title_gp = gpar(fontsize = font_size + 2, fontface = "bold"))
    dev.off()
    
  } else {
    ComplexHeatmap::draw(ht,
                         use_raster = FALSE,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "right",
                         column_title = plot_title,
                         column_title_gp = gpar(fontsize = font_size + 2, fontface = "bold"))
  }
}
