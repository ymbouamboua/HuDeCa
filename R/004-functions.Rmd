#' Run Quality Control on Seurat Objects
#'
#' Performs automated cell filtering based on gene/UMI counts, mitochondrial
#' and ribosomal content, dropout rate, and optional doublet detection.
#' Works on single or multiple Seurat objects.
#'
#' @param x Seurat object or list of Seurat objects.
#' @param min_feat Minimum number of detected genes.
#' @param min_umi Minimum number of UMIs.
#' @param mad_n Number of MADs for upper cutoffs (if method = "MAD").
#' @param max_mito Maximum mitochondrial percentage.
#' @param calc_ribo Logical; compute ribosomal gene percentage.
#' @param max_ribo Maximum ribosomal percentage.
#' @param rm_dbl Logical; perform doublet removal using scDblFinder.
#' @param calc_drop Logical; compute dropout fraction.
#' @param max_drop Maximum dropout fraction.
#' @param method Thresholding method: "MAD", "fixed", or "none".
#' @param fixed_thr Named list of fixed upper cutoffs.
#' @param mito_pat Regex for mitochondrial genes.
#' @param ribo_pat Regex for ribosomal genes.
#' @param species "human" or "mouse" (sets default gene patterns).
#' @param log_g2u Logical; filter by log10(genes/UMI).
#' @param min_g2u Minimum genes/UMI ratio.
#' @param sample_col Metadata column for sample ID.
#' @param outdir Output directory.
#' @param merge Logical; merge outputs into a single Seurat object.
#'
#' @return A filtered Seurat object, list, or merged object.
#' @export
#'
#' @examples
#' qc_data <- run_qc(seurat_list, calc_ribo = TRUE, rm_dbl = TRUE)
#'
run_qc <- function(
    x,
    min_feat = 200,
    min_umi = 500,
    mad_n = 5,
    max_mito = 5,
    calc_ribo = FALSE,
    max_ribo = 3,
    calc_drop = FALSE,
    max_drop = 0.95,
    rm_dbl = FALSE,
    method = c("MAD", "fixed", "none"),
    fixed_thr = list(max_feat = 6000, max_umi = 20000),
    mito_pat = NULL,
    ribo_pat = NULL,
    species = c("human", "mouse"),
    sample_col = "orig.ident",
    outdir = "results/QC",
    merge_output = TRUE,
    verbose = TRUE
) {
  library(Seurat)
  library(dplyr)
  library(Matrix)
  
  method <- match.arg(method)
  species <- match.arg(species)
  
  # Default gene patterns
  if (is.null(mito_pat)) mito_pat <- if (species == "human") "^MT-" else "^mt-"
  if (is.null(ribo_pat)) ribo_pat <- if (species == "human") "^RP[LS]" else "^Rp[ls]"
  
  dir.create(outdir, recursive = TRUE, showWarnings = FALSE)
  
  # Input validation
  if (inherits(x, "Seurat")) {
    obj_list <- list(x)
    single <- TRUE
  } else if (is.list(x) && all(sapply(x, inherits, "Seurat"))) {
    obj_list <- x
    single <- FALSE
  } else stop("Input must be a Seurat object or list of Seurat objects.")
  
  qc_sum <- data.frame()
  dbl_sum <- data.frame()
  
  if (verbose) cat("\nðŸš€ Starting quality control for", length(obj_list), "sample(s)...\n")
  
  for (i in seq_along(obj_list)) {
    obj <- obj_list[[i]]
    sample <- if (sample_col %in% colnames(obj@meta.data))
      unique(obj@meta.data[[sample_col]]) else paste0("Sample_", i)
    
    pre_cells <- ncol(obj)
    if (verbose) cat("\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nðŸ“¦ Sample:", sample, "| Cells:", pre_cells, "\n")
    
    # Compute QC metrics
    obj$percent_mito <- PercentageFeatureSet(obj, pattern = mito_pat)
    if (calc_ribo) obj$percent_ribo <- PercentageFeatureSet(obj, pattern = ribo_pat)
    if (calc_drop) {
      counts <- GetAssayData(obj, slot = "counts")
      obj$dropout <- Matrix::colSums(counts == 0) / nrow(counts)
    }
    
    # Compute thresholds
    if (method == "MAD") {
      max_feat <- median(obj$nFeature_RNA) + mad_n * mad(obj$nFeature_RNA)
      max_umi  <- median(obj$nCount_RNA) + mad_n * mad(obj$nCount_RNA)
    } else if (method == "fixed") {
      max_feat <- fixed_thr$max_feat
      max_umi  <- fixed_thr$max_umi
    } else {
      max_feat <- Inf; max_umi <- Inf
    }
    
    # Apply permissive filters
    filt <- subset(
      obj,
      nFeature_RNA > min_feat &
        nFeature_RNA < max_feat &
        nCount_RNA > min_umi &
        percent_mito < max_mito &
        (if (calc_ribo) percent_ribo < max_ribo else TRUE) &
        (if (calc_drop) dropout < max_drop else TRUE)
      # âŒ No max UMI cutoff â€” preserves high-depth nuclei
    )
    
    post_cells <- ncol(filt)
    pct_rm <- round((1 - post_cells / pre_cells) * 100, 2)
    if (verbose) cat("âœ… Retained:", post_cells, "cells (", pct_rm, "% removed)\n")
    
    # Optional doublet filtering
    if (rm_dbl) {
      if (verbose) cat("ðŸ” Running scDblFinder...\n")
      sce <- scDblFinder::scDblFinder(as.SingleCellExperiment(filt))
      filt$scDblFinder <- sce$scDblFinder.class
      filt <- subset(filt, scDblFinder == "singlet")
      dbl_sum <- rbind(dbl_sum, data.frame(Sample = sample, Doublets = sum(sce$scDblFinder.class == "doublet")))
    }
    
    # Summarize
    qc_sum <- rbind(qc_sum, data.frame(
      Sample = sample,
      Pre_Cells = pre_cells,
      Post_Cells = post_cells,
      Removed_Pct = pct_rm,
      min_feat, max_feat, min_umi,
      max_mito,
      Method = method, MADs = mad_n
    ))
    
    obj_list[[i]] <- filt
  }
  
  # Save summary
  write.csv(qc_sum, file.path(outdir, "QC_summary_permissive.csv"), row.names = FALSE)
  if (rm_dbl && nrow(dbl_sum) > 0)
    write.csv(dbl_sum, file.path(outdir, "Doublet_summary.csv"), row.names = FALSE)
  
  # Return object
  if (merge_output && length(obj_list) > 1) {
    merged <- merge(x = obj_list[[1]], y = obj_list[-1], merge.data = TRUE)
    if (verbose) cat("\nðŸ”— Merged object returned.\n")
    if (verbose) cat("\nðŸ”— Join leyers.\n")
    #merged <- JoinLayers(merged)
    #merged <- fix_seurat_matrix_names(merged)
    return(merged)
  } else if (single) {
    if (verbose) cat("\nâœ… Returning single filtered object.\n")
    #obj_list[[1]] <- fix_seurat_matrix_names(obj_list[[1]])
    return(obj_list[[1]])
  } else {
    if (verbose) cat("\nâœ… Returning list of filtered objects.\n")
    return(obj_list)
  }
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Sex and Erythroid Contamination QC for Seurat Objects
#'
#' This function computes per-cell sex scores based on XIST and Y-linked gene expression,
#' flags sex-discordant cells, calculates erythroid contamination using canonical hemoglobin genes,
#' and filters cells that are both sex-discordant and above a specified erythroid threshold. Optional QC plots are produced.
#'
#' @param obj A Seurat object containing single-cell RNA-seq data.
#' @param sample_col Character. Column name in `obj@meta.data` corresponding to sample IDs. Default is "sample".
#' @param y_genes Character vector. List of Y-chromosome genes to use for sex score. Default is c("UTY","RPS4Y1","ZFY","DDX3Y","KDM5D").
#' @param xist_gene Character. Gene name for XIST. Default is "XIST".
#' @param eps Numeric. Small pseudocount added to avoid division by zero. Default is 1e-6.
#' @param female_thresh Numeric. Sex score threshold above which a cell is classified as female-like. Default is 1.
#' @param male_thresh Numeric. Sex score threshold below which a cell is classified as male-like. Default is -1.
#' @param eryth_genes Character vector. Canonical hemoglobin genes for erythroid contamination assessment. Default is c("HBB","HBA1","HBA2","HBE1","HBG1","HBG2","HBM").
#' @param eryth_percentile Numeric. Percentile to define high erythroid signal for filtering (0-1). Default is 0.95.
#' @param make_plots Logical. Whether to produce QC plots. Default is TRUE.
#' @param plot_prefix Character. Prefix for saved QC plot filenames. Default is "qc_".
#'
#' @return A list with the following components:
#' \item{object}{The input Seurat object with added metadata columns: sex_score, sex_call, eryth_sum, inferred_sex, sex_discordant.}
#' \item{filtered}{A Seurat object filtered to remove cells that are both sex-discordant and above the erythroid threshold.}
#' \item{summary}{A per-sample summary table including cell counts, fractions female/male/ambiguous, median sex score, fraction of cells with erythroid expression, and median erythroid sum.}
#' \item{eryth_threshold}{Numeric value corresponding to the threshold for high erythroid signal (computed from `eryth_percentile`).}
#' \item{n_removed}{Number of cells removed by filtering.}
#'
#' @examples
#' \dontrun{
#' qc <- sex_contamination_qc(obj, sample_col = "sample")
#' qc$summary
#' filtered_obj <- qc$filtered
#' }
#'
#' @import Seurat
#' @import dplyr
#' @import ggplot2
#' @export
sex_contamination_qc <- function(
    obj,
    sample_col = "sample",
    y_genes = c("UTY","RPS4Y1","ZFY","DDX3Y","KDM5D"),
    xist_gene = "XIST",
    eps = 1e-6,
    female_thresh = 1,
    male_thresh = -1,
    eryth_genes = c("HBB","HBA1","HBA2","HBE1","HBG1","HBG2","HBM"),
    majority_threshold = 0.5,
    eryth_percentile = 0.95,
    remove_ambiguous = TRUE,
    min_sex_score_diff = NULL,
    out_file = NULL
){
  cat("Extracting expression matrix (slot = data)...")
  Seurat::DefaultAssay(obj) <- "RNA"
  expr <- Seurat::GetAssayData(obj, slot = "data")
  meta_df <- obj@meta.data
  
  # 1. SEX SCORE
  cat("Computing sex scores...")
  
  meta_df$XIST <- if (xist_gene %in% rownames(expr)) expr[xist_gene, ] else 0
  
  y_present <- intersect(y_genes, rownames(expr))
  meta_df$Ysum <- if (length(y_present) > 0)
    Matrix::colSums(expr[y_present, , drop = FALSE])
  else 0
  
  meta_df$Ysum[is.na(meta_df$Ysum)] <- 0
  meta_df$XIST[is.na(meta_df$XIST)] <- 0
  
  meta_df$sex_score <- log2((meta_df$XIST + eps)/(meta_df$Ysum + eps))
  
  meta_df$sex_call <- ifelse(
    meta_df$sex_score > female_thresh, "Female-like",
    ifelse(meta_df$sex_score < male_thresh, "Male-like", "Ambiguous")
  )
  
  # 2. ERYTHROID SCORE
  cat("Computing erythroid scores...")
  
  eryth_present <- intersect(eryth_genes, rownames(expr))
  meta_df$eryth_sum <- if (length(eryth_present) > 0)
    Matrix::colSums(expr[eryth_present, , drop = FALSE])
  else 0
  
  meta_df$eryth_sum[is.na(meta_df$eryth_sum)] <- 0
  
  eryth_threshold <- as.numeric(
    stats::quantile(meta_df$eryth_sum, eryth_percentile, na.rm = TRUE)
  )
  
  # 3. SUMMARY PER SAMPLE
  cat("Summarizing per-sample sex composition...")
  
  tbl_summary <- meta_df %>%
    dplyr::group_by(.data[[sample_col]]) %>%
    dplyr::summarise(
      n_cells = dplyr::n(),
      frac_female_like = mean(sex_call == "Female-like"),
      frac_male_like   = mean(sex_call == "Male-like"),
      frac_ambiguous   = mean(sex_call == "Ambiguous"),
      median_sex_score = stats::median(sex_score),
      median_eryth_sum = stats::median(eryth_sum),
      .groups = "drop"
    )
  
  # 4. INFER SAMPLE SEX
  inferred <- tbl_summary %>%
    dplyr::mutate(inferred_sex =
                    ifelse(frac_female_like > majority_threshold, "Female", "Male")) %>%
    dplyr::select(.data[[sample_col]], inferred_sex) %>%
    tibble::deframe()
  
  meta_df$inferred_sex <- unname(inferred[meta_df[[sample_col]]])
  
  # 5. DISCORDANCE
  meta_df$sex_discordant <-
    (meta_df$inferred_sex == "Female" & meta_df$sex_call == "Male-like") |
    (meta_df$inferred_sex == "Male"   & meta_df$sex_call == "Female-like")
  
  if (!is.null(min_sex_score_diff)) {
    global_median <- stats::median(meta_df$sex_score, na.rm = TRUE)
    meta_df$strong_discordance <- meta_df$sex_discordant &
      abs(meta_df$sex_score - global_median) >= min_sex_score_diff
  } else {
    meta_df$strong_discordance <- meta_df$sex_discordant
  }
  
  # 6. FLAG CELLS FOR REMOVAL
  cat("Flagging cells for removal...")
  
  remove_cells <- meta_df$strong_discordance & (meta_df$eryth_sum > eryth_threshold)
  
  if (remove_ambiguous)
    remove_cells <- remove_cells | meta_df$sex_call == "Ambiguous"
  
  cat(sum(remove_cells), " cells flagged.")
  
  # 7. WRITE METADATA BACK
  obj <- Seurat::AddMetaData(obj, metadata = meta_df)
  
  # 8. SUBSET FILTERED OBJECT
  cat("Creating filtered object...")
  
  keep_cells <- rownames(meta_df)[!remove_cells]
  filt_obj <- subset(obj, cells = keep_cells)
  
  # 9. SUMMARY FOR OUTPUT
  removal_summary <- data.frame(
    sample = meta_df[[sample_col]],
    removed = remove_cells
  ) %>%
    dplyr::group_by(sample) %>%
    dplyr::summarise(
      n_removed = sum(removed),
      frac_removed = mean(removed),
      .groups = "drop"
    )
  
  tbl_summary <- tbl_summary %>%
    dplyr::left_join(removal_summary, by = "sample") %>%
    dplyr::mutate(eryth_threshold = eryth_threshold)
  
  # 10. OUTPUT FILE
  if (!is.null(out_file)) {
    utils::write.table(tbl_summary, file = out_file, sep = "\t",
                       quote = FALSE, row.names = FALSE)
  }
  
  # Fix deusat matrix names
  obj <- fix_seurat_matrix_names(obj)
  filt_obj <- fix_seurat_matrix_names(filt_obj)
  
  # 11. RETURN OUTPUT
  return(list(
    object = obj,
    filtered = filt_obj,
    tbl_summary = tbl_summary,
    eryth_threshold = eryth_threshold,
    n_removed = sum(remove_cells)
  ))
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
genefilter <- function(
    obj,
    mode = c("B","A","C"),
    keep.genes = c("MEG3"),
    excl.genes = NULL,
    assay = "RNA",
    normalize = TRUE,
    norm.method = "LogNormalize",
    scale.fac = 10000,
    find.hvg = TRUE,
    n.hvg = 2000,
    scale.data = TRUE,
    verbose = TRUE
){
  stopifnot(inherits(obj, "Seurat"))
  mode <- match.arg(mode)
  DefaultAssay(obj) <- assay
  
  genes <- rownames(obj[[assay]])
  
  # robust meta.features accessor (works for Seurat v5) 
  get_gene_biotype <- function(obj, assay) {
    assay_obj <- obj[[assay]]
    
    # Assay5: meta.features only exists if user added it
    if (!"meta.features" %in% slotNames(assay_obj)) {
      return(NULL)
    }
    mf <- assay_obj@meta.features
    if (is.null(mf) || nrow(mf) == 0) return(NULL)
    
    mf <- as.data.frame(mf)
    
    if (!"gene_biotype" %in% colnames(mf)) return(NULL)
    
    x <- mf$gene_biotype
    names(x) <- rownames(mf)
    return(x)
  }
  
  gb <- get_gene_biotype(obj, assay)
  
  # filtering rules 
  filters <- list(
    biotypes_rm = c(
      "lincRNA","lncRNA","antisense_RNA","processed_transcript",
      "pseudogene","processed_pseudogene","unprocessed_pseudogene",
      "transcribed_unprocessed_pseudogene","transcribed_processed_pseudogene",
      "unitary_pseudogene","Mt_rRNA","Mt_tRNA","rRNA"
    ),
    regex_rm = c(
      "^MT-",
      "^(RPL|RPS)[0-9]+",
      "^HB[ABDGEMQZ]",
      "^LINC[0-9]+",
      "^(AC|AL|AP|RP)[0-9]+",
      "^(CTD|CTC)-",
      "^LOC[0-9]+",
      "^C[0-9]+orf", "-AS[0-9]+$",
      "^FAM[0-9]+","^DAZ[0-9]+$",
      "^XXBAC", "^RPS4Y[12]$",
      "\\.[0-9]+$", "^TTTY[0-9]+$",
      "^ENSG[0-9]+$","^USP9Y$",
      "^XIST$", "^TSIX$",
      "^SRY$", "^ZFY$", "^UTY$"
    )
  )

  genes_up <- toupper(genes)
  names(genes_up) <- genes
  
  rm_biotype <- c()
  if (!is.null(gb)) {
    for (bt in filters$biotypes_rm)
      rm_biotype <- c(rm_biotype, names(gb)[gb == bt])
  }
  
  rm_regex <- c()
  for (rx in filters$regex_rm)
    rm_regex <- c(rm_regex, genes[grepl(rx, genes_up)])
  
  must_remove <- unique(c(rm_biotype, rm_regex))
  
  # keep sets 
  if (!is.null(gb)) {
    prot_ok <- names(gb)[gb == "protein_coding"]
  } else {
    prot_ok <- setdiff(genes, must_remove)
  }
  
  if (mode == "A") {
    keep <- prot_ok
  } else if (mode == "C") {
    keep <- setdiff(genes, must_remove)
  } else {
    keep <- union(prot_ok, keep.genes)
  }
  
  if (!is.null(excl.genes))
    keep <- setdiff(keep, excl.genes)
  
  keep <- setdiff(keep, must_remove)
  removed <- setdiff(genes, keep)
  
  if (verbose) {
    message("=== filter_genes (Seurat v5-safe) ===")
    message("Genes:", length(genes))
    message("Kept :", length(keep))
    message("Removed:", length(removed))
  }
  
  # subset + normalization 
  obj_f <- subset(obj, features = keep)
  
  if (normalize)
    obj_f <- NormalizeData(obj_f, normalization.method = norm.method, scale.factor = scale.fac)
  
  if (find.hvg)
    obj_f <- FindVariableFeatures(obj_f, nfeatures = n.hvg)
  
  if (scale.data)
    obj_f <- ScaleData(obj_f, features = VariableFeatures(obj_f))
  
  return(obj_f)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Filter Outliers in Seurat Clusters Using Local Density
#'
#' @description
#' Removes low-density (outlier) cells within specified clusters of a Seurat object,
#' based on k-nearest neighbor (KNN) distances in a given dimensional reduction (e.g., UMAP or PCA).
#' Optionally visualizes before/after filtering for each cluster and summarizes retained/removed cell counts.
#'
#' @param obj A Seurat object.
#' @param group.by Character string. Metadata column used to define clusters (default: `"seurat_clusters"`).
#' @param reduction Character string. Dimensional reduction to use (e.g., `"umap"`, `"pca"`).
#' @param density.threshold Numeric in (0,1). Quantile of local density defining cutoff (default: `0.95`).
#' @param k Integer. Number of neighbors for KNN-based local density (default: `30`).
#' @param relax Numeric multiplier (>1) to loosen the density threshold (default: `2`).
#' @param clean.all Logical. If `TRUE`, filter all clusters; otherwise specify `target.clusters`.
#' @param target.clusters Vector of cluster identities to clean. Ignored if `clean.all = TRUE`.
#' @param verbose Logical. Print progress and summary (default: `TRUE`).
#' @param color Color for highlighted cells in plots (default: `"red"`).
#' @param pt.size Point size for plotting (default: `1`).
#' @param base.size Base text size for plot titles (default: `10`).
#' @param ncol Integer. Number of columns for the combined plot layout (default: `2`).
#' @param return.plot Logical. Return combined patchwork plot (default: `FALSE`).
#'
#' @return A list with:
#' \itemize{
#'   \item \code{obj}: The filtered Seurat object.
#'   \item \code{summary}: A data.frame summarizing before/after cell counts per cluster.
#'   \item \code{plot}: (optional) Combined before/after UMAP visualization if `return.plot = TRUE`.
#' }
#'
#' @details
#' The function estimates local cell density for each cluster using mean KNN distances.
#' Cells below the density cutoff (low-density regions) are considered outliers and removed.
#' Clusters not listed in `target.clusters` remain untouched.
#'
#' @examples
#' \dontrun{
#' res <- filter_outliers(
#'   obj = obj,
#'   group.by = "seurat_clusters",
#'   target.clusters = c(0,1,2,3),
#'   reduction = "umap",
#'   density.threshold = 0.95,
#'   k = 30,
#'   relax = 2,
#'   verbose = TRUE,
#'   return.plot = TRUE
#' )
#' res$summary
#' print(res$plot)
#' }
#'
#' @import Seurat
#' @import FNN
#' @import patchwork
#' @export
filter_outliers <- function(obj,
                            group.by = "seurat_clusters",
                            reduction = "umap",
                            density.threshold = 0.95,
                            k = 30,
                            relax = 2,
                            clean.all = FALSE,
                            target.clusters = NULL,
                            verbose = TRUE,
                            color = "red",
                            pt.size = 1,
                            base.size = 10,
                            ncol = 2,
                            return.plot = FALSE) {
  
  require(Seurat)
  require(FNN)
  require(patchwork)
  
  #Checks
  if (!group.by %in% colnames(obj@meta.data))
    stop("Column ", group.by, " not found in metadata.")
  if (!reduction %in% Reductions(obj))
    stop("Reduction ", reduction, " not found in object.")
  
  obj <- SetIdent(obj, value = group.by)
  uniq.clust <- unique(na.omit(as.character(obj@meta.data[[group.by]])))
  
  if (clean.all) {
    clusts <- uniq.clust
  } else if (!is.null(target.clusters)) {
    bad <- setdiff(target.clusters, uniq.clust)
    if (length(bad) > 0) stop("Invalid clusters: ", paste(bad, collapse = ", "))
    clusts <- target.clusters
  } else {
    stop("Specify either clean.all = TRUE or target.clusters.")
  }
  
  if (verbose) cat("Processing clusters:", paste(clusts, collapse = ", "), "\n")
  
  #Loop
  all.keep <- c()
  plots <- list()
  summ <- data.frame()
  emb <- Embeddings(obj, reduction)
  
  for (cl in clusts) {
    cells <- rownames(obj@meta.data)[obj@meta.data[[group.by]] == cl]
    if (length(cells) < 2) next
    
    coord <- emb[cells, , drop = FALSE]
    kk <- min(k, length(cells) - 1)
    dens <- rowMeans(knn.dist(coord, k = kk), na.rm = TRUE)
    obj@meta.data[cells, "dens"] <- dens
    
    thr <- quantile(dens, density.threshold, na.rm = TRUE)
    keep <- cells[dens <= thr * relax]
    all.keep <- c(all.keep, keep)
    
    summ <- rbind(summ, data.frame(
      cluster = cl,
      before = length(cells),
      after = length(keep),
      removed = length(cells) - length(keep),
      pct.rm = round((1 - length(keep)/length(cells)) * 100, 2)
    ))
    
    p1 <- DimPlot(obj, reduction = reduction, group.by = group.by,
                  cells.highlight = cells, cols.highlight = color,
                  sizes.highlight = pt.size) +
      NoAxes() + NoLegend() +
      ggtitle(paste("Cluster", cl, "(n=", length(cells), ")")) +
      theme(plot.title = element_text(hjust = 0.5, size = base.size))
    
    p2 <- DimPlot(obj, reduction = reduction, group.by = group.by,
                  cells.highlight = keep, cols.highlight = color,
                  sizes.highlight = pt.size) +
      NoAxes() + NoLegend() +
      ggtitle(paste("Filtered", cl, "(n=", length(keep),
                    ")\nCutoff=", round(thr, 2), " K=", kk)) +
      theme(plot.title = element_text(hjust = 0.5, size = base.size))
    
    plots[[as.character(cl)]] <- p1 + p2 + patchwork::plot_layout(ncol = 2)
  }
  
  #Keep filtered + untouched clusters
  all.target <- rownames(obj@meta.data)[obj@meta.data[[group.by]] %in% clusts]
  other.cells <- setdiff(colnames(obj), all.target)
  keep.cells <- unique(c(all.keep, other.cells))
  filt <- subset(obj, cells = keep.cells)
  
  if (verbose) {
    cat("\n=== FILTER SUMMARY ===\n")
    print(summ, row.names = FALSE)
    cat("Total before:", ncol(obj), "\n")
    cat("Total after:", ncol(filt), "\n")
    cat("Removed:", ncol(obj) - ncol(filt), "\n")
  }
  
  if (return.plot) {
    combo <- wrap_plots(plots, ncol = ncol)
    return(list(obj = filt, summary = summ, plot = combo))
  } else {
    return(list(obj = filt, summary = summ))
  }
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
run_decontx <- function(
    input,
    assay_name = "RNA",
    verbose = TRUE,
    ...
) {
  library(Seurat)
  library(SingleCellExperiment)
  library(scater)
  library(celda)
  library(Matrix)
  
  # 1. LOAD INPUT
  if (inherits(input, "Seurat")) {
    if (verbose) cat("Input is a Seurat object\n")
    
    sce <- as.SingleCellExperiment(input)
    
    # extract original UMAP from Seurat
    if ("umap" %in% names(input@reductions)) {
      reducedDims(sce)$UMAP_before <- Embeddings(input, "umap")
      if (verbose) cat("UMAP_before extracted from Seurat\n")
    } else {
      reducedDims(sce)$UMAP_before <- NULL
      if (verbose) cat("No UMAP found in Seurat\n")
    }
    
  } else if (inherits(input, "SingleCellExperiment")) {
    
    sce <- input
    if (verbose) cat("Input is SingleCellExperiment\n")
    
    # preserve existing UMAP
    if ("UMAP" %in% names(reducedDims(sce))) {
      reducedDims(sce)$UMAP_before <- reducedDims(sce)$UMAP
      if (verbose) cat("UMAP_before extracted from SCE\n")
    } else {
      reducedDims(sce)$UMAP_before <- NULL
      if (verbose) cat("No UMAP present in SCE\n")
    }
    
  } else if (is.matrix(input) || inherits(input, "dgCMatrix")) {
    
    if (verbose) cat("Input is counts matrix\n")
    sce <- SingleCellExperiment(assays=list(counts=input))
    reducedDims(sce)$UMAP_before <- NULL
    
  } else {
    stop("Input must be Seurat, SCE, or matrix.")
  }
  
  # 2. RUN DECONTX
  if (verbose) cat("Running DecontX...\n")
  sce <- decontX(sce, ...)
  
  cleaned <- decontXcounts(sce)
  cleaned <- round(cleaned)
  
  # 3. COMPUTE UMAP_after (new)
  if (verbose) cat("Computing UMAP_after from DecontX-cleaned counts...\n")
  
  sce <- runUMAP(sce, exprs_values = "decontXcounts")
  reducedDims(sce)$UMAP_after <- reducedDims(sce)$UMAP
  reducedDims(sce)$UMAP <- NULL    # avoid confusion
  
  # 4. RETURN BOTH
  return(list(
    sce = sce,
    UMAP_before = reducedDims(sce)$UMAP_before,
    UMAP_after  = reducedDims(sce)$UMAP_after,
    cleaned_counts = cleaned
  ))
}



save_heatmap <- function(
    ht,
    filename,
    width = 8,
    height = 6,
    formats = c("pdf"),
    dpi = 600
) {
  
  stopifnot(!missing(ht))
  stopifnot(is.character(filename))
  stopifnot(is.numeric(width), is.numeric(height))
  
  for (fmt in formats) {
    
    fmt <- tolower(fmt)
    file_out <- paste0(filename, ".", fmt)
    
    if (fmt == "pdf") {
      
      pdf(
        file_out,
        width = width,
        height = height,
        useDingbats = FALSE
      )
      
    } else if (fmt == "png") {
      
      png(
        file_out,
        width = width,
        height = height,
        units = "in",
        res = dpi
      )
      
    } else if (fmt == "tiff") {
      
      tiff(
        file_out,
        width = width,
        height = height,
        units = "in",
        res = dpi,
        compression = "lzw"
      )
      
    } else if (fmt %in% c("jpg", "jpeg")) {
      
      jpeg(
        file_out,
        width = width,
        height = height,
        units = "in",
        res = dpi,
        quality = 100
      )
      
    } else {
      stop("Unsupported format: ", fmt)
    }
    
    # Draw AFTER opening device
    ComplexHeatmap::draw(ht)
    
    dev.off()
  }
  
  invisible(TRUE)
}



#' Fix matrix names in Seurat v5 objects (robust)
#'
#' Ensures that all matrices in a Seurat RNA assay (`layers`, `data`, `scale.data`)
#' have proper row and column names. Skips slots that do not exist or are empty.
#'
#' @param sobj A Seurat object
#' @return A Seurat object with all matrix names fixed
fix_seurat_matrix_names <- function(sobj) {
  assay <- sobj[["RNA"]]
  
  for (slot.name in c("layers", "data", "scale.data")) {
    # Handle layers specially
    if (slot.name == "layers" && !is.null(assay@layers$counts)) {
      mat <- assay@layers$counts
      if (!is.null(mat) && length(dim(mat)) == 2) {
        if (is.null(rownames(mat))) rownames(mat) <- rownames(assay)
        if (is.null(colnames(mat))) colnames(mat) <- colnames(sobj)
        assay@layers$counts <- mat
      }
    } 
    # Other slots
    else if (slot.name %in% slotNames(assay) && !is.null(slot(assay, slot.name))) {
      mat <- slot(assay, slot.name)
      if (!is.null(mat) && length(dim(mat)) == 2) {
        if (is.null(rownames(mat))) rownames(mat) <- rownames(assay)
        if (is.null(colnames(mat))) colnames(mat) <- colnames(sobj)
        slot(assay, slot.name) <- mat
      }
    }
  }
  
  sobj[["RNA"]] <- assay
  return(sobj)
}


# save_fig <- function(
#     filename,
#     fig = NULL,
#     layout = c("single", "double"),
#     type = c("ggplot", "heatmap", "baseplot"),
#     format = c("pdf", "png", "tiff"),
#     width = NULL,
#     height = NULL,
#     dpi = 300
# ){
#   layout <- match.arg(layout)
#   type <- match.arg(type)
#   format <- match.arg(format)
#   
#   # Nature Communications sizing
#   default_width <- ifelse(layout == "single", 3.5, 7.2)  # inches
#   default_height <- ifelse(type %in% c("heatmap", "baseplot"), 8, 5)
#   
#   width <- width %||% default_width
#   height <- height %||% default_height
#   
#   # Ensure filename extension matches format
#   if(!grepl(paste0("\\.", format, "$"), filename))
#     filename <- paste0(filename, ".", format)
#   
#   cat("Saving ", filename,
#           "\n layout=", layout,
#           "\n type=", type,
#           "\n size=", width, "Ã—", height, " inches @ DPI=", dpi)
#   
#   # PDF output
#   if(format == "pdf") {
#     pdf(filename, width = width, height = height, useDingbats = FALSE)
#     if(type == "ggplot") print(fig)
#     if(type %in% c("heatmap", "baseplot")) eval(fig)
#     dev.off()
#     return(invisible(filename))
#   }
#   
#   # PNG / TIFF
#   if(format %in% c("png", "tiff")) {
#     if(type == "ggplot") {
#       ggsave(filename, plot = fig, width = width, height = height,
#              units = "in", dpi = dpi)
#     } else if(type %in% c("heatmap", "baseplot")) {
#       if(format == "png") png(filename, width = width, height = height,
#                               units = "in", res = dpi)
#       if(format == "tiff") tiff(filename, width = width, height = height,
#                                 units = "in", res = dpi, compression = "lzw")
#       eval(fig)
#       dev.off()
#     }
#   }
#   
#   invisible(filename)
# }


# save_fig <- function(
#     filename,
#     fig = NULL,
#     layout = c("single", "double"),
#     type = c("ggplot", "heatmap", "baseplot"),
#     format = c("pdf", "png", "tiff"),
#     width = NULL,
#     height = NULL,
#     dpi = 300
# ){
#   layout <- match.arg(layout)
#   type <- match.arg(type)
#   format <- match.arg(format)
#   
#   # Nature Communications sizing defaults
#   default_width <- ifelse(layout == "single", 3.5, 7.2)  # inches
#   default_height <- ifelse(type %in% c("heatmap", "baseplot"), 8, 5)
#   
#   width <- width %||% default_width
#   height <- height %||% default_height
#   
#   # Ensure filename extension matches format
#   if(!grepl(paste0("\\.", format, "$"), filename)) {
#     filename <- paste0(filename, ".", format)
#   }
#   
#   cat("Saving ", filename,
#       "\n layout=", layout,
#       "\n type=", type,
#       "\n size=", width, "Ã—", height, " inches @ DPI=", dpi, "\n")
#   
#   # PDF output
#   if(format == "pdf") {
#     pdf(filename, width = width, height = height, useDingbats = FALSE)
#     if(type == "ggplot") print(fig)
#     if(type %in% c("heatmap", "baseplot")) eval(fig)
#     dev.off()
#     return(invisible(filename))
#   }
#   
#   # PNG / TIFF output
#   if(format %in% c("png", "tiff")) {
#     if(type == "ggplot") {
#       ggsave(filename, plot = fig, width = width, height = height,
#              units = "in", dpi = dpi)
#     } else if(type %in% c("heatmap", "baseplot")) {
#       if(format == "png") {
#         png(filename, width = width, height = height, units = "in", res = dpi)
#       }
#       if(format == "tiff") {
#         tiff(filename, width = width, height = height, units = "in", res = dpi, compression = "lzw")
#       }
#       eval(fig)
#       dev.off()
#     }
#   }
#   
#   invisible(filename)
# }

savefig <- function(
    filename,
    fig = NULL,
    layout = c("single", "double"),
    type = c("ggplot", "heatmap", "baseplot"),
    format = c("pdf", "png", "tiff"),
    width = NULL,
    height = NULL,
    dpi = 600
){
  layout <- match.arg(layout)
  type <- match.arg(type)
  formats <- format   # allow vector of formats
  
  # Nature Communications sizing defaults
  default_width <- ifelse(layout == "single", 3.5, 7.2)
  default_height <- ifelse(type %in% c("heatmap", "baseplot"), 8, 5)
  
  width <- width %||% default_width
  height <- height %||% default_height
  
  for(fmt in formats) {
    
    out_file <- filename
    if(!grepl(paste0("\\.", fmt, "$"), out_file))
      out_file <- paste0(out_file, ".", fmt)
    
    cat("Saving ", out_file,
        "\n layout=", layout,
        "\n type=", type,
        "\n size=", width, "Ã—", height, " inches @ DPI=", dpi,
        "\n format=", fmt, "\n\n")
    
    # PDF
    if(fmt == "pdf") {
      pdf(out_file, width = width, height = height, useDingbats = FALSE)
      if(type == "ggplot") print(fig)
      if(type %in% c("heatmap", "baseplot")) eval(fig)
      dev.off()
      next
    }
    
    # PNG / TIFF
    if(fmt %in% c("png", "tiff")) {
      if(type == "ggplot") {
        ggsave(out_file, plot = fig,
               width = width, height = height,
               units = "in", dpi = dpi)
        
      } else if(type %in% c("heatmap", "baseplot")) {
        
        if(fmt == "png")
          png(out_file, width = width, height = height, units = "in", res = dpi)
        
        if(fmt == "tiff")
          tiff(out_file, width = width, height = height, units = "in",
               res = dpi, compression = "lzw")
        
        eval(fig)
        dev.off()
      }
    }
  }
  
  invisible(filename)
}



#' Colorize Values Using Various Color Palettes
#'
#' This function assigns colors to unique values in a vector using a variety of distinct and continuous color palettes.  
#' It supports both discrete and continuous color schemes, including RColorBrewer, Viridis, and custom palettes.
#'
#' @param x A vector of values to be colorized.
#' @param theme A string specifying the color theme. Available themes:
#'   * **Distinct palettes**: `"alphabet"`, `"tube"`, `"tol"`, `"glasbey"`, `"tableau"`, `"bright"`, `"pastel"`, `"cList"``
#'   * **RColorBrewer palettes**:
#'     - *Sequential*: `"Blues"`, `"BuGn"`, `"BuPu"`, `"GnBu"`, `"Greens"`, `"Greys"`, `"Oranges"`, `"OrRd"`, `"PuBu"`,
#'                     `"PuBuGn"`, `"PuRd"`, `"Purples"`, `"RdPu"`, `"Reds"`, `"YlGn"`, `"YlGnBu"`, `"YlOrBr"`, `"YlOrRd"`
#'     - *Qualitative*: `"Accent"`, `"Dark2"`, `"Paired"`, `"Pastel1"`, `"Pastel2"`, `"Set1"`, `"Set2"`, `"Set3"`
#'     - *Divergent*: `"BrBG"`, `"PiYG"`, `"PRGn"`, `"PuOr"`, `"RdBu"`, `"RdGy"`, `"RdYlBu"`, `"RdYlGn"`, `"Spectral"`
#'   * **Viridis palettes**: `"viridis"`, `"magma"`, `"plasma"`, `"cividis"`, `"inferno"`
#'   * **Random colors**: `"random"`
#' @param bgval A value in `x` that should be assigned a background color (`"#CCCCCC"` by default). Default is `NULL` (no special background value).
#' @param n_colors Number of colors to generate for continuous palettes. Default is `100`.
#'
#' @return A named vector of hex color codes, where names correspond to unique values in `x`.
#'
#' @examples
#' # Apply Viridis color palette
#' colorize(1:10, theme = "viridis")
#'
#' # Apply RColorBrewer "Blues" palette
#' colorize(letters[1:10], theme = "Blues")
#'
#' # Use a distinct color palette (Glasbey)
#' colorize(1:15, theme = "glasbey")
#'
#' @import viridis
#' @import RColorBrewer
#' @export
colorize <- function(x, theme = "alphabet", bgval = NULL, n_colors = 100, reverse = FALSE) {
  
  require(viridis)
  require(RColorBrewer)
  
  # Define distinct color palettes
  color_alphabet <- matrix(c(
    240, 163, 255, 0, 117, 220, 153, 63, 0, 76, 0, 92, 0, 92, 49, 43, 206, 72, 255, 204, 153,
    128, 128, 128, 148, 255, 181, 143, 124, 0, 157, 204, 0, 194, 0, 136, 0, 51, 128, 255, 164, 5,
    255, 168, 187, 66, 102, 0, 255, 0, 16, 94, 241, 242, 0, 153, 143, 224, 255, 102, 116, 10, 255,
    153, 0, 0, 255, 255, 128, 255, 255, 0, 255, 80, 5
  ), ncol = 3, byrow = TRUE) / 256
  
  tube_colors <- c(
    "#B36305", "#E32017", "#FFD300", "#00782A", "#F3A9BB",
    "#A0A5A9", "#9B0056", "#000000", "#003688", "#0098D4",
    "#95CDBA", "#00A4A7", "#EE7C0E", "#84B817", "#E21836",
    "#7156A5"
  )
  
  tol_colors <- c(
    "#332288", "#88CCEE", "#44AA99", "#117733", "#999933",
    "#DDCC77", "#CC6677", "#882255", "#AA4499", "#DDDDDD",
    "#E69F00", "#56B4E9"
  )
  
  glasbey_colors <- c(
    "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF",
    "#00FFFF", "#800000", "#808000", "#008000", "#800080",
    "#808080", "#C0C0C0", "#008080", "#000080", "#FFA500"
  )
  
  tableau_colors <- c(
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD",
    "#8C564B", "#E377C2", "#BCBD22", "#17BECF",
    "#AEC7E8", "#FFBB78", "#98DF8A", "#FF9896", "#C5B0D5",
    "#C49C94", "#F7B6D2", "#DBDB8D", "#9EDAE5"
  )
  
  bright_colors <- c(
    "#E6194B", "#3CB44B", "#FFE119", "#4363D8", "#F58231",
    "#911EB4", "#42D4F4", "#F032E6", "#BFEF45", "#FABEBE"
  )
  
  pastel_colors <- c(
    "#FFB3BA", "#FFDFBA", "#FFFFBA", "#BAFFC9", "#BAE1FF",
    "#E6C0E9", "#D9C3A1", "#C4E5F5", "#F6D7A7", "#D1E8E2"
  )
  
  cList = list(c("grey85","#FFF7EC","#FEE8C8","#FDD49E","#FDBB84",
                 "#FC8D59","#EF6548","#D7301F","#B30000","#7F0000"),
               c("#4575B4","#74ADD1","#ABD9E9","#E0F3F8","#FFFFBF",
                 "#FEE090","#FDAE61","#F46D43","#D73027")[c(1,1:9,9)],
               c("#FDE725","#AADC32","#5DC863","#27AD81","#21908C",
                 "#2C728E","#3B528B","#472D7B","#440154"))
  
  # cList = c("grey85","#FFF7EC","#FEE8C8","#FDD49E","#FDBB84", "#FC8D59","#EF6548","#D7301F","#B30000","#7F0000", "#4575B4","#74ADD1","#ABD9E9","#E0F3F8","#FFFFBF", 
  #                "#FEE090","#FDAE61","#F46D43","#D73027", "#FDE725","#AADC32","#5DC863","#27AD81","#21908C", "#2C728E","#3B528B","#472D7B","#440154")
  
  viridis_colors <- viridis(n_colors, option = "viridis")
  magma_colors <- viridis(n_colors, option = "magma")
  plasma_colors <- viridis(n_colors, option = "plasma")
  inferno_colors <- viridis(n_colors, option = "inferno")
  cividis_colors <- viridis(n_colors, option = "cividis")
  
  brewer_palettes <- c('Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens', 'Greys', 'Oranges', 'OrRd', 'PuBu', 
                       'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd', 
                       "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3", 
                       "BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral")
  
  set.seed(42)
  random_colors <- rgb(runif(n_colors), runif(n_colors), runif(n_colors))
  
  # Choose color theme
  if (theme == "alphabet") {
    colors <- apply(rbind(color_alphabet, 1 - (1 - color_alphabet) / 2, color_alphabet / 2), 1, 
                    function(row) rgb(row[1], row[2], row[3]))
  } else if (theme == "tube") {
    colors <- tube_colors
  } else if (theme == "cList") {
    colors <- cList
  } else if (theme == "tol") {
    colors <- tol_colors
  } else if (theme == "glasbey") {
    colors <- glasbey_colors
  } else if (theme == "tableau") {
    colors <- tableau_colors
  } else if (theme == "bright") {
    colors <- bright_colors
  } else if (theme == "pastel") {
    colors <- pastel_colors
  } else if (theme == "random") {
    colors <- random_colors
  } else if (theme %in% brewer_palettes) {
    colors <- colorRampPalette(brewer.pal(8, theme))(n_colors) 
  } else if (theme == "viridis") {
    colors <- viridis_colors
  } else if (theme == "magma") {
    colors <- magma_colors
  } else if (theme == "plasma") {
    colors <- plasma_colors
  } else if (theme == "cividis") {
    colors <- cividis_colors
  } else if (theme == "inferno") {
    colors <- inferno_colors
  } else {
    stop("Invalid theme.")
  }
  
  # Reverse colors if needed
  if (reverse) {
    colors <- rev(colors)
  }
  
  unique_vals <- unique(x)
  encoded_vals <- match(x, unique_vals) - 1
  colors <- colors[(encoded_vals %% length(colors)) + 1]
  
  if (!is.null(bgval)) {
    colors[x == bgval] <- "#CCCCCC"
  }
  
  names(colors) <- unique_vals
  return(colors)
}


# Utility: %||%
`%||%` <- function(a, b) if(!is.null(a)) a else b



#' Safe subset of Seurat object
#'
#' Wrapper around Seurat::subset that fixes matrix names automatically.
#'
#' @param sobj Seurat object
#' @param ... Arguments passed to Seurat::subset
#' @return Subsetted Seurat object
get_subset <- function(sobj, group.by = NULL, invert = FALSE,...) {
  if (!is.null(group.by)) sobj <- SetIdent(sobj, value = group.by)
  sobj2 <- subset(sobj, invert = invert,...)
  sobj2 <- fix_seurat_matrix_names(sobj2)
  return(sobj2)
}

#' Safe merge of Seurat objects
#'
#' Wrapper around Seurat::merge that fixes matrix names automatically.
#'
#' @param x Seurat object
#' @param y Seurat object
#' @param ... Additional arguments to Seurat::merge
#' @return Merged Seurat object
get_merge <- function(obj.list) {
  if (length(obj.list) == 0) stop("No Seurat objects provided")
  merged <- Reduce(merge, obj.list)
  merged <- JoinLayers(merged)
  assay <- merged[["RNA"]]
  assay@layers$counts <- GetAssayData(merged, slot = "counts")
  merged[["RNA"]] <- assay
  merged <- fix_seurat_matrix_names(merged)
  return(merged)
}

#' Load multiple 10X/Seurat samples with optional merge and save
#'
#' @param sample.dirs Character vector of sample folder names
#' @param parent.dir Parent directory containing sample folders
#' @param use.filtered Logical, whether to use filtered matrices (default TRUE)
#' @param save.dir Directory to save individual Seurat objects (default NULL)
#' @param merge Logical, whether to merge all Seurat objects (default FALSE)
#' @return List of Seurat objects or a single merged Seurat object
#' @examples
#' objs <- load_seurat(c("FN_S1256","FN_S3478"), parent.dir = "data/processed")
load_seurat <- function(sample.dirs, parent.dir, use.filtered = TRUE, save.dir = NULL, merge = FALSE) {
  library(Seurat)
  library(Matrix)
  
  load_one <- function(sample.name) {
    cat("\n[INFO] Loading sample:", sample.name, "\n")
    samp.path <- file.path(parent.dir, sample.name)
    if (!dir.exists(samp.path)) stop("[ERROR] Sample folder not found: ", samp.path, "\n")
    
    # List possible candidates
    candidates <- list.files(samp.path, recursive = TRUE, full.names = TRUE)
    if (use.filtered) {
      candidates <- candidates[grepl("filtered_feature_bc_matrix$|filtered_feature_bc_matrix.h5$", candidates)]
    } else {
      candidates <- candidates[grepl("raw_feature_bc_matrix$|raw_feature_bc_matrix.h5$", candidates)]
    }
    
    if (length(candidates) == 0) stop("[ERROR] No valid 10X input found for sample: ", sample.name, "\n")
    
    # Prioritize H5 file
    h5.file <- candidates[grepl("\\.h5$", candidates)]
    counts <- if (length(h5.file) > 0) {
      cat("  Reading from H5 file:", basename(h5.file[1]), "\n")
      Seurat::Read10X_h5(h5.file[1])
    } else {
      cat("  Reading from folder:", basename(candidates[1]), "\n")
      Seurat::Read10X(candidates[1])
    }
    
    # Create Seurat object
    cat("  Creating Seurat object...\n")
    sobj <- Seurat::CreateSeuratObject(counts = counts, project = sample.name)
    
    # Fix matrix names
    cat("  Fixing Seurat matrix names...\n")
    sobj <- fix_seurat_matrix_names(sobj)
    
    cat("  Sample loaded: ", ncol(sobj), "cells x", nrow(sobj), "features.\n")
    return(sobj)
  }
  
  cat("[INFO] Starting to load all samples...\n")
  objs <- setNames(lapply(sample.dirs, load_one), sample.dirs)
  cat("[INFO] All samples loaded.\n")
  
  if (!is.null(save.dir)) {
    dir.create(save.dir, recursive = TRUE, showWarnings = FALSE)
    cat("[INFO] Saving individual Seurat objects to:", save.dir, "\n")
    invisible(lapply(names(objs), function(n) {
      saveRDS(objs[[n]], file.path(save.dir, paste0(n, ".rds")))
    }))
    cat("[INFO] All objects saved.\n")
  }
  
  if (merge && length(objs) > 1) {
    cat("[INFO] Merging Seurat objects...\n")
    merged <- Reduce(safe.merge, objs)
    cat("[INFO] Merged object dimensions:", ncol(merged), "cells x", nrow(merged), "features.\n")
    merged <- fix_seurat_matrix_names(merged)
    cat("[INFO] Matrix names fixed in merged object.\n")
    return(merged)
  } else {
    return(objs)
  }
}

#' Split a Seurat object by metadata and fix matrix names
#'
#' @param object A Seurat object
#' @param split.by Metadata column name to split by
#' @return A named list of Seurat objects with @layers$counts fixed
#' @examples
#' seurat.list <- split_seurat_objects(merged, split.by = "BulkSample")
split_seurat_objects <- function(object, split.by) {
  require(Seurat)
  
  objs <- Seurat::SplitObject(object, split.by = split.by)
  
  objs <- lapply(objs, function(sobj) {
    # Ensure @layers$counts exist
    assay <- sobj[["RNA"]]
    assay@layers$counts <- Seurat::GetAssayData(sobj, slot = "counts")
    sobj[["RNA"]] <- assay
    
    # Fix row/colnames
    sobj <- fix_seurat_matrix_names(sobj)
    return(sobj)
  })
  
  return(objs)
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Subset a Seurat object with optional multi-condition filtering, normalization, PCA/Harmony, and clustering
#'
#' This function subsets a Seurat object either by identities (`idents`) or by a complex boolean expression
#' (`subset_expr`) evaluated on `meta.data`. After subsetting, it optionally performs normalization,
#' variable feature selection, scaling, PCA or Harmony integration, neighbor graph construction, clustering,
#' and UMAP embedding. It is particularly suitable for integrated datasets.
#'
#' @param object A Seurat object to subset and preprocess.
#' @param idents Optional character or numeric vector of identities to subset by (see `Seurat::subset`).
#' @param invert Logical; whether to invert the identity-based subsetting. Default is FALSE.
#' @param group.by Optional metadata column to temporarily set as active identities for subsetting.
#' @param subset_conditions Optional logical expression evaluated in `meta.data` to select cells. Can handle
#' multiple conditions, e.g. `sample %in% c("AD-23425","CTRL-26450") & ann_level_3 %in% c("Alpha1-tany")`.
#' @param use.harmony Logical; whether to run Harmony integration after subsetting. Default TRUE.
#' @param harmony.group Character; metadata column used for Harmony batch integration. Default "orig.ident".
#' @param ndims Integer; number of dimensions to use for PCA/Harmony and downstream graph construction. Default 50.
#' @param resolution Numeric; clustering resolution for `FindClusters`. Default 0.5.
#' @param min.dist Numeric; minimum distance parameter for UMAP. Default 0.3.
#' @param spread Numeric; spread parameter for UMAP. Default 1.
#'
#' @return A Seurat object containing only the selected cells, with updated PCA/Harmony, clustering, and UMAP embeddings.
#'
#' @examples
#' \dontrun{
#' sub <- seurat_subset(
#'   object = obj,
#'   subset_expr = sample %in% c("FTD-21032","CTRL-26450") &
#'                 ann_level_3 %in% c("Alpha1-tany","Beta1-tany"),
#'   use.harmony = TRUE,
#'   harmony.group = "orig.ident",
#'   min.dist = 0.5
#' )
#' DimPlot(sub, group.by = "sample")
#' }
#'
#' @export
#' 
seurat_subset <- function(
    object,
    idents = NULL,
    invert = FALSE,
    group.by = NULL,
    subset_conditions = NULL,    # list of column = vector to filter on
    use.harmony = TRUE,
    harmony.group = "orig.ident",
    ndims = 50,
    resolution = 0.5,
    min.dist = 0.3,
    spread = 1
){
  stopifnot(inherits(object, "Seurat"))
  
  # Set identities for subsetting
  if (!is.null(group.by)) object <- SetIdent(object, value = group.by)
  
  DefaultAssay(object) <- "RNA"
  
  # Subset by meta.data conditions safely
  if (!is.null(subset_conditions)) {
    md <- object@meta.data
    keep_cells <- rownames(md)
    
    for (col in names(subset_conditions)) {
      vals <- subset_conditions[[col]]
      if (!col %in% colnames(md)) stop(paste("Column", col, "not found in meta.data"))
      keep_cells <- keep_cells[md[keep_cells, col] %in% vals]
    }
    
    object <- object[, keep_cells]
  }
  
  # Standard Seurat subsetting via idents
  if (!is.null(idents)) {
    object <- subset(object, idents = idents, invert = invert)
  }
  
  # Basic preprocessing
  object <- NormalizeData(object)
  object <- FindVariableFeatures(object)
  object <- ScaleData(object)
  
  # PCA or Harmony
  if (use.harmony) {
    object <- harmony::RunHarmony(object, group.by.vars = harmony.group)
    red <- "harmony"
  } else {
    object <- RunPCA(object, npcs = ndims)
    red <- "pca"
  }
  
  # Graph + clustering
  object <- FindNeighbors(object, dims = 1:ndims, reduction = red)
  object <- FindClusters(object, resolution = resolution)
  
  # Auto-select PCs (optional helper)
  if (exists("get_pcs")) {
    ndims <- get_pcs(object, reduction.name = red)
  }
  
  # UMAP
  object <- RunUMAP(
    object,
    dims = 1:ndims,
    reduction = red,
    min.dist = min.dist,
    spread = spread
  )
  
  DefaultAssay(object) <- "RNA"
  object <- fix_seurat_matrix_names(object)
  
  return(object)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Select cells from a Seurat object based on gene expression, clusters, and metadata
#'
#' @description
#' `cellpick()` selects cells from a Seurat object using positive and/or negative
#' gene expression criteria, optional cluster restrictions, and flexible metadata
#' filtering (categorical or numeric ranges).
#'
#' @param obj A Seurat object.
#' @param pos.genes Character vector of genes that should be expressed.
#' @param neg.genes Character vector of genes that must NOT be expressed (default NULL).
#' @param slot Assay slot to use for expression values (default "data").
#' @param expr.thresh Numeric expr.thresh above which a gene is considered expressed (default 0).
#' @param min.genes Minimum number of `pos.genes` that must be expressed
#'   (default 1; use length(pos.genes) to require all).
#' @param clusters Optional vector of cluster IDs to retain (default NULL).
#' @param cluster.col Metadata column containing cluster identities
#'   (default NULL; uses `Idents(obj)`).
#' @param meta.col Metadata column to filter on (default NULL).
#' @param meta.vals Values or numeric range (length 2) used to filter `meta.col`.
#' @param return.obj Logical; if TRUE, return a Seurat object subset
#'   instead of cell names (default FALSE).
#' @param verbose Logical; print filtering diagnostics (default FALSE).
#'
#' @return
#' Character vector of selected cell names, or a Seurat object if `return.obj = TRUE`.
#'
#' @export
#'
#' @examples
#' # Olfactory HBC selection
#' cells <- cellpick(
#'   obj,
#'   pos.genes = c("TP63", "KRT5", "KRT14"),
#'   neg.genes = c("KRT13"),
#'   min.genes = 2,
#'   cluster.col = "seurat_clusters",
#'   clusters = 16,
#'   meta.col = "group",
#'   meta.vals = c("PCW10", "PCW12"),
#'   verbose = TRUE
#' )
cellpick <- function(
    obj,
    pos.genes,
    neg.genes = NULL,
    slot = "data",
    expr.thresh = 0,
    min.genes = 1,
    clusters = NULL,
    cluster.col = NULL,
    meta.col = NULL,
    meta.vals = NULL,
    return.obj = FALSE,
    verbose = FALSE
) {
  
  stopifnot(inherits(obj, "Seurat"))
  stopifnot(length(pos.genes) >= 1)
  
  # Expression matrix
  mat <- Seurat::GetAssayData(obj, slot = slot)
  
  missing <- setdiff(pos.genes, rownames(mat))
  if (length(missing) > 0) {
    stop("Positive gene(s) not found: ", paste(missing, collapse = ", "))
  }
  
  # 2. Positive gene filtering
  expr.pos <- mat[pos.genes, , drop = FALSE] > expr.thresh
  keep.pos <- Matrix::colSums(expr.pos) >= min.genes
  cells <- colnames(mat)[keep.pos]
  
  if (verbose) message("After positive genes: ", length(cells))
  
  # Negative gene filtering
  if (!is.null(neg.genes)) {
    missing.neg <- setdiff(neg.genes, rownames(mat))
    if (length(missing.neg) > 0) {
      stop("Negative gene(s) not found: ", paste(missing.neg, collapse = ", "))
    }
    
    expr.neg <- mat[neg.genes, , drop = FALSE] > expr.thresh
    keep.neg <- Matrix::colSums(expr.neg) == 0
    cells <- intersect(cells, colnames(mat)[keep.neg])
    
    if (verbose) message("After negative genes: ", length(cells))
  }
  
  # Cluster restriction
  if (!is.null(clusters)) {
    clust <- if (is.null(cluster.col)) {
      as.character(Seurat::Idents(obj))
    } else {
      if (!cluster.col %in% colnames(obj@meta.data)) {
        stop("cluster.col not found in obj@meta.data")
      }
      as.character(obj@meta.data[[cluster.col]])
    }
    
    names(clust) <- colnames(obj)
    cells <- intersect(cells, names(clust)[clust %in% clusters])
    
    if (verbose) message("After cluster filter: ", length(cells))
  }
  
  # Metadata filtering (generalized)
  if (!is.null(meta.col)) {
    if (!meta.col %in% colnames(obj@meta.data)) {
      stop("meta.col not found in obj@meta.data")
    }
    if (is.null(meta.vals)) {
      stop("meta.vals must be provided when meta.col is used")
    }
    
    meta <- obj@meta.data[[meta.col]]
    names(meta) <- colnames(obj)
    
    # Attempt numeric coercion for character metadata
    meta.num <- suppressWarnings(as.numeric(gsub("[^0-9.-]", "", meta)))
    
    if (all(!is.na(meta.num)) && length(meta.vals) == 2) {
      keep.meta <- meta.num >= meta.vals[1] & meta.num <= meta.vals[2]
    } else {
      keep.meta <- meta %in% meta.vals
    }
    
    cells <- intersect(cells, names(meta)[keep.meta])
    
    if (verbose) message("After metadata filter: ", length(cells))
  }
  
  # Return
  if (return.obj) {
    return(subset(obj, cells = cells))
  }
  
  return(cells)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'#' Compute OR Gene Dominance Scores in Single-Cell RNA-seq Data
#'
#' This function computes a dominance score for olfactory receptor (OR) genes in each cell
#' of a Seurat object. The dominance score quantifies how strongly the top-expressed OR
#' dominates over the second-most expressed OR, adjusted for sparse single-cell expression.
#'
#' @param seurat_obj A Seurat object containing single-cell RNA-seq data.
#' @param or_genes A character vector of OR gene names to consider.
#' @param assay Character; the assay name in Seurat object (default: "RNA").
#' @param slot Character; the assay slot to use (default: "data").
#' @param epsilon Numeric; a small number to prevent division by zero (default: 1e-9).
#' @param scale_factor Numeric; multiplier for top OR expression to scale dominance (default: 10).
#' @param exponent Numeric; exponent to raise the scaled log expression (default: 1).
#'
#' @return A data frame with one row per cell containing:
#'   \describe{
#'     \item{top_expr}{Expression of the top-expressed OR gene.}
#'     \item{second_expr}{Expression of the second-highest OR gene.}
#'     \item{dominance_score}{Computed dominance score.}
#'     \item{cell}{Cell barcode or identifier.}
#'     \item{n_OR_expressed}{Number of OR genes with nonzero expression in the cell.}
#'     \item{PCW}{PCW metadata from the Seurat object.}
#'     \item{cluster}{Cell identity from Seurat object.}
#'     \item{cell_group}{Coarse cell grouping (mOSN, iOSN, Others).}
#'     \item{dominance_bin}{Binned dominance score (0â€“1, 1â€“2, â€¦, >6).}
#'   }
#'
#' @examples
#' \dontrun{
#' Idents(sub) <- "ann_level_2"
#' or_genes <- intersect(ORs$Gene_name, rownames(sub))
#' df <- compute_OR_dominance(sub, or_genes)
#' head(df)
#' table(df$dominance_bin)
#' }
#'
#' @export
#' 
compute_OR_dominance <- function(
    seurat_obj,
    or_genes,
    assay = "RNA",
    slot = "data",
    epsilon = 1e-9,
    scale_factor = 10,
    exponent = 1
){
  # --- Load required packages ---
  require(dplyr)
  require(Seurat)
  require(rlang)
  
  # --- Filter OR genes present in Seurat object ---
  or_genes <- intersect(or_genes, rownames(seurat_obj))
  if(length(or_genes) == 0) stop("No OR genes found in the Seurat object.")
  
  # --- Extract expression matrix ---
  or_mat <- as.matrix(GetAssayData(seurat_obj, assay = assay, slot = slot)[or_genes, , drop = FALSE])
  
  # --- Function to compute scaled dominance per cell ---
  compute_scaled_dominance <- function(x) {
    x_sorted <- sort(x, decreasing = TRUE)
    x1 <- x_sorted[1]
    x2 <- ifelse(length(x_sorted) >= 2, x_sorted[2], 0)
    
    if (x1 == 0) return(c(top_expr = 0, second_expr = 0, dominance_score = 0))
    
    # --- Scaled for sparse single-cell data ---
    score <- ((x1 - x2) / (x1 + x2 + epsilon)) * (log1p(scale_factor * x1) ^ exponent)
    return(c(top_expr = x1, second_expr = x2, dominance_score = score))
  }
  
  # --- Apply dominance calculation to all cells ---
  dom_vals <- t(apply(or_mat, 2, compute_scaled_dominance))
  dom_vals <- as.data.frame(dom_vals)
  
  # --- Ensure correct column names ---
  colnames(dom_vals) <- c("top_expr", "second_expr", "dominance_score")
  
  # --- Construct output dataframe ---
  df <- dom_vals %>%
    mutate(
      cell = colnames(or_mat),
      n_OR_expressed = colSums(or_mat > 0),
      PCW = seurat_obj$PCW,
      cluster = Idents(seurat_obj)
    ) %>%
    mutate(
      cell_group = case_when(
        cluster %in% c("GBC") ~ "GBC",
        cluster %in% c("INP") ~ "INP",
        cluster %in% c("iOSN") ~ "iOSN",
        TRUE ~ "Others"
      ),
      dominance_bin = cut(
        dominance_score,
        breaks = c(0, 1, 2, 3, 4, 5, 6, Inf),
        labels = c("0â€“1", "1â€“2", "2â€“3", "3â€“4", "4â€“5", "5â€“6", ">6"),
        right = FALSE,
        include.lowest = TRUE
      )
    )
  
  return(df)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
vcf_correlation <- function(cluster_vcf, reference_vcf,  outdir,  method = "Souporcell", column_title = NULL,
                                    column_title_side = "bottom",column_names_rot = 0,row_title = NULL, 
                            fontsize = 12, width = 4,  height = 3) {
  
  require(vcfR)
  require(dplyr)
  require(tidyr)
  require(ComplexHeatmap)
  require(RColorBrewer)
  require(ggplot2)
  require(readr)
  
  cat("Reading VCF files...\n")
  ref_geno <- read.vcfR(reference_vcf)
  cluster_geno <- read.vcfR(cluster_vcf)
  
  # Helper function to convert GP to DS if needed
  calculate_DS <- function(GP_df) {
    columns <- c()
    for (i in 1:ncol(GP_df)) {
      columns <- c(columns, paste0(colnames(GP_df)[i], "-0"), paste0(colnames(GP_df)[i], "-1"), paste0(colnames(GP_df)[i], "-2"))
    }
    df <- GP_df
    colnames(df) <- paste0("c", colnames(df))
    colnames_orig <- colnames(df)
    for (i in 1:length(colnames_orig)) {
      df <- separate(df, sep = ",", col = colnames_orig[i], into = columns[(1 + (3 * (i - 1))):(3 + (3 * (i - 1)))])
    }
    df <- mutate_all(df, function(x) as.numeric(as.character(x)))
    for (i in 1:ncol(GP_df)) {
      GP_df[, i] <- df[, (2 + ((i - 1) * 3))] + 2 * df[, (3 + ((i - 1) * 3))]
    }
    return(GP_df)
  }
  
  # Pearson correlation function with NA handling
  pearson_correlation <- function(df, ref_df, clust_df) {
    for (col in colnames(df)) {
      for (row in rownames(df)) {
        valid_pairs <- complete.cases(ref_df[[col]], clust_df[[row]])
        if (sum(valid_pairs) > 0) {
          df[row, col] <- cor(as.numeric(ref_df[[col]][valid_pairs]), as.numeric(clust_df[[row]][valid_pairs]), method = "pearson")
        } else {
          df[row, col] <- NA  # Assign NA if no valid pairs
        }
      }
    }
    return(df)
  }
  
  cat("Extracting genotype formats...\n")
  
  # Initialize format type
  format_clust <- NA
  cluster_geno_tidy <- as_tibble(extract.gt(element = "DS", cluster_geno, IDtoRowNames = F))
  
  if (!all(colSums(is.na(cluster_geno_tidy)) == nrow(cluster_geno_tidy))) {
    cat("Found DS genotype format in cluster VCF. Using DS for correlation.")
    format_clust <- "DS"
  }
  
  if (is.na(format_clust)) {
    cluster_geno_tidy <- as_tibble(extract.gt(element = "GT", cluster_geno, IDtoRowNames = F))
    if (!all(colSums(is.na(cluster_geno_tidy)) == nrow(cluster_geno_tidy))) {
      cat("Found GT genotype format in cluster VCF. Using GT for correlation.")
      format_clust <- "GT"
      separator <- ifelse(any(grepl("\\|", cluster_geno_tidy[1, ])), "|", "/")
      
      cluster_geno_tidy <- as_tibble(lapply(cluster_geno_tidy, function(x) {
        gsub(paste0("0", separator, "0"), 0, x)
      }) %>%
        lapply(., function(x) {
          gsub(paste0("0", separator, "1"), 1, x)
        }) %>%
        lapply(., function(x) {
          gsub(paste0("1", separator, "0"), 1, x)
        }) %>%
        lapply(., function(x) {
          gsub(paste0("1", separator, "1"), 2, x)
        }))
    }
  }
  
  if (is.na(format_clust)) {
    cluster_geno_tidy <- as_tibble(extract.gt(element = "GP", cluster_geno, IDtoRowNames = F))
    if (!all(colSums(is.na(cluster_geno_tidy)) == nrow(cluster_geno_tidy))) {
      format_clust <- "GP"
      cluster_geno_tidy <- calculate_DS(cluster_geno_tidy)
      cat("Found GP genotype format in cluster VCF. Using GP for correlation.")
    } else {
      stop("No valid genotype format (DS, GT, GP) found in cluster VCF.")
    }
  }
  
  cat("Processing reference VCF...\n")
  
  format_ref <- NA
  ref_geno_tidy <- as_tibble(extract.gt(element = "DS", ref_geno, IDtoRowNames = F))
  
  if (!all(colSums(is.na(ref_geno_tidy)) == nrow(ref_geno_tidy))) {
    cat("Found DS genotype format in reference VCF. Using DS.")
    format_ref <- "DS"
  }
  
  if (is.na(format_ref)) {
    ref_geno_tidy <- as_tibble(extract.gt(element = "GT", ref_geno, IDtoRowNames = F))
    if (!all(colSums(is.na(ref_geno_tidy)) == nrow(ref_geno_tidy))) {
      cat("Found GT genotype format in reference VCF. Using GT.")
      format_ref <- "GT"
      separator <- ifelse(any(grepl("\\|", ref_geno_tidy[1, ])), "|", "/")
      
      ref_geno_tidy <- as_tibble(lapply(ref_geno_tidy, function(x) {
        gsub(paste0("0", separator, "0"), 0, x)
      }) %>%
        lapply(., function(x) {
          gsub(paste0("0", separator, "1"), 1, x)
        }) %>%
        lapply(., function(x) {
          gsub(paste0("1", separator, "0"), 1, x)
        }) %>%
        lapply(., function(x) {
          gsub(paste0("1", separator, "1"), 2, x)
        }))
    }
  }
  
  cat("Matching SNPs between cluster and reference VCFs...\n")
  
  cluster_geno_tidy$ID <- paste0(cluster_geno@fix[, "CHROM"], ":", cluster_geno@fix[, "POS"])
  ref_geno_tidy$ID <- paste0(ref_geno@fix[, "CHROM"], ":", ref_geno@fix[, "POS"])
  
  locations <- inner_join(ref_geno_tidy[, "ID"], cluster_geno_tidy[, "ID"])
  ref_geno_tidy <- left_join(locations, ref_geno_tidy)
  cluster_geno_tidy <- left_join(locations, cluster_geno_tidy)
  
  cat("Computing Pearson correlation...\n")
  
  pearson_correlations <- matrix(nrow = ncol(cluster_geno_tidy) - 1, ncol = ncol(ref_geno_tidy) - 1)
  colnames(pearson_correlations) <- colnames(ref_geno_tidy)[2:ncol(ref_geno_tidy)]
  rownames(pearson_correlations) <- colnames(cluster_geno_tidy)[2:ncol(cluster_geno_tidy)]
  pearson_correlations <- pearson_correlation(as.data.frame(pearson_correlations), ref_geno_tidy, cluster_geno_tidy)
  
  cat("Ordering samples automatically...\n")
  
  # Extract numeric part if exists, otherwise alphabetical order
  extract_numeric <- function(x) {
    num <- suppressWarnings(as.numeric(gsub("[^0-9]", "", x)))
    ifelse(is.na(num), Inf, num)   # non-numeric names go to end
  }
  
  # Automatic ordering of reference samples
  ref_order <- order(extract_numeric(colnames(pearson_correlations)))
  cluster_order <- order(extract_numeric(rownames(pearson_correlations)))
  
  pearson_correlations <- pearson_correlations[cluster_order, ref_order]
  
  write_delim(as.data.frame(pearson_correlations), file = paste0(outdir, "/ref_clust_pearson_correlations.tsv"), delim = "\t")
  
  cat("Generating correlation heatmap...\n")
  
  #col_fun <- colorRampPalette(viridisLite::viridis(100))(100)
  
  ht <- Heatmap(
    as.matrix(pearson_correlations),
    name = 'Spearman\ncorrelation',
    #col = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdYlBu")))(100),
    col = viridis::viridis(100),
    border = "black",
    rect_gp = gpar(col = "black"),
    column_names_rot = column_names_rot,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    column_title_side = column_title_side,
    column_names_centered = TRUE,
    column_names_gp = gpar(fontsize = fontsize, hjust = 0.5),
    row_names_gp = gpar(fontsize = fontsize, hjust = 0.5),
    show_row_dend = FALSE,
    show_row_names = TRUE,
    show_column_names = TRUE,
    show_column_dend = FALSE,
    row_title = row_title,
    column_title = column_title,
    heatmap_legend_param = list(
      title = 'Spearman correlation',
      legend_height = unit(3.6, 'cm'),
      legend_width = unit(1, 'cm'),
      title_position = 'lefttop-rot',
      border = 'black'
    )
  )
  
  
  # Save the correlation figures 
  # png(filename = paste0(outdir, "/ref_clust_pearson_correlation.png"), width = 500)
  # print(ht)
  # dev.off()
  cat("Save correlation heatmap\n")
  
  pdf(file = paste0(outdir, "/ref_clust_pearson_correlation.pdf"), width = width, height = height)  # Save as PDF
  draw(ht)
  dev.off()
  
  print(ht)
  
  cat("Done! Correlation results saved in:\n ", outdir)
  
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
add_bulk_donor_mapping_to_seurat <- function(
    object,
    combined_tsv,
    donor_mapping_tsv = NULL,
    barcode_col = "Barcode"
) {
  # --- Load combined cell-level mapping ---
  if (is.character(combined_tsv)) {
    df <- read.table(combined_tsv, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
  } else if (is.data.frame(combined_tsv)) {
    df <- combined_tsv
  } else {
    stop("combined_tsv must be either a file path or a data.frame")
  }
  
  # --- Load donor-level mapping ---
  if (!is.null(donor_mapping_tsv)) {
    if (is.character(donor_mapping_tsv)) {
      map <- read.table(donor_mapping_tsv, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
    } else if (is.data.frame(donor_mapping_tsv)) {
      map <- donor_mapping_tsv
    } else {
      stop("donor_mapping_tsv must be a file path or a data.frame")
    }
  }
  
  # Normalize barcode
  if (!barcode_col %in% colnames(df)) {
    stop(paste("Barcode column", barcode_col, "not found in combined mapping dataframe"))
  }
  
  df$cell <- df[[barcode_col]]
  df$cell <- gsub("_1$", "", df$cell)
  rownames(df) <- df$cell
  
  # Only keep barcodes present in Seurat
  common <- intersect(colnames(object), rownames(df))
  if (length(common) == 0)
    stop("No overlapping cell barcodes between Seurat object and mapping file")
  
  df <- df[common, , drop = FALSE]
  
  # Add metadata
  object <- AddMetaData(object, metadata = df)
  
  # Add donor-level mapping if provided
  if (!is.null(donor_mapping_tsv)) {
    rownames(map) <- map$donor
    if ("Vireo_Individual_Assignment" %in% colnames(df)) {
      object$DonorBestBulk <- map[df$Vireo_Individual_Assignment, "best_bulk"]
      object$DonorMappingStatus <- map[df$Vireo_Individual_Assignment, "status"]
    }
  }
  
  object <- fix_seurat_matrix_names(object)
  
  return(object)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
run_slingshot_on_pca_plot_umap <- function(
    seurat_obj,
    cluster_col = "ann_level_2",
    pca_n = 50,
    start_clust = NULL,
    end_clusts = NULL,
    approx_points = 200,
    shrink = FALSE,
    verbose = TRUE
) {
  suppressPackageStartupMessages({
    library(slingshot)
    library(Seurat)
    library(dplyr)
    library(ggplot2)
  })
  
  if (verbose) cat("Extracting PCA embeddings and cluster labels...\n")
  
  clusters <- seurat_obj[[cluster_col, drop = TRUE]]
  clusters <- as.character(clusters)
  names(clusters) <- colnames(seurat_obj)
  
  pca_emb <- Embeddings(seurat_obj, "pca")[, seq_len(pca_n), drop = FALSE]
  pca_emb <- as.matrix(pca_emb)
  pca_emb <- pca_emb[match(colnames(seurat_obj), rownames(pca_emb)), , drop = FALSE]
  stopifnot(identical(rownames(pca_emb), names(clusters)))
  
  # Auto-detect root
  if (is.null(start_clust)) {
    if (verbose) cat("Auto-detecting root cluster (closest to PCA origin)...\n")
    d0 <- rowSums(pca_emb^2)
    df <- data.frame(cluster = clusters, d0 = d0)
    
    start_clust <- df %>% group_by(cluster) %>%
      summarise(m = median(d0)) %>%
      arrange(m) %>% pull(cluster) %>% .[1]
    
    if (verbose) cat(" â†’ Root:", start_clust, "\n")
  }
  
  # Auto-detect terminals
  if (is.null(end_clusts)) {
    if (verbose) cat("Auto-detecting terminal clusters (farthest from PCA origin)...\n")
    d0 <- rowSums(pca_emb^2)
    df <- data.frame(cluster = clusters, d0 = d0)
    
    end_clusts <- df %>% group_by(cluster) %>%
      summarise(m = median(d0)) %>%
      arrange(desc(m)) %>% head(3) %>% pull(cluster)
    
    if (verbose) cat(" â†’ Terminals:", paste(end_clusts, collapse = ", "), "\n")
  }
  
  # Slingshot in PCA space
  if (verbose) cat("Running Slingshot...\n")
  
  sds <- slingshot(
    data = pca_emb,
    clusterLabels = clusters,
    start.clus = start_clust,
    end.clus = end_clusts,
    shrink = shrink,
    approx_points = approx_points
  )
  
  # Pseudotime
  pt <- slingPseudotime(sds)
  colnames(pt) <- paste0("Lineage", seq_len(ncol(pt)))
  seurat_obj <- AddMetaData(seurat_obj, as.data.frame(pt))
  
  # Project Slingshot curves onto UMAP
  if (verbose) cat("Projecting trajectory curves to UMAP...\n")
  
  umap_coords <- as.data.frame(seurat_obj@reductions$umap@cell.embeddings)
  colnames(umap_coords) <- c("UMAP1", "UMAP2")
  
  # Only first 4 PCs used for LOESS (safe)
  pcs4 <- as.data.frame(seurat_obj@reductions$pca@cell.embeddings[, 1:4])
  colnames(pcs4) <- paste0("PC", 1:4)
  
  df_fit <- cbind(umap_coords, pcs4)
  
  pca_curves <- slingCurves(sds)
  
  curve_umap <- lapply(pca_curves, function(curve) {
    
    curve_pts <- as.data.frame(curve$s)[, 1:4]
    colnames(curve_pts) <- paste0("PC", 1:4)
    
    fit_x <- loess(UMAP1 ~ PC1 + PC2 + PC3 + PC4, data = df_fit)
    fit_y <- loess(UMAP2 ~ PC1 + PC2 + PC3 + PC4, data = df_fit)
    
    data.frame(
      UMAP1 = predict(fit_x, curve_pts),
      UMAP2 = predict(fit_y, curve_pts)
    )
  })
  
  # Report lineage stats
  if (verbose) {
    cat("\nLineages detected:", paste(colnames(pt), collapse = ", "), "\n")
    print(colSums(!is.na(pt)))
    
    cat("\nSlingshot lineage structure:\n")
    print(slingshot::SlingshotDataSet(sds))
    
    cat("\nCurve summaries:\n")
    for (i in seq_along(pca_curves)) {
      cat(paste0(
        "Curve ", i, ": Length = ", round(pca_curves[[i]]$dist[nrow(pca_curves[[i]]$dist)], 2),
        ", Points = ", nrow(pca_curves[[i]]$s), "\n"
      ))
    }
  }
  
  # Return object
  return(list(
    seurat = seurat_obj,
    sds = sds,
    pseudotime = pt,
    pca_curves = pca_curves,
    curve_umap = curve_umap,
    detected_root = start_clust,
    detected_terminals = end_clusts
  ))
}


library(Seurat)
library(slingshot)
library(RColorBrewer)
library(ggplot2)
library(dplyr)
library(mgcv)    # for GAM smoothing of curves (optional)
library(scales)

run_slingshot <- function(
    obj,
    cluster_col = "ann_level_2",
    reduction = "pca",
    n_pcs = NULL,
    start_clust = "OHBC",
    end_clusts = NULL,
    approx_points = 100,
    verbose = TRUE
) {
  
  suppressPackageStartupMessages({
    library(slingshot)
    library(Seurat)
    library(dplyr)
  })
  
  if (verbose) cat("Preparing clustering info...\n")
  Idents(obj) <- obj[[cluster_col, drop = TRUE]]
  clusters <- factor(as.character(Idents(obj)))
  
  if (verbose) cat(paste0("Using ", reduction, " reduction...\n"))
  emb <- Embeddings(obj, reduction)
  
  if (is.null(n_pcs)) {
    if (verbose) cat("Auto-detecting PCs (all available)...\n")
    pca_mat <- emb
  } else {
    pca_mat <- emb[, seq_len(n_pcs), drop = FALSE]
  }
  
  if (verbose) cat("Running Slingshot...\n")
  sds <- slingshot(
    pca_mat,
    clusterLabels = clusters,
    start.clus = start_clust,
    end.clus = end_clusts,
    approx_points = approx_points
  )
  
  if (verbose) cat("Extracting pseudotime...\n")
  pt <- slingPseudotime(sds)
  colnames(pt) <- paste0("Lineage", seq_len(ncol(pt)))
  
  # add pseudotime back into metadata
  pt_df <- as.data.frame(pt)
  obj <- AddMetaData(obj, metadata = pt_df)
  
  if (verbose) {
    cat("Done!\n")
    cat("Lineages detected: ", paste(colnames(pt), collapse = ", "),"\n")
    cat("Cells with pseudotime per lineage:\n")
    print(colSums(!is.na(pt)))
  }
  
  return(list(
    seurat = obj,
    sds = sds,
    pseudotime = pt
  ))
}


#' Compute cluster statistics from Seurat object (multiple group.by)
#'
#' @param object Seurat object
#' @param ident Metadata column for cluster identities (default: "seurat_clusters")
#' @param group.by One or more metadata columns to group by (default: "orig.ident")
#' @param rm.sum Logical; remove total row (default: FALSE)
#' @param rm.pct Logical; hide percentage columns (default: FALSE)
#' @return Data frame of cluster counts and percentages
#' @export
cluster_stats <- function(object, ident = "seurat_clusters", 
                          group.by = "orig.ident", rm.sum = FALSE, rm.pct = FALSE) {
  
  if (!inherits(object, "Seurat")) stop("`object` must be a Seurat object.")
  if (!missing(ident)) object <- SetIdent(object, value = ident)
  
  group.by <- as.character(group.by)
  missing.cols <- setdiff(group.by, colnames(object@meta.data))
  if(length(missing.cols)) stop(sprintf("'%s' not in meta.data.", paste(missing.cols, collapse = ", ")))
  
  # Base cluster totals
  tbl <- table(object@active.ident)
  stats <- data.frame(cluster = names(tbl), count = as.numeric(tbl), pct = as.numeric(prop.table(tbl)*100))
  
  # Function to compute counts and percent per group.by
  compute_group <- function(g) {
    tab <- table(object@active.ident, object@meta.data[[g]])
    df <- as.data.frame.matrix(tab) %>% tibble::rownames_to_column("cluster")
    pct <- prop.table(tab, margin = 2) * 100
    pct.df <- as.data.frame.matrix(pct) %>% tibble::rownames_to_column("cluster")
    colnames(pct.df)[-1] <- paste0(colnames(pct.df)[-1], ".", g, ".pct")
    cbind(df[,-1], pct.df[,-1])
  }
  
  if(length(group.by) > 0) {
    stats <- cbind(stats, purrr::map_dfc(group.by, compute_group))
  }
  
  stats <- janitor::adorn_totals(stats, "row")
  if(rm.sum) stats <- stats[1:(nrow(stats)-1), ]
  if(rm.pct) stats <- stats[, !grepl("\\.pct$", colnames(stats))]
  
  stats
}




#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Automatically Select the Optimal Number of PCs
#'
#' This function computes an optimal number of principal components (PCs)
#' to use for downstream analysis based on variance explained. It supports
#' any dimensional reduction stored in a Seurat object (e.g., PCA, Harmony).
#'
#' @param object A Seurat object.
#' @param reduction.name Name of the reduction slot to inspect
#'   (default: \code{"pca"}). Must exist in \code{object[[reduction.name]]}.
#'
#' @details
#' The selection heuristic uses two criteria:
#'
#' \itemize{
#'   \item \strong{co1}: First PC where cumulative variance exceeds 90\% AND
#'         the PC-specific variance drops below 5\%.
#'
#'   \item \strong{co2}: Last PC where the drop in variance from the previous PC
#'         is greater than 0.1\%.
#' }
#'
#' The function returns the larger of the two values, ensuring sufficient
#' dimensionality for clustering and UMAP.
#'
#' @return An integer giving the recommended number of dimensions.
#'
#' @examples
#' \dontrun{
#' pcs <- get_pcs(seurat_obj, reduction.name = "pca")
#' }
#'
#' @export
#' 
get_pcs <- function(object, reduction.name="pca") {
  # Check seurat object
  if(class(object) != "Seurat") {
    message("WARNING: this rds file does not contain a Seurat object! STOP RUNNING THIS SCRIPT")
    message("Check the data type by running:")
    message("class(obj)")
    stop()
  }
  # Determine percent of variation associated with each PC
  pct <- object[[reduction.name]]@stdev / sum(object[[reduction.name]]@stdev)*100
  # Calculate cumulative percents for each PC
  cumu <- cumsum(pct)
  # Determine which PC exhibits cumulative percent greater than 90% and % 
  # variation associated with the PC as less than 5
  co1 <- which(cumu > 90 & pct < 5)[1]
  co1
  # Determine the difference between variation of PC and subsequent PC and
  # selecting last point where change of % of variation is more than 0.1%.
  co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
  # Minimum of the two calculation
  #pcs <- min(co1, co2)
  c(co1, co2)
  pcs <- max(co1, co2)
  #pcs <- max(co1, co2)
  return(pcs)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Compute Unique Gene Expression Statistics
#'
#' This function evaluates a set of genes in a Seurat object and returns:
#' \enumerate{
#'   \item The number of selected genes expressed by each cell.
#'   \item The number of cells expressing each gene.
#' }
#'
#' @param object A Seurat object containing an RNA assay.
#' @param gene.list Character vector of gene names to evaluate.
#'
#' @return A list containing:
#' \describe{
#'   \item{\code{per.cell}}{A data frame with columns \code{Cell} and \code{Unique}.}
#'   \item{\code{per.gene}}{A data frame with columns \code{gene} and \code{cells.expressing}.}
#' }
#'
#' @export
get_unique_gene_table <- function(object, gene.list, assay = "RNA", layer = "counts") {
  if (!inherits(object, "Seurat"))
    stop("`object` must be a Seurat object.")
  
  if (!assay %in% names(object@assays))
    stop("Assay not found in object.")
  
  assay_obj <- object[[assay]]
  
  # Access the matrix via @layers (Seurat v5)
  if (!layer %in% names(assay_obj@layers))
    stop(paste0("Layer '", layer, "' not found in the assay."))
  
  mat <- assay_obj@layers[[layer]]
  
  # Ensure dimnames are set
  if (is.null(rownames(mat))) rownames(mat) <- rownames(assay_obj)
  if (is.null(colnames(mat))) colnames(mat) <- colnames(object)
  
  genes.present <- intersect(gene.list, rownames(mat))
  if (length(genes.present) == 0)
    stop("None of the provided genes exist in the object.")
  
  mat <- mat[genes.present, , drop = FALSE]
  mat <- mat[Matrix::rowSums(mat > 0) > 0, , drop = FALSE]
  
  per.cell <- data.frame(
    Cell = colnames(mat),
    Unique = Matrix::colSums(mat > 0)
  )
  
  per.gene <- data.frame(
    gene = rownames(mat),
    cells.expressing = Matrix::rowSums(mat > 0)
  )
  
  per.gene <- per.gene[order(per.gene$cells.expressing), ]
  
  list(per.cell = per.cell, per.gene = per.gene)
}


#' Compute gene-set dominance score per cell
#'
#' Computes a dominance score for a gene set in each cell based on the
#' relative expression of the top-expressed gene versus the second-highest
#' expressed gene. Optionally scales dominance by expression magnitude,
#' bins scores, assigns QC flags, and appends selected metadata for
#' downstream analysis.
#'
#' @param obj A \code{Seurat} object.
#' @param geneset Character vector of gene names defining the gene set.
#' @param assay Assay to use (default: \code{"RNA"}).
#' @param slot Expression slot to use (default: \code{"data"}).
#' @param epsilon Small constant to avoid division by zero.
#' @param scale.log Logical; whether to scale dominance by log-transformed
#'   top gene expression.
#' @param exponent Numeric exponent applied to log-scaled expression.
#' @param bins Numeric vector defining bins for adjusted dominance scores.
#' @param bin.labels Optional character labels for dominance bins.
#' @param strong.dom.thresh Threshold above which a cell is flagged as
#'   strongly dominant.
#' @param group.by Metadata column used for cell grouping
#'   (e.g. \code{"ann2"}).
#' @param idents Character vector of identity values to retain;
#'   all others are labeled \code{"Others"}.
#' @param add.meta Character vector of additional metadata columns
#'   (e.g. \code{c("sample","stage","sex")}) to append to output.
#' @param verbose Logical; whether to print informative messages.
#'
#' @details
#' For each cell, the dominance score is calculated as:
#'
#' \deqn{(Top1 - Top2) / (Top1 + Top2 + epsilon)}
#'
#' If \code{scale.log = TRUE}, the score is multiplied by
#' \code{log1p(Top1)^exponent}.
#'
#' Only the metadata columns specified in \code{group.by} and
#' \code{add.meta} are joined, ensuring minimal memory overhead.
#'
#' @return A list with:
#' \itemize{
#'   \item \code{df}: Data frame with per-cell dominance metrics,
#'         bin assignments, QC flags, grouping identity, and selected metadata.
#'   \item \code{genes_detected}: Character vector of detected genes from
#'         \code{geneset}.
#' }
#'
#' @seealso \code{\link[Seurat]{GetAssayData}}
#'
#' @examples
#' \dontrun{
#' res <- dominance_score(
#'   obj = seurat_obj,
#'   geneset = OR_genes,
#'   group.by = "ann2",
#'   idents = c("INP", "iOSN"),
#'   add.meta = c("sample", "stage", "sex"),
#'   bins = c(-Inf, 0.5, 1, 1.5, 2, Inf)
#' )
#'
#' head(res$df)
#' }
#'
#' @export
#' 
dominance_score <- function(
    obj,
    geneset = NULL,
    assay = "RNA",
    slot = "data",
    epsilon = 1e-9,
    scale.log = TRUE,
    exponent = 1,
    bins = c(-Inf, 0.1, 0.5, 1, 2, Inf),
    bin.labels = NULL,
    strong.dom.thresh = 1.5,
    group.by = NULL,        
    idents = NULL,      
    add.meta = NULL,    
    verbose = TRUE
) {
  
  require(Seurat)
  require(Matrix)
  require(dplyr)
  
  stopifnot(inherits(obj, "Seurat"))
  
  ## Gene detection
  all_genes <- rownames(obj[[assay]])
  detected_genes <- intersect(unique(geneset), all_genes)
  
  if (length(detected_genes) == 0)
    stop("No genes from geneset found in Seurat object.")
  
  expr_mat <- as.matrix(
    GetAssayData(obj, assay = assay, slot = slot)[
      detected_genes, , drop = FALSE
    ]
  )
  
  ## Top1 / Top2 per cell
  
  compute_top2_cell <- function(v) {
    nz <- which(v != 0)
    if (length(nz) == 0) return(c(top1 = 0, top2 = 0))
    if (length(nz) == 1) return(c(top1 = v[nz], top2 = 0))
    ord <- order(v, decreasing = TRUE)
    c(top1 = v[ord[1]], top2 = v[ord[2]])
  }
  
  top2_mat <- apply(expr_mat, 2, compute_top2_cell)
  if (is.null(dim(top2_mat)))
    top2_mat <- matrix(top2_mat, nrow = 2)
  
  top1_vec <- top2_mat[1, ]
  top2_vec <- top2_mat[2, ]
  
  dominance <- (top1_vec - top2_vec) /
    (top1_vec + top2_vec + epsilon)
  
  adjust_score <- if (scale.log) {
    dominance * (log1p(top1_vec) ^ exponent)
  } else {
    dominance
  }
  
  ## Top gene & counts
  get_top_gene <- function(v) {
    if (all(v == 0)) return(NA_character_)
    rownames(expr_mat)[which.max(v)]
  }
  
  top_gene_vec <- apply(expr_mat, 2, get_top_gene)
  n_genes_expr <- Matrix::colSums(expr_mat > 0)
  
  ## Base dataframe
  df <- data.frame(
    cell = colnames(expr_mat),
    top_gene = top_gene_vec,
    top_expr = as.numeric(top1_vec),
    second_expr = as.numeric(top2_vec),
    dominance = as.numeric(dominance),
    adjust_score = as.numeric(adjust_score),
    n_genes_expr = as.integer(n_genes_expr),
    stringsAsFactors = FALSE
  )
  
  ## Selective metadata join
  meta <- obj@meta.data
  meta$cell <- rownames(meta)
  
  cols_to_add <- unique(c(group.by, add.meta))
  cols_to_add <- intersect(cols_to_add, colnames(meta))
  
  if (length(cols_to_add) > 0) {
    df <- left_join(
      df,
      meta[, c("cell", cols_to_add), drop = FALSE],
      by = "cell"
    )
  } else if (verbose) {
    message("No metadata columns added.")
  }
  
  ## Cell grouping
  ## Cell grouping (SAFE)
  if (!is.null(group.by) && group.by %in% colnames(df)) {
    
    group_vals <- as.character(df[[group.by]])
    
    if (!is.null(idents)) {
      df$ident <- ifelse(
        group_vals %in% idents,
        group_vals,
        "Others"
      )
    } else {
      df$ident <- group_vals
    }
    
  } else {
    df$ident <- "Others"
    if (verbose)
      warning("group.by not found; all cells set to 'Others'.")
  }
  
  ## Binning
  if (is.null(bin.labels)) {
    bin.labels <- sapply(seq_len(length(bins) - 1), function(i) {
      lb <- bins[i]; ub <- bins[i + 1]
      if (is.finite(lb) && is.finite(ub)) paste0(lb, "-", ub)
      else if (!is.finite(lb)) paste0("<", ub)
      else paste0(">=", lb)
    })
  }
  
  df$adjusted_bin <- cut(
    df$adjust_score,
    breaks = bins,
    labels = bin.labels,
    include.lowest = TRUE,
    right = FALSE
  )
  
  ## QC flags
  df$qc_flag <- "ok"
  df$qc_flag[df$n_genes_expressed == 0] <- "no_gene"
  df$qc_flag[df$top_expr == 0] <- "no_top_expr"
  df$qc_flag[df$adjust_score >= strong.dom.thresh] <- "strong_dominant"
  
  ## Output
  list(df = df, genes_detected = detected_genes)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Summarize Seurat Object Metadata
#'
#' This function summarizes metadata from a Seurat object and generates a bar plot 
#' for visualization. It allows grouping and conditioning by metadata columns, 
#' supports color customization, and provides options for reordering bars.
#'
#' @param object A Seurat object containing single-cell RNA-seq data.
#' @param group.by A string specifying the metadata column to group by (default: "sample").
#' @param condition.by A string specifying a second metadata column for conditional grouping (default: NULL).
#' @param pal.setup A string specifying the color palette from RColorBrewer (default: "Set1").
#' @param custom.colors A vector of custom colors to use instead of the default palette (default: NULL).
#' @param use.discrete.colors Logical; if TRUE, uses discrete colors from Set1 (default: FALSE).
#' @param angle.x An integer specifying the angle of x-axis labels (default: 90).
#' @param vjust.x Vertical justification of x-axis labels (default: NULL).
#' @param hjust.x Horizontal justification of x-axis labels (default: NULL).
#' @param x.title A string for the x-axis title (default: same as `group.by`).
#' @param remove.axis.x.text Logical; if TRUE, removes x-axis text (default: FALSE).
#' @param reorder.bars Logical; if TRUE, reorders bars based on a specified column (default: FALSE).
#' @param reorder.column A string specifying the column to reorder bars by (default: NULL).
#' @param plot.variable A string specifying the metric to plot: "total_counts", "total_transcripts", 
#'  "mean_transcripts", "median_transcripts", or "proportion" (default: "total_counts").
#' @param title A string specifying the plot title (default: same as `plot.variable`).
#' @param legend Logical; if FALSE, removes the legend (default: TRUE).
#' @param text.size An integer specifying the text size in the plot (default: 10).
#'
#' @return A list containing:
#'   \item{summary_table}{A summary table with calculated statistics.}
#'   \item{plot}{A ggplot2 object representing the bar plot.}
#'
#' @import Seurat dplyr ggplot2 RColorBrewer
#' @export
#'
#' @examples
#' \dontrun{
#'   result <- summarize_seurat(object = seurat_obj, group.by = "cell_type", plot.variable = "total_counts")
#'   print(result$plot)
#' }
summarize_seurat <- function(object, 
                             group.by = "sample",
                             assay = "RNA",
                             slot = "counts",
                             condition.by = NULL,  
                             pal.setup = "Set1",
                             custom.colors = NULL,
                             use.discrete.colors = FALSE,
                             theme = "classic", 
                             x.angle = 45, 
                             x.title = group.by,
                             remove.axis.x.text = FALSE,
                             reorder.bars = FALSE,
                             reorder.column = NULL,
                             plot.variable = c("total_transcripts", "mean_transcripts", "median_transcripts", 
                                               "num_expressed_genes", "mean_genes_per_cell", "num_cells"),
                             plot.title = plot.variable,
                             legend = TRUE,
                             legend.title = NULL,
                             legend.key.size = 0.3,
                             legend.position = "right",
                             legend.ncol = 1,
                             legend.alpha = 1,
                             text.size = 10,
                             remove.x.labels = FALSE,
                             remove.x.title = FALSE,
                             remove.y.title = FALSE,
                             y.title = NULL) {
  
  # Load required libraries
  require(Seurat)
  require(dplyr)
  require(ggplot2)
  require(RColorBrewer)
  
  # Validate the plotting method choice
  plot.variable <- match.arg(plot.variable)
  
  # Extract metadata and gene expression matrix
  metadata <- object@meta.data
  gene_counts <- object[[assay]][slot]
  
  # Ensure group.by exists
  if (!group.by %in% colnames(metadata)) {
    stop(paste("The specified group.by column", group.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Ensure condition.by exists if provided
  if (!is.null(condition.by) && !condition.by %in% colnames(metadata)) {
    stop(paste("The specified condition.by column", condition.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Compute expressed genes per cell
  expressed_genes_per_cell <- Matrix::colSums(gene_counts > 0)  # Number of genes expressed per cell
  metadata$num_expressed_genes <- expressed_genes_per_cell
  
  # Group data
  if (!is.null(condition.by)) {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by), !!sym(condition.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      ) %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::mutate(proportion = total_counts / sum(total_counts)) %>%  
      dplyr::ungroup()
  } else {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      )
  }
  
  # Add the number of cells per group (corrected)
  num_cells_per_group <- metadata %>%
    dplyr::group_by(!!sym(group.by)) %>%
    dplyr::summarise(num_cells = n(), .groups = 'drop')
  summary_stats <- left_join(summary_stats, num_cells_per_group, by = group.by)
  
  # Ensure plot.variable exists
  if (!(plot.variable %in% colnames(summary_stats))) {
    stop(paste("The specified plot.variable", plot.variable, "does not exist in the summary statistics table."))
  }
  
  # Define colors
  unique_groups <- unique(summary_stats[[ifelse(is.null(condition.by), group.by, condition.by)]])
  num_groups <- length(unique_groups)
  
  if (!is.null(custom.colors)) {
    if (length(custom.colors) < num_groups) {
      stop(paste("Insufficient colors in custom.colors. Needed:", num_groups, "Provided:", length(custom.colors)))
    }
    colors_to_use <- custom.colors
  } else if (use.discrete.colors) {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set1"))(num_groups)
  } else {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_groups), pal.setup))(num_groups)
  }
  
  # Reorder bars globally if required
  if (reorder.bars) {
    if (is.null(reorder.column)) {
      reorder.column <- plot.variable  # Default to reordering by the plot variable
    }
    if (!reorder.column %in% colnames(summary_stats)) {
      stop(paste("The specified reorder.column", reorder.column, "does not exist in the summary statistics table."))
    }
    
    # Ensure reorder.column is evaluated correctly
    summary_stats <- summary_stats %>%
      dplyr::mutate(!!reorder.column := as.numeric(summary_stats[[reorder.column]])) %>%
      dplyr::arrange(dplyr::desc(!!sym(reorder.column))) %>%
      dplyr::mutate(!!sym(group.by) := factor(!!sym(group.by), levels = unique(!!sym(group.by))))
  }
  
  # Create base bar plot
  p <- ggplot(summary_stats, aes(x = !!sym(group.by), y = !!sym(plot.variable))) +
    geom_bar(stat = "identity", position = "stack", color = "black", linewidth = 0.2) +  
    plot_theme(theme = theme, x.angle = x.angle, font.size = text.size) +
    theme(legend.position = legend.position,
          legend.key.size = unit(legend.key.size, "cm")) +
    guides(color = guide_legend(ncol = legend.ncol, alpha = legend.alpha, title = legend.title)) +
    labs(title = plot.title, y = plot.variable, x = x.title, colour = paste(legend.title)) 
  
  # Add fill aesthetic
  if (!is.null(condition.by)) {
    p <- p + aes(fill = !!sym(condition.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  } else {
    p <- p + aes(fill = !!sym(group.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  }
  
  if (remove.x.title) {
    p <- p + theme(axis.title.x = element_blank())
  }
  
  if (remove.y.title) {
    p <- p + theme(axis.title.y = element_blank())
  }
  
  if (remove.x.labels) {
    p <- p + theme(axis.text.x = element_blank(),
                   axis.ticks.x = element_blank())
  }
  
  if (!is.null(y.title)) {
    p <- p + ylab(y.title)
  }
  
  # Hide legend if specified
  if (!legend) {
    p <- p & NoLegend()
  }
  
  # Return results
  return(list(summary_table = summary_stats, plot = p))
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Custom ggplot Theme for Consistent Scientific Figures
#'
#' @description
#' `plot_theme()` applies a standardized and highly configurable visual style
#' to ggplot figures, optimized for scientific publishing (Nature, Cell,
#' Science, etc.).  
#'  
#' It wraps around base ggplot themes (`theme_minimal()`, `theme_classic()`,
#' `theme_bw()`, etc.) and exposes fine-grained control over axis visibility,
#' tick marks, borders, legend formatting, panel background, and dark/light mode.
#'
#' @param theme Character string specifying the base theme.
#'   One of: `"minimal"`, `"classic"`, `"bw"`, `"test"`, `"void"`.
#'
#' @param font.size Base font size for all text elements.
#'
#' @param xy.val Logical. Show axis tick labels?  
#' @param x.angle Angle of x-axis text.  
#' @param hjust Horizontal justification of x-axis labels (if not `NULL`).  
#' @param vjust Vertical justification of x-axis labels (if not `NULL`).  
#'
#' @param xlab,ylab Logical. Show x or y axis label?  
#' @param xy.lab Logical. Master switch for showing both axis labels.
#'
#' @param facet.face Fontface used for facet strip text.  
#' @param ttl.face Fontface used for plot title.  
#' @param txt.face Fontface for general text (`"plain"`, `"italic"`, `"bold"`).
#'
#' @param leg.pos Legend position (e.g., `"right"`, `"bottom"`, `"none"`).  
#' @param leg.dir Legend direction (`"vertical"` or `"horizontal"`).  
#' @param leg.size Legend text size.  
#' @param leg.ttl Legend title size.  
#' @param leg.just Legend justification.
#'
#' @param ttl.pos Title alignment: `"center"`, `"left"`, or `"right"`.  
#' @param x.ttl,y.ttl Logical. Show x- or y-axis title?
#'
#' @param ticks Logical or `NULL`. If `TRUE` show axis ticks, if `FALSE` hide,
#'   if `NULL`, keep base theme's default.
#'
#' @param line Logical or `NULL`. Controls axis lines.  
#' @param border Logical or `NULL`. Show panel border?  
#' @param grid.major Logical or `NULL`. Control major gridlines.  
#' @param grid.minor Logical or `NULL`. Control minor gridlines.
#'
#' @param panel.fill Panel background color.  
#' @param facet.bg Logical. Use a background for facet strips?
#'
#' @param mode `"light"` or `"dark"` appearance mode. Adjusts text and panel
#'   colors accordingly.
#'
#' @param ... Additional arguments passed to theme elements.
#'
#' @return
#' A ggplot2 theme object that can be added to a ggplot via `+`.
#'
#' @examples
#' \dontrun{
#' library(ggplot2)
#' df <- data.frame(x = 1:10, y = rnorm(10))
#'
#' ggplot(df, aes(x, y)) +
#'   geom_line() +
#'   plot_theme(theme = "classic", font.size = 9)
#' }
#'
#' @export
#' 
plot_theme <- function(
    theme = c("minimal","classic","bw","test","void"),
    font.size = 8,
    xy.val = TRUE, x.angle = 0, hjust = NULL, vjust = NULL,
    xlab = TRUE, ylab = TRUE, xy.lab = TRUE,
    facet.face = "bold", ttl.face = "bold",
    txt.face = c("plain","italic","bold"),
    leg.pos = "right", leg.dir = "vertical",
    leg.size = 8, leg.ttl = 8, leg.just = "center",
    ttl.pos = c("center","left","right"),
    x.ttl = TRUE, y.ttl = TRUE,
    ticks = NULL,       # NULL = keep theme default
    line = NULL,        # NULL = keep theme default (fix)
    border = NULL,      # NULL = keep theme default
    grid.major = NULL,  # NULL = keep theme default
    grid.minor = NULL,  # NULL = keep theme default
    panel.fill = "white", facet.bg = TRUE,
    mode = c("light","dark"),
    ...
) {
  require(ggplot2)
  
  theme <- match.arg(theme)
  ttl.pos <- match.arg(ttl.pos)
  txt.face <- match.arg(txt.face)
  mode <- match.arg(mode)
  
  # COLORS (NC style) 
  if (mode == "light") {
    col.txt   <- "#1A1A1A"
    col.grid  <- "#D9D9D9"
    col.panel <- panel.fill
    col.strip <- "#EFEFEF"
  } else {
    col.txt   <- "#444444" #"#DDDDDD"
    col.grid  <- "#444444"
    col.panel <- "#1E1E1E"
    col.strip <- "#383838"
  }
  
  # Automatic x-label alignment 
  if (is.null(hjust) || is.null(vjust)) {
    a <- x.angle
    if (a == 0)   { hjust <- .5; vjust <- 1   }
    else if (a == 45)  { hjust <- 1; vjust <- 1 }
    else if (a == 90)  { hjust <- 1; vjust <- .5 }
    else if (a == 270) { hjust <- 0; vjust <- .5 }
    else               { hjust <- 1; vjust <- 1 }
  }
  
  ttl.pos <- switch(ttl.pos, left = 0, center = .5, right = 1)
  
  # Base theme
  base <- theme(
    text = element_text(color = col.txt, size = font.size, family = "Helvetica"),
    
    axis.text.x = element_text(color = col.txt, size = font.size),
    axis.text.y = element_text(color = col.txt, size = font.size),
    
    plot.title = element_text(
      hjust = ttl.pos, face = ttl.face,
      size = font.size + 1, color = col.txt
    ),
    
    strip.text = element_text(face = facet.face, color = col.txt),
    strip.background = if (facet.bg)
      element_rect(fill = col.strip, color = NA)
    else element_blank(),
    
    legend.key.height = unit(.3, "cm"),
    legend.key.width  = unit(.3, "cm"),
    legend.text  = element_text(size = leg.size, color = col.txt),
    legend.title = element_text(size = leg.size, face = "bold", color = col.txt),
    legend.position = leg.pos,
    legend.direction = leg.dir,
    legend.justification = leg.just,
    #legend.background = element_blank(),
    legend.background = element_rect(fill = "transparent", color = NA),
    legend.box.background = element_rect(fill = "transparent", color = NA),
    panel.background = element_rect(fill = col.panel, color = NA),
    
    ...
  )
  
  # Native theme defaults preserved
  preset <- switch(theme,
                   minimal = theme_minimal(base_size = font.size),
                   classic = theme_classic(base_size = font.size),
                   bw      = theme_bw(base_size = font.size),
                   test    = theme_test(base_size = font.size),
                   void    = theme_void(base_size = font.size)
  )
  
  # Void cleanup 
  if (theme == "void") {
    preset <- preset + theme(
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      axis.line = element_blank(),
      panel.grid = element_blank(),
      panel.background = element_blank(),
      panel.border = element_blank(),
      strip.text = element_blank(),
      strip.background = element_blank()
    )
  }
  
  th <- preset + base
  
  #  Label/tick/title overrides 
  if (!xy.lab) th <- th + theme(axis.text = element_blank(), axis.ticks = element_blank())
  if (!xlab) th <- th + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  if (!ylab) th <- th + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
  if (!x.ttl) th <- th + theme(axis.title.x = element_blank())
  if (!y.ttl) th <- th + theme(axis.title.y = element_blank())
  
  # Axis TICKS override 
  if (!is.null(ticks)) {
    th <- th + if (ticks)
      theme(axis.ticks = element_line(color = col.txt))
    else
      theme(axis.ticks = element_blank())
  }
  
  # Axis LINES override (FIXED) 
  if (!is.null(line)) {
    th <- th + if (line)
      theme(axis.line = element_line(color = col.txt, linewidth = 0.4))
    else
      theme(axis.line = element_blank())
  }
  
  # Grid overrides
  if (!is.null(grid.major)) {
    th <- th + if (grid.major)
      theme(panel.grid.major = element_line(color = col.grid, linewidth = .3))
    else
      theme(panel.grid.major = element_blank())
  }
  
  if (!is.null(grid.minor)) {
    th <- th + if (grid.minor)
      theme(panel.grid.minor = element_line(color = col.grid, linewidth = .15))
    else
      theme(panel.grid.minor = element_blank())
  }
  
  #  Border override
  if (!is.null(border)) {
    th <- th + if (border)
      theme(panel.border = element_rect(color = col.grid, fill = NA))
    else
      theme(panel.border = element_blank())
  }
  
  # X-axis angle
  if (xy.val && xlab) {
    th <- th + theme(
      axis.text.x = element_text(angle = x.angle, hjust = hjust, vjust = vjust)
    )
  }
  
  return(th)
}


# Utility: %||%
`%||%` <- function(a, b) if(!is.null(a)) a else b

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Generate a Color Palette with Presets and Interpolation
#'
#' This function generates a vector of colors based on predefined palette presets
#' or a user-supplied set of base colors. Colors can be interpolated in multiple
#' color spaces and adjusted for saturation, lightness, and vividness.
#'
#' @param n Integer. Number of colors to generate.
#' @param preset Character. One of \code{"bright"}, \code{"pastel"}, \code{"warm"},
#'   \code{"cool"}, \code{"contrast"}, \code{"earth"}, \code{"base"}, or \code{"custom"}.
#'   If \code{"custom"} is chosen, \code{base_colors} must be supplied.
#' @param base_colors Character vector of HEX color codes. Required if
#'   \code{preset = "custom"}.
#' @param space Character. Color interpolation space. One of \code{"Lab"},
#'   \code{"rgb"}, or \code{"HCL"}.
#' @param oversample_factor Numeric. Factor by which to oversample colors before filtering.
#'   Larger values create smoother gradients. Default is \code{1.3}.
#' @param remove_gray Logical. If \code{TRUE} (default), removes grayish colors
#'   (low saturation).
#' @param reverse Logical. If \code{TRUE}, reverses the order of colors.
#' @param adjust_saturation Numeric multiplier for color saturation (chroma) in HCL space.
#'   Default is \code{1} (no change).
#' @param adjust_lightness Numeric multiplier for lightness in HCL space.
#'   Default is \code{1} (no change).
#'
#' @details
#' This function provides flexibility for both discrete and continuous color needs.
#' If the number of requested colors (\code{n}) is greater than the number of colors
#' in the base palette, the palette is interpolated in the chosen color space.
#'
#' The \code{remove_gray} option filters out low-chroma colors that appear grayish.
#'
#' @return A character vector of HEX color codes.
#'
#' @examples
#' # Get 5 bright colors
#' custom_palette(5, preset = "bright", space = "Lab")
#'
#' # Get 15 colors from the custom "base" preset
#' custom_palette(15, preset = "base", space = "HCL")
#'
#' # Use a fully custom palette
#' my_cols <- c("#123456", "#abcdef", "#ff0000")
#' custom_palette(10, preset = "custom", base_colors = my_cols)
#'
#' @import colorspace
#' @export
custom_palette <- function(n,
                      preset = c("base","bright", "pastel", "warm", "cool", "contrast", "earth", "custom"),
                      base_colors = NULL,
                      space = c("Lab", "rgb", "HCL"),
                      oversample_factor = 1.3,
                      remove_gray = TRUE,
                      reverse = FALSE,
                      adjust_saturation = 1,
                      adjust_lightness = 1) {
  
  library(colorspace)
  
  # Presets
  presets <- list(
    bright = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00",
               "#FFFF33", "#A65628", "#F781BF", "#999999"),
    pastel = c("#FDB462", "#B3DE69", "#BC80BD", "#CCEBC5", "#FFED6F",
               "#FB9A99", "#B2DF8A", "#CAB2D6", "#FFFFB3"),
    warm = c("#8C510A", "#BF812D", "#DFC27D", "#F6E8C3", "#FDD49E",
             "#F4A582", "#D6604D", "#B2182B"),
    cool = c("#2166AC", "#4393C3", "#92C5DE", "#D1E5F0",
             "#0571B0", "#74ADD1", "#ABD9E9", "#E0F3F8"),
    contrast = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A",
                 "#66A61E", "#E6AB02", "#A6761D"),
    earth = c("#A6611A", "#DFC27D", "#80CDC1", "#018571",
              "#E5E5E5", "#F5F5F5", "#B2182B", "#D6604D"),
    # base = c(
    #   "#E41A1C", "#57A156", "#06A5FF", "#7289da", "#8D5B96", "#CB7647", "#F38E38",
    #   "#F781BE", "#CC95C8", "#B27E85", "#9A6242", "#5FA3C9", "#3766A4", "#204E75",
    #   "#1B9D77", "#86CC84", "#D3EC90", "#FBF583", "#E7C715", "#F0A957", "#F57994",
    #   "#E7298A", "#A90D55", "#52587E", "#17CDD3", "#8ECDE0", "#BC6298", "#AE2373",
    #   "#5E4EA1", "#7E8D86", "#507C51", "#1F5917", "#BEC603", "#C5DD3B", "#A8DA83",
    #   "#8DD3C7"
    # ),
    base = c(
      "#E41A1C", "#68618B", "#409388", "#57A156", "#8D5B96", "#CB7647", "#F38E38",
      "#F781BE", "#CC95C8", "#B27E85", "#9A6242", "#5FA3C9", "#3766A4", "#204E75",
      "#1B9D77", "#86CC84", "#D3EC90", "#FBF583", "#E7C715", "#F0A957", "#F57994",
      "#E7298A", "#A90D55", "#52587E", "#17CDD3", "#8ECDE0", "#BC6298", "#AE2373",
      "#5E4EA1", "#7E8D86", "#507C51", "#1F5917", "#BEC603", "#C5DD3B", "#A8DA83",
      "#8DD3C7"
    ),
    custom = NULL
  )
  
  # Pick preset
  preset <- match.arg(preset)
  if (preset != "custom") {
    base_colors <- presets[[preset]]
  } else if (is.null(base_colors)) {
    stop("For preset = 'custom', you must provide base_colors.")
  }
  
  # Match space argument
  space <- match.arg(space)
  
  # Short-circuit if enough colors
  if (n <= length(base_colors)) {
    cols <- base_colors[1:n]
    if (reverse) cols <- rev(cols)
    return(cols)
  }
  
  # Oversample
  extra_colors <- ceiling(n * oversample_factor)
  
  # Interpolation
  if (space %in% c("rgb", "Lab")) {
    extended_colors <- grDevices::colorRampPalette(base_colors, space = space)(extra_colors)
  } else if (space == "HCL") {
    extended_colors <- grDevices::colorRampPalette(base_colors, space = "hcl")(extra_colors)
  }
  
  # Remove grayish
  if (remove_gray) {
    is_grayish <- function(col) {
      rgb <- grDevices::col2rgb(col)
      sd(rgb) < 15
    }
    extended_colors <- Filter(function(c) !is_grayish(c), extended_colors)
  }
  
  # Adjust saturation / lightness
  if (adjust_saturation != 1 || adjust_lightness != 1) {
    hcl_vals <- colorspace::coords(
      methods::as(colorspace::hex2RGB(extended_colors), "polarLUV")
    )
    hcl_vals[, "C"] <- pmax(0, hcl_vals[, "C"] * adjust_saturation)
    hcl_vals[, "L"] <- pmax(0, pmin(100, hcl_vals[, "L"] * adjust_lightness))
    extended_colors <- colorspace::hex(colorspace::polarLUV(hcl_vals))
  }
  
  # Take first n
  final_colors <- extended_colors[1:n]
  if (reverse) final_colors <- rev(final_colors)
  
  return(final_colors)
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Cell map visualization for Seurat objects
#'
#' @param object Seurat object
#' @param group.by Column(s) in metadata to group cells
#' @param reduction Dimensionality reduction to use (default "umap")
#' @param dims Dimensions to plot (1,2) or 3 for 3D
#' @param shuffle Logical, shuffle cells
#' @param raster Logical, rasterize plot
#' @param alpha Point transparency
#' @param repel Logical, repel labels
#' @param n.cells Logical, show number of cells in labels
#' @param label Logical, show cluster labels
#' @param label.size Cluster label size
#' @param label.face Cluster label font face
#' @param colors Named vector of colors
#' @param figplot Logical, minimal figure plot for figure panels
#' @param no.axes Logical, hide axes
#' @param plot.ttl Plot title
#' @param legend Logical, show legend
#' @param leg.ttl Legend title
#' @param item.size Legend item size
#' @param leg.pos Legend position
#' @param leg.just Legend justification
#' @param leg.dir Legend direction
#' @param leg.size Legend font size
#' @param leg.ncol Legend number of columns
#' @param item.border Logical, border around legend items
#' @param font.size Base font size
#' @param pt.size Point size
#' @param dark Logical, dark theme
#' @param total.cells Logical, include total cells in title
#' @param threeD Logical, 3D plot
#' @param theme Theme name
#' @param facet.bg Logical, add facet background
#' @param ... Additional arguments passed to DimPlot
#' @return ggplot or plotly object
#' @export
cellmap <- function(object, group.by=NULL, reduction="umap", dims=c(1,2), 
                    shuffle=FALSE, raster=NULL,raster.dpi = c(512, 512), alpha=1, repel=FALSE, n.cells=TRUE,
                    label=FALSE, label.size=3.5, label.face="plain", cols=NULL, 
                    figplot=FALSE, no.axes=FALSE, plot.ttl=NULL, legend=TRUE,
                    leg.ttl=NULL, item.size=3, leg.pos="right", leg.just="center",
                    leg.dir="vertical", leg.size=10, leg.ncol=NULL, item.border=TRUE,
                    font.size=10, pt.size=0.1, dark=FALSE, total.cells=FALSE,
                    threeD=FALSE, theme="classic", facet.bg=FALSE, ...) {
  
  # Helper: prepare object and colors
  .prepare_object <- function(obj, group, cols=NULL){
    stopifnot(inherits(obj,"Seurat"))
    if(is.null(group)) group <- "ident"
    if(group=="ident") obj@meta.data$ident <- Idents(obj)
    else if(!group %in% colnames(obj@meta.data)) stop(paste("Grouping column", group, "not found."))
    
    values <- as.character(obj@meta.data[[group]])
    values[is.na(values)] <- "Unknown"
    levels_group <- if(is.factor(obj@meta.data[[group]])) levels(obj@meta.data[[group]]) else unique(values)
    if("Unknown" %in% values & !("Unknown" %in% levels_group)) levels_group <- c(levels_group, "Unknown")
    obj@meta.data[[group]] <- factor(values, levels=levels_group)
    Idents(obj) <- obj@meta.data[[group]]
    
    if(is.null(cols)){
      cols <- custom_palette(length(levels_group))
      names(cols) <- levels_group
      if("Unknown" %in% levels_group) cols["Unknown"] <- "gray70"
    } else {
      if(is.null(names(cols))) cols <- setNames(cols[seq_along(levels_group)], levels_group)
      missing <- setdiff(levels_group, names(cols))
      if(length(missing)) cols[missing] <- "gray70"
      cols <- cols[levels_group]
    }
    
    list(obj=obj, cols=cols, levels_group=levels_group)
  }
  
  # warning for figplot + non-classic theme 
  if (figplot && theme != "classic") {
    warning(
      "`figplot = TRUE` ignores theme settings; set `figplot = FALSE` to apply theme = '", theme, "'."
    )
  }
  
  # Helper: 3D plot
  .plot_3D <- function(obj, dims, cols, alpha, pt.size, label, label.size, label.face, n.cells){
    emb <- obj@reductions[[reduction]]@cell.embeddings
    df <- data.frame(x=emb[, dims[1]], y=emb[, dims[2]], z=emb[, dims[3]], cluster=Idents(obj))
    hover_labels <- if(n.cells){
      tbl <- table(df$cluster)
      paste0(df$cluster, " (", tbl[as.character(df$cluster)], ")")
    } else as.character(df$cluster)
    
    p3d <- plotly::plot_ly(df, x=~x, y=~y, z=~z, color=~cluster, colors=cols,
                           type="scatter3d", mode="markers",
                           marker=list(size=pt.size, opacity=alpha, line=list(width=0)),
                           text=hover_labels, hoverinfo="text")
    if(label){
      centers <- df %>% dplyr::group_by(cluster) %>% dplyr::summarise(x=median(x), y=median(y), z=median(z))
      p3d <- p3d %>% plotly::add_text(data=centers, x=~x, y=~y, z=~z, text=~cluster, textposition="top center")
    }
    p3d
  }
  
  # Handle multiple group.by
  if(length(group.by)>1){
    plots <- lapply(group.by, function(g){
      cellmap(object=object, group.by=g, shuffle=shuffle, raster=raster, alpha=alpha,
              repel=repel, reduction=reduction, dims=dims, n.cells=n.cells,
              label=label, label.size=label.size, label.face=label.face, colors=cols,
              figplot=figplot, plot.ttl=g, legend=legend, leg.ttl=g, item.size=item.size,
              leg.pos=leg.pos, leg.just=leg.just, leg.dir=leg.dir, leg.ncol=leg.ncol,
              font.size=font.size, item.border=item.border, pt.size=pt.size,
              dark=dark, total.cells=total.cells, threeD=threeD, theme=theme,
              facet.bg=facet.bg, raster.dpi=raster.dpi,...)
    })
    return(patchwork::wrap_plots(plots))
  }
  
  # Prepare object and colors
  prep <- .prepare_object(object, group.by, cols)
  object <- prep$obj
  cols <- prep$cols
  levels_group <- prep$levels_group
  
  # Handle legend columns
  if(is.null(leg.ncol)) leg.ncol <- if(length(levels_group)>18) 2 else 1
  
  # Validate reduction
  if(!(reduction %in% names(object@reductions))){
    stop(paste0("Reduction '", reduction, "' not found. Available: ", paste(names(object@reductions), collapse=", ")))
  }
  emb <- object@reductions[[reduction]]@cell.embeddings
  if(max(dims) > ncol(emb)) stop("Selected dims exceed available dimensions in reduction.")
  
  # 3D plotting
  if(threeD || length(dims)==3) return(.plot_3D(object, dims, cols, alpha, pt.size, label, label.size, label.face, n.cells))
  
  # 2D plot
  plt <- Seurat::DimPlot(object, group.by=group.by, shuffle=shuffle, raster=raster, pt.size=pt.size,
                         repel=repel, alpha=alpha, reduction=reduction, dims=dims, raster.dpi=raster.dpi,...)
  
  if(!is.null(alpha) && alpha<1) plt <- plt + ggplot2::scale_alpha_manual(values=rep(alpha, length(levels_group)), guide="none")
  if(is.null(leg.ttl)) leg.ttl <- group.by
  
  # Cluster labels
  cell.nb <- if(n.cells) table(object@active.ident) else NULL
  clust.lab <- if(n.cells) paste0(names(cell.nb), " (",cell.nb,")") else levels_group
  plt <- plt + ggplot2::scale_color_manual(labels=clust.lab, values=cols, breaks=levels_group)
  
  # Legend
  plt <- plt & ggplot2::guides(color=ggplot2::guide_legend(
    override.aes = if(item.border) list(size=item.size, shape=21, color="black",
                                        stroke=0.2, fill=unname(cols)) else list(size=item.size),
    ncol=leg.ncol, title=leg.ttl, keyheight=grid::unit(0.25,"cm"), keywidth=grid::unit(0.25,"cm")
  ))
  
  # Plot title
  if(total.cells){
    plot.ttl <- paste0(plot.ttl, " (n=", format(ncol(object), big.mark=","), ")")
  }
  
  text_col <- if(dark) "white" else "black"
  
  # Theme
  if(figplot){
    warning("figplot=TRUE ignores custom themes. Use figplot=FALSE for full theming.")
    plt <- plt + labs(title=plot.ttl) +
      plot_theme(font.size=font.size, leg.size=leg.size, x.ttl=FALSE, ticks=FALSE, line=FALSE,
                 border=FALSE, grid.major=FALSE, grid.minor=FALSE, panel.fill="white", ...)
    text_col <- "black"
  } else {
    plt <- plt + labs(title=plot.ttl) +
      plot_theme(theme=theme, font.size=font.size, leg.just=leg.just, leg.dir=leg.dir,
                 leg.size=leg.size, leg.pos=leg.pos, leg.ttl=leg.ttl, facet.bg=facet.bg,
                 mode=if(dark) "dark" else "light", ...)
  }
  
  # Labels
  if(label){
    umap_data <- dplyr::tibble(x=emb[, dims[1]], y=emb[, dims[2]], cluster=as.character(object@active.ident)) %>%
      dplyr::group_by(cluster) %>% dplyr::summarise(x=median(x), y=median(y), .groups="drop")
    plt <- plt + ggrepel::geom_text_repel(
      data=umap_data, aes(x, y, label=cluster),
      color=text_col, fontface=label.face,
      bg.color = if(figplot) "#F0F0F0" else if(dark) "#3A3A3A" else "grey95",
      bg.r = 0.1, size=label.size, seed=42
    )
  }
  
  if(!legend) plt <- plt & Seurat::NoLegend()
  if(no.axes) plt <- plt & Seurat::NoAxes()
  
  # figplot arrow axes (minimal figure)
  if(figplot){
    x.lab.reduc <- plt$labels$x %||% paste0(toupper(reduction), dims[1])
    y.lab.reduc <- plt$labels$y %||% paste0(toupper(reduction), dims[2])
    plt <- plt & Seurat::NoAxes()
    L <- 0.12
    axis.df <- data.frame(x0=c(0,0), y0=c(0,0), x1=c(L,0), y1=c(0,L))
    axis.plot <- ggplot2::ggplot(axis.df) +
      ggplot2::geom_segment(ggplot2::aes(x=x0, y=y0, xend=x1, yend=y1), linewidth=0.4, lineend="round") +
      ggplot2::xlab(x.lab.reduc) + ggplot2::ylab(y.lab.reduc) +
      ggplot2::coord_fixed() + ggplot2::theme_classic(base_size=font.size) +
      ggplot2::theme(plot.background=ggplot2::element_rect(fill="transparent", colour=NA),
                     panel.background=ggplot2::element_rect(fill="transparent", colour=NA),
                     axis.text=ggplot2::element_blank(),
                     axis.ticks=ggplot2::element_blank(),
                     axis.line=ggplot2::element_blank(),
                     panel.border=ggplot2::element_blank(),
                     axis.title=ggplot2::element_text(size=font.size, face="plain"),
                     plot.margin=ggplot2::margin(0,0,0,0))
    figure.layout <- c(patchwork::area(t=1,l=1,b=11,r=11), patchwork::area(t=10,l=1,b=11,r=2))
    return(plt + axis.plot + patchwork::plot_layout(design=figure.layout))
  }
  
  plt
}


#' #' Flexible Dimensionality Reduction Plot for Seurat Objects
#' #'
#' #' @description
#' #' `cellmap()` is an enhanced, customizable wrapper around Seurat's `DimPlot`
#' #' that supports:
#' #' - 2D or 3D embeddings  
#' #' - Alphabetical or user-defined legend ordering  
#' #' - Dark/light themes  
#' #' - Cluster labels with cell counts  
#' #' - Legend customization (dot borders, ncol, icon size, justification, etc.)  
#' #' - Optional axis removal or figure-style layout  
#' #' - Multiple `group.by` inputs (returns patchwork grid)  
#' #'
#' #' The function supports **full control** over colors, transparency, label placement,
#' #' legend formatting, background colors, axis visibility, and more.
#' #'
#' #' @param object Seurat object.
#' #' @param group.by Metadata column(s) used for grouping. Can be one or multiple.
#' #' @param shuffle Logical; whether to randomly shuffle points.
#' #' @param raster Logical; rasterize points to speed plotting.
#' #' @param alpha Transparency value for points (0â€“1).
#' #' @param repel Logical; whether to repel cluster labels.
#' #' @param reduction Dimensionality reduction to use ("umap", "tsne", "pca", etc.).
#' #' @param dims Numeric vector; which dimensions to plot (2D or 3D).
#' #' @param cell.number Logical; append cell numbers to legend labels.
#' #' @param label Logical; add cluster labels on plot.
#' #' @param label.size Numeric; text size for labels.
#' #' @param label.fontface Font face for labels ("plain", "bold", "italic", etc.).
#' #' @param colors Optional named vector of colors. Names define legend order.
#' #' @param expand.colors Logical; unused in main plotting (kept for compatibility).
#' #' @param figure.plot Logical; draw plot in figure mode (axis arrows).
#' #' @param no.axes Logical; remove both axes.
#' #' @param plot.title Optional custom plot title.
#' #' @param legend Logical; display legend.
#' #' @param legend.title Legend title (defaults to grouping variable).
#' #' @param item.size Numeric; size of legend icons.
#' #' @param legend.position Character ("right", "left", "bottom", "top").
#' #' @param legend.justification Character ("center", "left", "right", etc.).
#' #' @param legend.ncol Number of columns in legend.
#' #' @param legend.dot.border Logical; draw border around legend dot.
#' #' @param cell.countours Logical; add thin outline around each point.
#' #' @param font.size Base font size.
#' #' @param pt.size Point size for cells.
#' #' @param dark.theme Logical; enable dark mode.
#' #' @param show.total.cells Logical; append total cell count to title.
#' #' @param threeD Logical; produce Plotly 3D embedding.
#' #' @param ... Additional arguments passed to `DimPlot()`.
#' #'
#' #' @details
#' #' ### Legend Ordering
#' #' - If user supplies a **named** color vector:  
#' #'   â†’ the legend follows that exact order.  
#' #'
#' #' - If colors are not named:  
#' #'   â†’ levels are ordered **alphabetically**.  
#' #'
#' #' - If Seurat object has factor levels, they are preserved unless colors override them.
#' #'
#' #' ### Dark Theme
#' #' Dark mode correctly switches:
#' #' - panel background  
#' #' - plot background  
#' #' - all axis text  
#' #' - legend text/title  
#' #' - label text  
#' #'
#' #' ### Multiple group.by
#' #' If multiple `group.by` values are passed, the function recursively creates multiple
#' #' plots and returns a patchwork layout.
#' #'
#' #' @return
#' #' - A ggplot object (2D)  
#' #' - A plotly object (3D) if `threeD = TRUE`  
#' #' - A patchwork object when multiple `group.by` inputs are provided  
#' #'
#' #' @import Seurat ggplot2 dplyr ggrepel plotly patchwork
#' #'
#' #' @examples
#' #' \dontrun{
#' #' cellmap(seurat_obj, group.by = "celltype")
#' #'
#' #' # With alphabetical legend (by default)
#' #' cellmap(seurat_obj, group.by = "seurat_clusters")
#' #'
#' #' # With custom legend order
#' #' cols <- c(B = "#1f77b4", A = "#ff7f0e")
#' #' cellmap(seurat_obj, group.by = "cluster", colors = cols)
#' #'
#' #' # 3D embedding
#' #' cellmap(seurat_obj, dims = c(1, 2, 3), threeD = TRUE)
#' #' }
#' #'
#' #' @export
#' #' 
#' cellmap <- function(object, group.by = NULL, shuffle = FALSE, raster = NULL, alpha = 1, repel = FALSE,
#'                      reduction = "umap", dims = c(1, 2), cell.number = TRUE, label = FALSE, label.size = 5,
#'                      label.fontface = "italic", colors = NULL, expand.colors = TRUE, figure.plot = FALSE,
#'                      no.axes = FALSE, plot.title = NULL, legend = TRUE, legend.title = NULL, item.size = 4,
#'                      legend.position = "right", legend.justification = "center", legend.ncol = 1, legend.dot.border = TRUE,
#'                      cell.countours = FALSE, font.size = 8, pt.size = NULL, dark.theme = FALSE, show.total.cells = FALSE,
#'                      threeD = FALSE, ...) {
#'   
#'   require(Seurat)
#'   require(ggplot2)
#'   require(dplyr)
#'   require(ggrepel)
#'   require(plotly)
#'   require(patchwork)
#'   
#'   if (length(group.by) > 1) {
#'     message("Multiple 'group.by' values detected. Generating separate plots...")
#'     plots <- lapply(group.by, function(g) {
#'       cellmap(object = object, group.by = g, shuffle = shuffle, raster = raster, alpha = alpha,
#'                repel = repel, reduction = reduction, dims = dims, cell.number = cell.number,label = label,
#'                label.size = label.size,label.fontface = label.fontface, colors = colors, no.axes = no.axes,
#'                expand.colors = expand.colors, figure.plot = figure.plot, plot.title = g, legend = legend,
#'                legend.title = g, item.size = item.size, legend.position = legend.position,
#'                legend.justification = legend.justification, legend.ncol = legend.ncol, font.size = font.size,
#'                legend.dot.border = legend.dot.border, cell.countours = cell.countours, pt.size = pt.size,
#'                dark.theme = dark.theme, show.total.cells = show.total.cells,threeD = threeD, ...)
#'     })
#'     return(patchwork::wrap_plots(plots))
#'   }
#'   
#'   stopifnot(inherits(object, "Seurat"))
#'   if (is.null(group.by)) group.by <- "ident"
#'   if (group.by == "ident") object@meta.data$ident <- Idents(object)
#'   else if (!group.by %in% colnames(object@meta.data))
#'     stop(paste("Grouping column", group.by, "does not exist in metadata."))
#'   
#'   object <- SetIdent(object, value = group.by)
#'   
#'   
#'   # COMPLETELY REPLACE the factor-handling block
#'   values <- as.character(object@meta.data[[group.by]])
#'   values[is.na(values)] <- "Unknown"
#'   
#'   if (is.factor(object@meta.data[[group.by]])) {
#'     levels_group <- levels(object@meta.data[[group.by]])
#'   } else {
#'     levels_group <- unique(values)   # preserve natural order, NOT alphabetical
#'   }
#'   
#'   if ("Unknown" %in% values && !("Unknown" %in% levels_group)) {
#'     levels_group <- c(levels_group, "Unknown")
#'   }
#'   
#'   object@meta.data[[group.by]] <- factor(values, levels = levels_group)
#'   Idents(object) <- object@meta.data[[group.by]]
#'   
#'   if (missing(legend.ncol)) {
#'     if (length(levels_group) > 18) legend.ncol <- 2 else legend.ncol <- 1
#'   }
#'   
#'   if (is.null(colors)) {
#'     colors <- custom_palette(length(levels_group))
#'     names(colors) <- levels_group
#'     if ("Unknown" %in% names(colors)) colors["Unknown"] <- "gray70"
#'   } else {
#'     # Ensure names
#'     if (is.null(names(colors))) {
#'       # assign in order; truncate or warn if mismatch
#'       colors <- setNames(colors[seq_len(length(levels_group))], levels_group)
#'     }
#'     
#'     # Make sure all levels have a color
#'     missing_levels <- setdiff(levels_group, names(colors))
#'     if (length(missing_levels) > 0) {
#'       colors[missing_levels] <- "gray70"
#'     }
#'     
#'     # Keep only colors for existing levels
#'     colors <- colors[levels_group]
#'   }
#'   
#'   if (!(reduction %in% names(object@reductions))) {
#'     stop(paste0("Reduction '", reduction, "' not found. Available: ",
#'                 paste(names(object@reductions), collapse = ", ")))
#'   }
#'   embeddings <- object@reductions[[reduction]]@cell.embeddings
#'   if (max(dims) > ncol(embeddings))
#'     stop("Selected dims exceed available dimensions in reduction.")
#'   
#'   if (threeD || length(dims) == 3) {
#'     df <- data.frame(
#'       x = embeddings[, dims[1]],
#'       y = embeddings[, dims[2]],
#'       z = embeddings[, dims[3]],
#'       cluster = Idents(object)
#'     )
#'     hover_labels <- if (cell.number) {
#'       cell.nb <- table(df$cluster)
#'       paste0(df$cluster, " (n=",cell.nb[as.character(df$cluster)],")")
#'     } else as.character(df$cluster)
#'     
#'     p3d <- plot_ly(
#'       df, x = ~x, y = ~y, z = ~z, color = ~cluster, colors = colors,
#'       type = "scatter3d", mode = "markers",
#'       marker = list(size = ifelse(is.null(pt.size), 2, pt.size),
#'                     opacity = alpha, line = list(width = 0)),
#'       text = hover_labels, hoverinfo = "text"
#'     )
#'     if (label) {
#'       centers <- df %>% group_by(cluster) %>% summarise(
#'         x = median(x), y = median(y), z = median(z)
#'       )
#'       p3d <- p3d %>%
#'         add_text(data = centers, x = ~x, y = ~y, z = ~z,
#'                  text = ~cluster, textposition = "top center")
#'     }
#'     return(p3d)
#'   }
#'   
#'   plt <- DimPlot(
#'     object = object, group.by = group.by,
#'     shuffle = shuffle, raster = raster, pt.size = pt.size,
#'     repel = repel, alpha = alpha, reduction = reduction, dims = dims, ...
#'   )
#'   
#'   if (!is.null(alpha) && alpha < 1)
#'     plt <- plt + scale_alpha_manual(values = rep(alpha, length(levels_group)), guide = "none")
#'   
#'   if (cell.number) {
#'     Idents(object) <- group.by
#'     cell.nb <- table(object@active.ident)
#'     sorted_cell_nb <- cell.nb[levels(object@meta.data[[group.by]])]
#'     ClusterLabels <- paste0(names(sorted_cell_nb), " (n=", sorted_cell_nb,")")
#'   } else ClusterLabels <- levels(object@meta.data[[group.by]])
#'   
#'   # DD breaks = levels_group
#'   plt <- plt + scale_color_manual(
#'     labels = ClusterLabels,
#'     values = colors,
#'     breaks = levels_group   
#'   )
#'   
#'   if (legend.dot.border) {
#'     plt <- plt & guides(color = guide_legend(
#'       override.aes = list(size = item.size, 
#'                           shape = 21,
#'                           size = 2,
#'                           color = "black",
#'                           stroke = 0.5, 
#'                           fill = unname(colors)),
#'       ncol = legend.ncol, 
#'       title = legend.title,
#'       keyheight = unit(0.25, "cm"),
#'       keywidth  = unit(0.25, "cm"),
#'       default.unit = "cm"
#'     ))
#'   } else {
#'     plt <- plt & guides(color = guide_legend(
#'       override.aes = list(size = item.size),
#'       ncol = legend.ncol, title = legend.title
#'     ))
#'   }
#'   
#'   total_cells <- ncol(object)
#'   if (is.null(plot.title)) plot.title <- group.by
#'   if (show.total.cells)
#'     plot.title <- paste0(plot.title, " (n = ", format(total_cells, big.mark = ","), ")")
#'   
#'   text_col <- if (dark.theme) "white" else "black"
#'   panel_bg <- if (dark.theme) "#1E1E1E" else "white"
#'   
#'   plt <- plt +
#'     labs(title = plot.title, colour = paste(legend.title)) +
#'     theme(
#'       plot.background = element_rect(fill = panel_bg, color = NA),
#'       panel.background = element_rect(fill = panel_bg, color = NA),
#'       plot.title = element_text(size = font.size + 4, hjust = 0.5,  face = "bold", color = text_col),
#'       axis.text.x = element_text(color = text_col, size = font.size),
#'       axis.text.y = element_text(color = text_col, size = font.size),
#'       axis.title = element_text(size = font.size, face = "bold", color = text_col),
#'       legend.title = element_text(size = font.size + 1, face = "bold", color = text_col),
#'       legend.text = element_text(size = font.size - 2, color = text_col),
#'       legend.position = legend.position,
#'       legend.justification = legend.justification,
#'       legend.spacing.y = unit(0.02, "cm"),
#'       legend.spacing.x = unit(0.02, "cm"),
#'       legend.key.height = unit(0.25, "cm"),
#'       legend.key.width = unit(0.25, "cm"),
#'       legend.background = element_rect(fill = if (dark.theme) "#2B2B2B" else "transparent", color = NA)
#'     )
#'   
#'   if (label) {
#'     umap_data <- tibble(
#'       x = embeddings[, dims[1]],
#'       y = embeddings[, dims[2]],
#'       cluster = as.character(object@active.ident)
#'     ) %>%
#'       group_by(cluster) %>%
#'       summarise(x = median(x), y = median(y), .groups = "drop")
#'     
#'     plt <- plt + geom_text_repel(
#'       data = umap_data, aes(x, y, label = cluster),
#'       color = if (dark.theme) "white" else "black",
#'       fontface = label.fontface, bg.color = if (dark.theme) "#3A3A3A" else "grey95",
#'       bg.r = 0.1, size = label.size, seed = 42
#'     )
#'   }
#'   
#'   if (cell.countours)
#'     plt <- plt & geom_point(
#'       aes(x = embeddings[, dims[1]], y = embeddings[, dims[2]]),
#'       shape = 21, colour = "black", stroke = 0.05
#'     )
#'   
#'   if (!legend) plt <- plt & NoLegend()
#'   if (no.axes) plt <- plt & NoAxes()
#'   
#'   if (figure.plot) {
#'     # x.lab.reduc <- if (!is.null(plt$labels$x)) plt$labels$x else paste0(toupper(reduction), "_", dims[1])
#'     # y.lab.reduc <- if (!is.null(plt$labels$y)) plt$labels$y else paste0(toupper(reduction), "_", dims[2])
#'     x.lab.reduc <- if (!is.null(plt$labels$x)) plt$labels$x else paste0(toupper(reduction), dims[1])
#'     y.lab.reduc <- if (!is.null(plt$labels$y)) plt$labels$y else paste0(toupper(reduction), dims[2])
#'     
#'     
#'     plt <- plt & NoAxes()
#'     
#'     axis.plot <- ggplot(data.frame(x = c(0, 1), y = c(0, 1)), aes(x, y)) +
#'       geom_blank() +
#'       xlab(x.lab.reduc) + ylab(y.lab.reduc) +
#'       theme_classic(base_size = font.size) +
#'       theme(
#'         plot.background  = element_rect(fill = "transparent", colour = NA),
#'         panel.background = element_rect(fill = "transparent"),
#'         axis.title       = element_text(size = font.size, face = "plain", colour = text_col),
#'         axis.text        = element_blank(),
#'         axis.ticks       = element_blank(),
#'         axis.line        = element_line(
#'           arrow = arrow(angle = 15, length = unit(.5, "cm"), type = "closed")
#'         )
#'       )    
#'     
#'     figure.layout <- c(
#'       patchwork::area(t = 1, l = 1, b = 11, r = 11),
#'       patchwork::area(t = 10, l = 1, b = 11, r = 2)
#'     )
#'     
#'     return(plt + axis.plot + patchwork::plot_layout(design = figure.layout))
#'   }
#'   
#'   return(plt)
#' }


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Cell Dot Plot (Enhanced Seurat DotPlot)
#'
#' A cleaner, more customizable wrapper around **Seurat::DotPlot**, providing
#' improved color handling, optional dot outlines, flexible axis formatting,
#' legend placement, and theme control. Useful for visualizing gene expression
#' patterns across clusters or metadata-defined groups.
#'
#' @param object A Seurat object.
#' @param features Character vector of features (genes or metadata fields) to plot.
#' @param group.by Column in `object@meta.data` used to group cells.
#'   Default: `"seurat_clusters"`.
#'
#' @param th.cols Color palette name from **RColorBrewer** used for the
#'   expression gradient. Default: `"Reds"`.
#' @param rev.th.cols Logical; reverse the gradient palette. Default: FALSE.
#'
#' @param dot.scale Numeric scale factor controlling the dot size range.
#'   Passed to `Seurat::DotPlot`. Default: 4.5.
#' @param dot.outline Logical; draw outlines around dots. Default: FALSE.
#'
#' @param x.angle Angle for x-axis labels (degrees). Default: 90.
#' @param vjust.x,hjust.x Vertical and horizontal justification for x labels.
#'
#' @param flip Logical; swap x and y axes using `coord_flip()`. Default: FALSE.
#'
#' @param font.size Base font size passed to internal theme helper. Default: 8.
#'
#' @param plot.title Optional plot title.
#'
#' @param leg.size Legend text size. Default: 8.
#' @param leg.pos Position of the legend (e.g., `"right"`, `"bottom"`).
#' @param leg.just Legend justification.
#' @param leg.hjust Logical; if TRUE, use a horizontal legend layout when possible.
#'
#' @param x.axis.pos Position of the x-axis (`"top"` or `"bottom"`).
#' @param theme ggplot2 theme name used by the internal theme helper.
#'
#' @param x.face,y.face Logical; italic styling for x and/or y-axis labels.
#' @param x.ttl,y.ttl Logical; italic styling for x and/or y-axis titles.
#'
#' @param ... Additional parameters passed to `Seurat::DotPlot()`.
#'
#' @details
#' This function enhances the standard Seurat dot plot by providing:
#' * Customizable Brewer color gradients  
#' * Optional dot outlines  
#' * Flexible axis label styling  
#' * Improved legend customization and ordering  
#' * Optional axis flipping  
#'
#' It retains all functionality of `Seurat::DotPlot` while adding cleaner,
#' publication-ready defaults.
#'
#' @return A ggplot object.
#'
#' @examples
#' \dontrun{
#' celldot(pbmc, features = c("MS4A1","CD3D"))
#'
#' celldot(pbmc, features = c("MS4A1","CD14"), th.cols = "Blues",
#'         dot.outline = TRUE, flip = TRUE)
#' }
#'
#' @export
#' 
celldot <- function(object, features, group.by="seurat_clusters", th.cols="Reds", rev.th.cols=FALSE,
                    dot.scale=4.5,x.angle=90, vjust.x=NULL, hjust.x=NULL,flip=FALSE, font.size=8, plot.title=NULL,
                    leg.size=10, leg.pos="right",leg.just="bottom", leg.hjust=FALSE,x.axis.pos="bottom", 
                    theme="classic",x.face=FALSE, y.face=FALSE,x.ttl=FALSE, y.ttl=FALSE,dot.outline=FALSE,
                    ...
){
  
  stopifnot(inherits(object,"Seurat"))
  object <- Seurat::SetIdent(object, value=group.by)
  features <- unique(features)
  
  pal <- RColorBrewer::brewer.pal(9, th.cols)
  if (rev.th.cols) pal <- rev(pal)
  
  # Outline settings
  outline_col <- if (dot.outline) "gray60" else NA
  outline_stroke <- if (dot.outline) 0.5 else 0
  
  # Base Seurat DotPlot
  plt <- suppressWarnings({suppressMessages({
    Seurat::DotPlot(object, features=features, dot.scale=dot.scale, ...) }) }) +
    scale_color_gradientn(colors=pal, oob=scales::squish) +
    geom_point(aes(size=pct.exp), shape=21, colour=outline_col, stroke=outline_stroke) +
    labs(title=plot.title, color="Average\nExpression",size="Percent\nExpressed") +
    plot_theme(theme=theme, font.size=font.size, x.angle=x.angle,x.hjust=hjust.x, x.vjust=vjust.x,
               xy.val=TRUE, x.lab=TRUE, y.lab=TRUE,leg.size = leg.size, leg.pos=leg.pos,
               leg.dir = ifelse(leg.hjust, "horizontal", "vertical"),
               leg.just = leg.just, x.ttl = x.ttl, y.ttl = y.ttl,
               ...)
  
  # Default guides
  guide_color <- guide_colorbar(frame.colour="black",ticks.colour="black")
  guide_size <- guide_legend(override.aes=list(shape=21, colour=outline_col, fill="black"))
  
  # Keep your original condition for horizontal legends
  if (leg.hjust && leg.pos %in% c("bottom", "top")) {
    guide_color <- guide_colorbar(title.position="top",title.hjust=0.5,frame.colour="black",
                                  ticks.colour="black",keyheight=unit(0.3,"cm"),keywidth=unit(2,"cm"))
    guide_size <- guide_legend(override.aes=list(shape=21, colour=outline_col, fill="black"),
                               title.position="top",title.hjust=0.5)
  }
  
  # Fix order
  guide_color$order <- 1
  guide_size$order  <- 2
  plt <- plt + guides(color = guide_color,size  = guide_size)
  
  # Axis placement
  if (x.axis.pos=="top") {
    plt <- plt + scale_x_discrete(position="top")
  }
  
  # Italic logic
  plt <- plt + theme(
    axis.text.x = if (x.face || (flip && y.face))
      element_text(face="italic") else element_text(),
    axis.text.y = if (y.face || (flip && x.face))
      element_text(face="italic") else element_text()
  )
  
  if (flip) plt <- plt + coord_flip()
  if (is.list(features)) plt <- plt + theme(strip.text.x=element_text(angle=45))
  
  return(plt)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Cell Feature Violin Plot with Statistics
#'
#' Plots expression or metadata features as violin plots for a Seurat object,
#' optionally adding median points, shared y-axis scaling, flipped axes, and
#' statistical comparisons (Wilcoxon for 2 groups, Kruskal-Wallis for >2 groups).
#'
#' @param obj A Seurat object.
#' @param features Character vector of feature names (genes or metadata columns) to plot.
#' @param ncol Number of columns in the output patchwork plot. Defaults to sqrt(#features / 1.5).
#' @param stack Logical; if TRUE, plots are stacked in a single column.
#' @param shared.y Logical; if TRUE, all violins share the same y-axis.
#' @param ttl.pos Position of subplot titles: "center", "left", or "right".
#' @param group.by Metadata column to group by. Defaults to "seurat_clusters".
#' @param split.by Optional metadata column to split violins by.
#' @param assay Assay to pull data from. Default is "RNA".
#' @param slot Slot to use for expression values. One of "data", "counts", or "scale.data".
#' @param log Logical; if TRUE, log-transform the expression values.
#' @param cols Optional named vector of colors for each group. If NULL, defaults are used.
#' @param med Logical; if TRUE, overlay median points on each violin.
#' @param med.size Size of median points if med = TRUE.
#' @param pt.size Size of jittered points. Set to 0 to hide points.
#' @param border.size Size of the violin border lines.
#' @param font.size Base font size for titles and labels.
#' @param theme ggplot2 theme to use: "classic", "minimal", etc.
#' @param x.angle Rotation angle of x-axis labels.
#' @param leg.pos Position of legend: "none", "right", "left", etc.
#' @param title Optional overall title for the patchwork plot.
#' @param rm.subtitles Logical; if TRUE, removes individual subplot titles.
#' @param flip Logical; if TRUE, flips x and y axes.
#' @param auto.resize Logical; if TRUE, sets dynamic width/height attributes.
#' @param ylab.global Global y-axis label. Defaults to expression level.
#' @param xlab.global Global x-axis label. Defaults to blank.
#' @param pairwise Logical; if TRUE, perform pairwise comparisons between groups.
#' @param add.stats Logical; if TRUE, add p-values to plots.
#' @param show.pval Logical; if TRUE, show p-values above violins.
#' @param pval.label Character; label type for p-values, e.g., "p.signif" or "p.format".
#' @param ... Additional arguments passed to ggplot2 layers.
#'
#' @return A patchwork object containing the violin plots.
#' @examples
#' \dontrun{
#' cellvio(sub, features = c("MEG3","TP63","HES6"),
#'         group.by = "ann_level_2",
#'         pt.size = 0.1, ncol = 3, pairwise = TRUE,
#'         font.size = 10, show.pval = TRUE)
#' }
#' @export
#' 
# cellvio_v1 <- function(
#     obj, features,
#     ncol = NULL,
#     shared.y = FALSE,
#     ttl.pos = c("center", "left", "right"),
#     group.by = "seurat_clusters",
#     split.by = NULL,
#     stack = FALSE,
#     assay = "RNA",
#     slot = "data",
#     log = FALSE,
#     cols = NULL,
#     med = FALSE,
#     med.size = 1,
#     pt.size = 0,
#     border.size = 0.1,
#     font = 8,
#     theme = "classic",
#     x.angle = 45,
#     leg.pos = "none",
#     title = NULL,
#     rm.subttl = FALSE,
#     flip = FALSE,
#     auto.resize = TRUE,
#     ylab.global = NULL,
#     xlab.global = NULL,
#     add.stats = FALSE,
#     show.pval = FALSE,
#     pairwise = FALSE,
#     pval.label = "p.signif",
#     font.size = 10,
#     ...
# ) {
#   
#   stopifnot(inherits(obj, "Seurat"))
#   if (length(features) == 0) stop("features must be provided.")
#   ttl.pos <- match.arg(ttl.pos)
#   
#   
#   # --- determine ncol ---
#   if (is.null(ncol)) {
#     ncol <- if (stack) 1 else max(1, ceiling(sqrt(length(features) / 1.5)))
#   }
#   
#   # Set identities if grouping
#   if (!is.null(group.by)) {
#     if (!group.by %in% colnames(obj@meta.data))
#       stop(paste(group.by, "not found in metadata."))
#     Idents(obj) <- group.by
#   }
#   
#   # Determine which features exist
#   f.expr <- intersect(features, rownames(obj[[assay]]))
#   f.meta <- intersect(features, colnames(obj@meta.data))
#   features <- unique(c(f.expr, f.meta))
#   if (!length(features)) stop("No features found in assay or metadata.")
#   
#   # Shared y-scale
#   ymax <- NULL
#   if (shared.y) {
#     vals <- c(
#       if (length(f.expr)) as.numeric(Seurat::GetAssayData(obj, assay, slot)[f.expr, ]),
#       if (length(f.meta)) as.numeric(as.matrix(obj@meta.data[, f.meta, drop = FALSE]))
#     )
#     vals <- vals[is.finite(vals)]
#     if (length(vals)) ymax <- max(vals)
#   }
#   
#   # Colors
#   if (is.null(cols)) {
#     g <- tryCatch(unique(obj[[group.by]][, 1]), error = \(e) NULL)
#     cols <- custom_palette(length(g))
#     #cols <- scales::hue_pal()(if (is.null(g)) 8 else length(g))
#     #cols <- ggpubr::get_palette("npg", length(g))
#     names(cols) <- g
#   }
#   
#   # ---- helper to build a single violin ----
#   # Helper to build a single violin with stats
#   vln <- function(f) {
#     df <- Seurat::FetchData(obj, vars = c(group.by, f))
#     names(df)[2] <- "value"
#     df[[group.by]] <- factor(df[[group.by]]) # ensure factor
#     
#     # Base plot
#     p <- ggplot(df, aes_string(group.by, "value", fill = group.by)) +
#       geom_violin(scale = "width", color = "black", size = border.size) +
#       scale_fill_manual(values = cols)
#     
#     # Points
#     if (pt.size > 0) p <- p + geom_jitter(width = 0.1, size = pt.size, alpha = 0.6)
#     
#     # Add statistics
#     if (add.stats && show.pval && length(levels(df[[group.by]])) > 1) {
#       cmp <- if (pairwise) utils::combn(levels(df[[group.by]]), 2, simplify = FALSE) else NULL
#       stat_fun <- if (length(levels(df[[group.by]])) == 2) "wilcox.test" else "kruskal.test"
#       y_max <- max(df$value, na.rm = TRUE)
#       y_step <- (ymax %||% y_max) * 0.05
#       p <- p + ggpubr::stat_compare_means(
#         method = stat_fun,
#         comparisons = cmp,
#         label = pval.label,
#         hide.ns = FALSE,
#         label.y = y_max + seq(0, by = y_step, length.out = length(cmp))
#       )
#     }
#     
#     
#     # Titles
#     p <- if (!rm.subttl) p + labs(title = f) else p + labs(title = NULL)
#     
#     # Theme & formatting
#     p <- p + plot_theme(theme = theme, font.size = font.size, x.angle = x.angle,
#                         leg.pos = leg.pos, x.ttl = FALSE, ttl.pos = ttl.pos)
#     
#     if (med) p <- p + stat_summary(fun = median, geom = "point", shape = 3, size = med.size)
#     if (!is.null(ymax)) p <- p + ylim(0, ymax)
#     if (flip) p <- p + coord_flip()
#     p + ylab(NULL)
#   }
#   
#   # number of cols
#   if (is.null(ncol))
#     ncol <- max(1, ceiling(sqrt(length(features) / 1.5)))
#   
#   plist <- lapply(features, vln)
#   total <- length(plist)
#   
#   # Only show x-axis on bottom plots
#   bottom <- sapply(1:ncol, \(i) max(seq(i, total, by = ncol)))
#   for (i in seq_along(plist)) {
#     if (!(i %in% bottom)) {
#       plist[[i]] <- plist[[i]] +
#         theme(axis.text.x = element_blank(),
#               axis.ticks.x = element_blank())
#     }
#   }
#   
#   # Layout
#   combo <- patchwork::wrap_plots(plist, ncol = ncol) +
#     patchwork::plot_layout(guides = "collect")
#   
#   if (!is.null(title)) {
#     combo <- combo +
#       patchwork::plot_annotation(
#         title = title,
#         theme = theme(title = element_text(face = "bold"))
#       )
#   }
#   
#   # Global labels
#   auto_y <- switch(slot,
#                    data = "Expression level",
#                    counts = "Raw counts",
#                    scale.data = "Scaled expression",
#                    "Expression level")
#   
#   ylab <- if (is.null(ylab.global)) auto_y else ylab.global
#   xlab <- if (is.null(xlab.global)) "" else xlab.global
#   
#   plt <- cowplot::ggdraw(combo) +
#     cowplot::draw_label(ylab, x = -0.01, y = 0.55, angle = 90, size = font) +
#     cowplot::draw_label(xlab, x = 0.5, y = 0.02, size = font) +
#     theme(plot.margin = margin(15, 15, 15, 15))
#   
#   # Auto resize attributes
#   if (auto.resize) {
#     ng <- length(unique(obj[[group.by]][, 1]))
#     attr(plt, "dynamic_width") <- 6 + ng * 0.3
#     attr(plt, "dynamic_height") <- 4 + length(features) * 0.25
#   }
#   
#   plt
# }

cellvio <- function(
    obj, features,
    ncol = NULL,
    shared.y = FALSE,
    ttl.pos = c("center", "left", "right"),
    group.by = "seurat_clusters",
    split.by = NULL,
    stack = FALSE,
    assay = "RNA",
    slot = "data",
    log = FALSE,
    cols = NULL,
    med = FALSE,
    med.size = 1,
    pt.size = 0,
    border.size = 0.1,
    theme = "classic",
    x.angle = 45,
    leg.pos = "none",
    title = NULL,
    rm.subttl = FALSE,
    flip = FALSE,
    auto.resize = TRUE,
    ylab.global = NULL,
    xlab.global = NULL,
    add.stats = FALSE,
    show.pval = FALSE,
    pairwise = FALSE,
    pval.label = "p.signif",
    font.size = 10,
    ...
) {
  
  stopifnot(inherits(obj, "Seurat"))
  if (length(features) == 0) stop("features must be provided.")
  ttl.pos <- match.arg(ttl.pos)
  
  
  # determine ncol
  if (is.null(ncol)) {
    ncol <- if (stack) 1 else max(1, ceiling(sqrt(length(features) / 1.5)))
  }
  
  # Set identities if grouping
  if (!is.null(group.by)) {
    if (!group.by %in% colnames(obj@meta.data))
      stop(paste(group.by, "not found in metadata."))
    Idents(obj) <- group.by
  }
  
  # Determine which features exist
  f.expr <- intersect(features, rownames(obj[[assay]]))
  f.meta <- intersect(features, colnames(obj@meta.data))
  features <- unique(c(f.expr, f.meta))
  if (!length(features)) stop("No features found in assay or metadata.")
  
  # Shared y-scale
  ymax <- NULL
  if (shared.y) {
    vals <- c(
      if (length(f.expr)) as.numeric(Seurat::GetAssayData(obj, assay, slot)[f.expr, ]),
      if (length(f.meta)) as.numeric(as.matrix(obj@meta.data[, f.meta, drop = FALSE]))
    )
    vals <- vals[is.finite(vals)]
    if (length(vals)) ymax <- max(vals)
  }
  
  # Colors
  if (is.null(cols)) {
    g <- tryCatch(unique(obj[[group.by]][, 1]), error = \(e) NULL)
    cols <- custom_palette(length(g))
    #cols <- scales::hue_pal()(if (is.null(g)) 8 else length(g))
    #cols <- ggpubr::get_palette("npg", length(g))
    names(cols) <- g
  }
  
  # Helper to build a single violin with stats
  vln <- function(f) {
    
    if (log && slot == "counts") {
      obj[[assay]]@data[f, ] <- log1p(obj[[assay]]@counts[f, ])
      slot_use <- "data"
    } else {
      slot_use <- slot
    }
    
    df <- Seurat::FetchData(obj, vars = c(group.by, f))
    names(df)[2] <- "value"
    df[[group.by]] <- factor(df[[group.by]]) # ensure factor
    
    # Base plot
    # p <- ggplot(df, aes_string(group.by, "value", fill = group.by)) +
    #   geom_violin(scale = "width", color = "black", size = border.size) +
    #   scale_fill_manual(values = cols)
    
    p <- suppressWarnings({
      suppressMessages({Seurat::VlnPlot(
      obj,
      features = f,
      group.by = group.by,
      split.by = split.by,
      assay = assay,
      slot = slot,
      pt.size = pt.size,
      cols = cols,
      ...
    ) + scale_y_continuous(
      expand = expansion(mult = c(0.05, 0.25))
    )
      })
    })
    
    # Points
    #if (pt.size > 0) p <- p + geom_jitter(width = 0.1, size = pt.size, alpha = 0.6)
    
    # Add statistics
    if (add.stats && show.pval && length(levels(df[[group.by]])) > 1) {
      cmp <- if (pairwise) utils::combn(levels(df[[group.by]]), 2, simplify = FALSE) else NULL
      stat_fun <- if (length(levels(df[[group.by]])) == 2) "wilcox.test" else "kruskal.test"
      y_max <- max(df$value, na.rm = TRUE)
      y_step <- (ymax %||% y_max) * 0.05
      p <- p + ggpubr::stat_compare_means(
        method = stat_fun,
        comparisons = cmp,
        label = pval.label,
        hide.ns = FALSE,
        label.y = y_max + seq(0, by = y_step, length.out = length(cmp))
      )
    }
    
    
    # Titles
    p <- if (!rm.subttl) p + labs(title = f) else p + labs(title = NULL)
    
    .style_layers <- function(
    p,
    violin_lw = 0.15,
    point_size = NULL,
    jitter_width = NULL
    ) {
      for (i in seq_along(p$layers)) {
        
        layer <- p$layers[[i]]
        
        # ---- Violin outline ----
        if (inherits(layer$geom, "GeomViolin")) {
          layer$aes_params$linewidth <- violin_lw
        }
        
        # ---- Points (Seurat uses GeomPoint + position_jitterdodge) ----
        if (inherits(layer$geom, "GeomPoint")) {
          
          if (!is.null(point_size)) {
            layer$aes_params$size  <- point_size
            layer$aes_params$alpha <- 0.6
          }
          
          if (!is.null(jitter_width) &&
              inherits(layer$position, "PositionJitterdodge")) {
            layer$position$width <- jitter_width
          }
        }
        
        p$layers[[i]] <- layer
      }
      p
    }
    
    p <- .style_layers(
      p,
      violin_lw  = border.size,
      point_size = if (pt.size > 0) pt.size else NULL,
      jitter_width = 0.08
    )
    
    # Theme & formatting
    p <- p + plot_theme(theme = theme, font.size = font.size, x.angle = x.angle,
                        leg.pos = leg.pos, x.ttl = FALSE, ttl.pos = ttl.pos)
    
    if (med) p <- p + stat_summary(fun = median, geom = "point", shape = 3, size = med.size)
    if (!is.null(ymax)) p <- p + ylim(0, ymax)
    if (flip) p <- p + coord_flip()
    p + ylab(NULL)
  }
  
  # number of cols
  if (is.null(ncol))
    ncol <- max(1, ceiling(sqrt(length(features) / 1.5)))
  
  plist <- lapply(features, vln)
  total <- length(plist)
  
  # Only show x-axis on bottom plots
  bottom <- sapply(1:ncol, \(i) max(seq(i, total, by = ncol)))
  for (i in seq_along(plist)) {
    if (!(i %in% bottom)) {
      plist[[i]] <- plist[[i]] +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank())
    }
  }
  
  # Layout
  combo <- patchwork::wrap_plots(plist, ncol = ncol) +
    patchwork::plot_layout(guides = "collect")
  
  if (!is.null(title)) {
    combo <- combo +
      patchwork::plot_annotation(
        title = title,
        theme = theme(title = element_text(face = "bold"))
      )
  }
  
  # Global labels
  auto_y <- switch(slot,
                   data = "Expression level",
                   counts = "Raw counts",
                   scale.data = "Scaled expression",
                   "Expression level")
  
  ylab <- if (is.null(ylab.global)) auto_y else ylab.global
  xlab <- if (is.null(xlab.global)) "" else xlab.global
  
  plt <- cowplot::ggdraw(combo) +
    cowplot::draw_label(ylab, x = -0.01, y = 0.55, angle = 90, size = font.size) +
    cowplot::draw_label(xlab, x = 0.5, y = 0.02, size = font.size) +
    theme(plot.margin = margin(15, 15, 15, 15))
  
  # Auto resize attributes
  if (auto.resize) {
    ng <- length(unique(obj[[group.by]][, 1]))
    attr(plt, "dynamic_width") <- 6 + ng * 0.3
    attr(plt, "dynamic_height") <- 4 + length(features) * 0.25
  }
  
  plt
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Residualized UMI Plot
#'
#' Compute residualized mean UMIs per donor/cell type and plot per cell.
#'
#' @param data Seurat object or data.frame with cell metadata.
#' @param cell.col Column name for cell type (default "cell_type").
#' @param group.col Column name for grouping variable (e.g., sex; default "sex").
#' @param stage.col Column name for numeric covariate to residualize by (e.g., PCW; default "PCW_num").
#' @param value.col Name of residualized value column (default "resid_mean_UMI_adj").
#' @param plot.type "bar" or "box" (default "box").
#' @param theme Theme name.
#' @param group.colors Named vector of colors for group.col.
#' @param stage.colors Named vector of colors for stage.col (numeric/factor).
#' @param jitter.size Size of points (default 1).
#' @param alpha Point transparency (default 0.8).
#' @param x.angle Angle for x-axis labels.
#' @param font.size Base font size.
#' @param leg.pos Legend position (default "top").
#' @return ggplot object.
#' @export
residual_plot <- function(data, cell.col, group.col, stage.col,
                          plot.type = c("box", "bar"), theme = "classic",
                          group.colors = NULL, stage.colors = NULL,
                          jitter.size = 1, alpha = 0.8, xlab = TRUE, ylab = TRUE,
                          x.angle = 45, font.size = 10, leg.pos = "top",...) {
  
  plot.type <- match.arg(plot.type)
  
  # --- Extract metadata if Seurat ---
  if (inherits(data, "Seurat")) {
    
    meta <- data@meta.data %>% as.data.frame()
    
    # Check columns exist
    for (col in c(cell.col, group.col, stage.col)) {
      if (!col %in% colnames(meta)) stop(paste0("Column '", col, "' not found in metadata."))
    }
    
    # Keep original stage labels for coloring
    meta$stage <- factor(meta[[stage.col]])
    
    # Create numeric version for regression only
    meta$stage_num <- suppressWarnings(as.numeric(gsub("[^0-9.]", "", meta[[stage.col]])))
    if (all(is.na(meta$stage_num))) {
      stop("Stage column could not be converted to numeric for regression.")
    }
    
    donor_celltype <- meta %>%
      group_by(sample, .data[[cell.col]], .data[[group.col]],
               stage, stage_num) %>%
      summarise(mean_UMI = mean(nCount_RNA, na.rm = TRUE), .groups="drop")
    
    resid_df <- donor_celltype %>%
      group_by(.data[[cell.col]]) %>%
      do({
        df <- .
        if (nrow(df) < 2) { df$resid <- NA; return(df) }
        df$resid <- resid(lm(mean_UMI ~ stage_num, data=df))
        df
      }) %>% ungroup() %>%
      mutate(resid_mean_UMI_adj = resid - min(resid, na.rm = TRUE))
    
    # Attach residuals to full metadata
    data_df <- meta %>%
      left_join(resid_df %>%
                  select(sample, .data[[cell.col]], resid_mean_UMI_adj),
                by = c("sample", cell.col))
    
    # These are the columns used by ggplot
    value.col <- "resid_mean_UMI_adj"
    stage.col <- "stage"  # <- IMPORTANT FIX
  } else if (is.data.frame(data)) {
    data_df <- data
    if (!all(c(cell.col, group.col, stage.col) %in% colnames(data_df))) {
      stop("Data frame must contain cell.col, group.col, and stage.col.")
    }
    value.col <- "resid_mean_UMI_adj"
    if (!value.col %in% colnames(data_df)) stop("Residual value column not found in data.frame.")
  } else {
    stop("data must be Seurat object or data.frame")
  }
  
  # Convert stage to factor for coloring in ggplot
  data_df[[stage.col]] <- factor(data_df[[stage.col]])
  
  # Prepare summary for bar plot
  if (plot.type == "bar") {
    bar_df <- data_df %>%
      group_by(.data[[cell.col]], .data[[group.col]]) %>%
      summarise(mean_val = mean(.data[[value.col]], na.rm = TRUE),
                se_val = sd(.data[[value.col]], na.rm = TRUE)/sqrt(n()),
                .groups = "drop")
  }
  
  # Base ggplot
  p <- ggplot(data_df, aes_string(x = cell.col, y = value.col, fill = group.col))
  
  if (plot.type == "box") {
    p <- p + geom_boxplot(outlier.shape = NA, alpha = 1,
                          position = position_dodge(width = 0.8), color = "black", linewidth = 0.2)
  } else if (plot.type == "bar") {
    p <- p + geom_bar(data = bar_df, aes_string(y = "mean_val"),
                      stat = "identity", position = position_dodge(width = 0.8),
                      color = "black", linewidth = 0.2)
  }
  
  p <- p + geom_jitter(aes_string(color = stage.col),
                       size = jitter.size, alpha = alpha,
                       position = position_jitterdodge(jitter.width = 0.15, dodge.width = 0.8))
  
  # Apply colors
  if (!is.null(group.colors)) p <- p + scale_fill_manual(values = group.colors)
  if (!is.null(stage.colors)) p <- p + scale_color_manual(values = stage.colors)
  
  # Labels & theme
  p <- p +
    labs(x = "", y = "Residualized mean UMIs", fill = group.col, color = stage.col) +
    plot_theme(x.angle = x.angle, theme = theme, font.size = font.size,
               leg.pos = leg.pos, xlab = xlab, ylab = ylab,...) +
    theme(
      legend.background = element_rect(fill = "transparent", color = NA),
      legend.box.background = element_rect(fill = "transparent", color = NA),
      panel.background = element_rect(fill = "transparent",  color = NA)
    )
  return(p)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Unique Gene Counts Per Cell (Robust Version)
#'
#' This function visualizes the number of selected genes expressed per cell.
#' It accepts either a Seurat object with a gene list or a precomputed per-cell table.
#' Missing or unexpressed genes are automatically handled with warnings.
#'
#' @param object Either a Seurat object or a data.frame with columns `Cell` and `Unique`.
#' @param gene.list Character vector of genes to evaluate (required if `object` is a Seurat object).
#' @param plot.type One of "bar", "hist", or "violin".
#' @param font.size Numeric font size.
#' @param theme Theme type passed to `plot_theme()`.
#' @param x.lab X-axis title.
#' @param y.lab Y-axis title.
#' @param ... Additional arguments passed to `plot_theme()`.
#'
#' @return A ggplot2 object.
#' @export
plot_unique_gene_counts <- function(
    object,
    gene.list = NULL,
    plot.type = c("bar", "hist", "violin"),
    font.size = 8,
    theme = "classic",
    x.lab = "Number of cells",
    y.lab = "Number of ORs",
    color = "#20679B",
    ...
) {
  
  # --- Get per-cell table ---
  if (inherits(object, "Seurat")) {
    
    if (is.null(gene.list)) stop("If `object` is a Seurat object, you must supply `gene.list`.")
    
    counts <- rownames(object[["RNA"]]@counts)
    genes.present <- intersect(gene.list, counts)
    
    if (length(genes.present) == 0) stop("None of the genes in `gene.list` exist in the object.")
    
    if (length(genes.present) < length(gene.list)) {
      warning(sprintf("Only %d/%d genes found in the object. Proceeding with available genes.", 
                      length(genes.present), length(gene.list)))
    }
    
    tbl <- get_unique_gene_table(object, genes.present)
    per.cell <- as.data.frame(tbl$per.cell)
    
  } else {
    per.cell <- as.data.frame(object)
    if (!all(c("Cell", "Unique") %in% colnames(per.cell))) {
      stop("`object` must be a Seurat object OR a data.frame with columns: Cell, Unique")
    }
  }
  
  # --- Filter non-expressing cells ---
  df <- per.cell[per.cell$Unique > 0, , drop = FALSE]
  
  if (nrow(df) == 0) stop("No cells express the selected genes.")
  
  df$Unique.factor <- factor(df$Unique)
  
  plot.type <- match.arg(plot.type)
  
  # --- Generate plot ---
  plt <- switch(
    plot.type,
    "bar" = ggplot(df, aes(x = Cell, y = Unique.factor)) +
      geom_bar(stat = "identity", colour = color) +
      labs(x = x.lab, y = y.lab) +
      plot_theme(theme = theme, legend.position = "none", font.size = font.size) +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()),
    
    "hist" = ggplot(df, aes(x = Unique)) +
      geom_histogram(binwidth = 1, fill = color, colour = "black") +
      labs(x = y.lab, y = "Number of cells") +
      plot_theme(theme = theme, font.size = font.size),
    
    "violin" = ggplot(df, aes(x = "", y = Unique)) +
      geom_violin(trim = FALSE, fill = color) +
      geom_jitter(width = 0.1, alpha = 0.4) +
      labs(x = "", y = y.lab) +
      plot_theme(theme = theme, font.size = font.size, ...)
  )
  
  return(plt)
}





#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot cluster proportions per sample or group
#'
#' This function visualizes cell type or cluster proportions across samples or groups,
#' optionally aggregating per-cell data to donor-level pseudobulk proportions. Supports
#' barplots or boxplots with statistical comparisons between groups.
#'
#' @param data A Seurat object or metadata data.frame.
#' @param data.full Optional Seurat object or metadata data.frame with full dataset
#'   for calculating total cell counts. Defaults to `data`.
#' @param cluster.col Column name for cluster/cell type annotation. Default: `"ann_level_3"`.
#' @param group.col Column name for group variable. Default: `"group"`.
#' @param sample.col Column name for sample identifier. Default: `"sample"`.
#' @param aggregate Logical; if TRUE, compute donor-level pseudobulk proportions. Default: TRUE.
#' @param sample.order.col Optional column for ordering samples. Default: NULL.
#' @param sample.colors Named vector of colors for samples. Default: NULL.
#' @param group.colors Named vector of colors for groups. Default: NULL.
#' @param font.size Base font size. Default: 10.
#' @param show.contour Logical; draw black border around bars/boxes. Default: TRUE.
#' @param theme ggplot theme type (e.g., `"minimal"`, `"classic"`). Default: `"minimal"`.
#' @param plot.type `"barplot"` or `"boxplot"`. Default: `"barplot"`.
#' @param x.angle Rotation angle for x-axis labels. Default: 45.
#' @param show.pval Logical; show p-values on plot. Default: TRUE.
#' @param multi.pval Logical; show multiple pairwise comparisons. Default: TRUE.
#' @param pairwise.test Logical; perform pairwise tests (currently unused). Default: FALSE.
#' @param label Label type for stats: `"p.signif"` or `"p.format"`. Default: `"p.signif"`.
#' @param label.size Font size for stat labels. Default: 5.
#' @param legend Logical; show legend. Default: TRUE.
#' @param legend.ncol Number of legend columns. Default: 1.
#' @param legend.title Legend title. Default: NULL.
#' @param plot.title Plot title. Default: NULL.
#' @param x.title X-axis label. Default: NULL.
#' @param y.title Y-axis label. Default: `"Percent"`.
#' @param ncol Number of facet columns. Default: 4.
#' @param bg.color Background panel color. Default: `"gray95"`.
#' @param ... Additional arguments passed to `plot_theme()`.
#'
#' @return ggplot object
#'
#' @examples
#' \dontrun{
#' plot_cluster_percent(
#'   data = seurat_obj,
#'   cluster.col = "ann_level_2",
#'   group.col = "PCW",
#'   sample.col = "sample",
#'   plot.type = "barplot",
#'   aggregate = TRUE,
#'   font.size = 8,
#'   x.angle = 45,
#'   show.pval = TRUE,
#'   multi.pval = FALSE,
#'   legend = FALSE
#' )
#' }
#' @export
#'
plot_cluster_percent <- function(data, data.full = NULL, cluster.col = "seurat_clusters", group.col = "group", sample.col = "sample", aggregate = TRUE,
    sample.order.col = NULL, sample.colors = NULL, group.colors = NULL, font.size = 8, show.contour = TRUE, theme = "minimal", plot.type = "barplot",
    x.angle = 45, show.pval = TRUE, multi.pval = TRUE, pairwise.test = FALSE, label = "p.signif", label.size = 5, legend = TRUE, legend.ncol = 1,
    legend.title = NULL, plot.title = NULL, x.title = NULL, y.title = "Proportion (%)", ncol = 4, bg.color = "white", facet.bg = TRUE,
    ...
) {
  require(ggplot2); require(ggpubr); require(dplyr); require(Seurat)
  
  # Convert Seurat objects to metadata
  if (inherits(data, "Seurat")) data <- data@meta.data
  if (!is.null(data.full) && inherits(data.full, "Seurat")) data.full <- data.full@meta.data
  if (is.null(data.full)) data.full <- data
  
  # Auto-fallback: use Idents if cluster.col not in metadata
  if (!cluster.col %in% colnames(data)) {
    if (inherits(data, "data.frame") && !is.null(attr(data, "Seurat"))) {
      data$cluster_temp <- as.character(Idents(attr(data, "Seurat")))
      cluster.col <- "cluster_temp"
      message("cluster.col not found in metadata. Using Idents(data) instead.")
    } else if (exists("Idents", mode = "function")) {
      data$cluster_temp <- as.character(Idents(data))
      cluster.col <- "cluster_temp"
      message("cluster.col not found. Using Idents(data) instead.")
    } else {
      stop(paste0("cluster.col '", cluster.col, "' not found and Idents unavailable."))
    }
  }
  
  # Aggregate per-sample totals
  total.cells <- data.full %>%
    group_by(across(all_of(sample.col))) %>%
    summarise(total.cells = n(), .groups = "drop")
  
  # Aggregate to donor-level pseudobulk proportions
  if (aggregate) {
    message("Aggregating per-cell data to donor-level pseudobulk proportions...")
    
    data <- data %>%
      group_by(across(all_of(c(cluster.col, group.col, sample.col)))) %>%
      summarise(num = n(), .groups = "drop") %>%
      left_join(total.cells, by = sample.col) %>%
      mutate(freq = (num / total.cells) * 100) %>%
      filter(!is.na(freq)) %>%
      rename(cluster = !!sym(cluster.col))
    
  } else {
    message("Using pre-aggregated donor-level data (no aggregation performed).")
    data <- data %>%
      rename(cluster = !!sym(cluster.col), freq = percent)
  }
  
  # Default colors
  if (is.null(group.colors)) {
    group.colors <- ggpubr::get_palette("jco", length(unique(data[[group.col]])))
    names(group.colors) <- unique(data[[group.col]])
  }
  if (is.null(sample.colors)) {
    sample.colors <- ggpubr::get_palette("npg", length(unique(data[[sample.col]])))
    names(sample.colors) <- unique(data[[sample.col]])
  }
  
  # Main plot
  if (plot.type == "barplot") {
    p <- ggplot(data, aes_string(x = group.col, y = "freq", fill = group.col)) +
      geom_bar(stat = "summary", fun = "mean",
               color = if (show.contour) "black" else NA,
               linewidth = 0.2, alpha = 0.8) +
      geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
      geom_jitter(aes_string(fill = sample.col),
                  size = 1.5, shape = 21, stroke = 0.3, alpha = 0.8,
                  position = position_jitterdodge(jitter.width = 0.2))
    
  } else if (plot.type == "boxplot") {
    p <- ggplot(data, aes_string(x = group.col, y = "freq", fill = group.col)) +
      geom_boxplot(outlier.shape = NA, width = 0.5, alpha = 0.8,
                   color = if (show.contour) "black" else NA, linewidth = 0.2) +
      geom_jitter(aes_string(fill = sample.col),
                  size = 1.5, shape = 21, stroke = 0.3, alpha = 0.8,
                  position = position_jitterdodge(jitter.width = 0.2))
    
  } else stop("Invalid plot.type. Choose 'barplot' or 'boxplot'.")
  
  # Factor ordering
  data[[group.col]] <- factor(data[[group.col]], levels = unique(data[[group.col]]))
  data[[sample.col]] <- factor(data[[sample.col]], levels = unique(data[[sample.col]]))
  
  # Statistical comparisons
  if (show.pval) {
    if (multi.pval) {
      p <- p + stat_compare_means(
        comparisons = combn(levels(data[[group.col]]), 2, simplify = FALSE),
        size = label.size, bracket.nudge.y = 0.5
      ) +
        stat_compare_means(
          size = label.size, label = "p.format",
          vjust = -5, hjust = -0.5, tip.length = 0, step.increase = 0.5
        )
    } else {
      p <- p + stat_compare_means(
        size = label.size, label = "p.format",
        vjust = -2, hjust = -0.5, tip.length = 0, step.increase = 0.5
      )
    }
  }
  
  # Theme and aesthetics
  p <- p +
    plot_theme(theme = theme, font.size = font.size, facet.background.show = facet.bg,
               x.angle = x.angle, legend.title = legend.title,
               panel.background.fill = bg.color, axis.title.x.show = FALSE,...) +
    labs(x = x.title, y = y.title, fill = legend.title, title = plot.title) +
    guides(fill = guide_legend(ncol = legend.ncol)) +
    scale_fill_manual(values = group.colors) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.3))) +
    facet_wrap(~ cluster, scales = "free_y", ncol = ncol) +
    theme(strip.text = element_text(face = "bold", size = font.size))
  
  if (!legend) p <- p & NoLegend()
  
  return(p)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Counts or Proportions by Group
#'
#' This function generates a ggplot2 bar, point, or box plot showing counts or
#' proportions of a variable (y) across groups (x). It supports Seurat objects
#' (uses `meta.data`), custom color palettes, stacking, coordinate flipping, and facetting.
#'
#' @param data Data frame or Seurat object (if Seurat, uses meta.data)
#' @param x Grouping variable (bare name)
#' @param y Identity variable (bare name)
#' @param plot.type Plot type: "bar", "point", or "box" (default "count")
#' @param prop Logical; if TRUE, plot proportions instead of counts
#' @param prop.multi Logical; compute proportions per group for multiple facets
#' @param stack Logical; stack bars (for bar plot) instead of dodging
#' @param coord.flip Logical; flip x and y axes
#' @param colors Vector of colors; if NULL, defaults to hue palette or RColorBrewer
#' @param use.brewer Logical; use RColorBrewer palette
#' @param brew.pal Brewer palette name (default "Set1")
#' @param raster Logical; not implemented (reserved)
#' @param theme ggplot2 theme type (default "classic")
#' @param font.size Base font size for text
#' @param x.angle Rotation angle for x-axis labels
#' @param ncol Number of columns for facet_wrap (if prop.multi)
#' @param legend Logical; whether to show legend
#' @param legend.title Legend title; if NULL, uses y variable
#' @param legend.text.size Legend text size
#' @param legend.position Legend position: "right", "bottom", etc.
#' @param legend.ncol Number of columns for legend
#' @param x.title Custom x-axis title
#' @param y.title Custom y-axis title
#' @param x.lab Logical; show x-axis labels
#' @param xy.lab Logical; show both x and y axis labels
#' @param show.contour Logical; add black border around bars (bar plot)
#'
#' @return ggplot object
#' @examples
#' \dontrun{
#' plot_props(df, x = dominance.bin, y = cluster, plot.type = "bar", prop = TRUE)
#' plot_props(sub, x = cell_group, y = dominance_bin, prop.multi = TRUE)
#' }
#' @export
plot_props <- function(
    data,
    x, y,
    plot.type = "bar",
    prop = FALSE,
    prop.multi = FALSE,
    percent.stack = FALSE,
    stack = FALSE,
    coord.flip = FALSE,
    x.reverse = FALSE,
    y.reverse = FALSE,
    colors = NULL,
    use.brewer = FALSE,
    brew.pal = "Set1",
    raster = FALSE,
    theme = "classic",
    font.size = 8,
    x.angle = 90,
    ncol = NULL,
    legend = TRUE,
    legend.title = NULL,
    legend.text.size = 8,
    legend.position = "right",
    legend.ncol = 1,
    x.title = NULL,
    y.title = NULL,
    x.lab = TRUE,
    xy.lab = TRUE,
    show.contour = TRUE,
    add.pval = FALSE,
    pval.test = "chisq",
    pval.size = 3,
    ...
) {
  require(ggplot2)
  require(dplyr)
  require(RColorBrewer)
  
  # Handle Seurat
  if (inherits(data, "Seurat")) data <- data@meta.data
  
  x_var <- rlang::enquo(x)
  y_var <- rlang::enquo(y)
  
  # Count table
  stat <- data %>%
    dplyr::select(!!x_var, !!y_var) %>%
    dplyr::rename(.group = !!x_var, .ident = !!y_var) %>%
    dplyr::group_by(.group, .ident) %>%
    dplyr::summarise(.n = n(), .groups = "drop")
  
  # proportions (per x-group)
  if (prop || prop.multi || percent.stack) {
    stat <- stat %>%
      dplyr::group_by(.group) %>%
      dplyr::mutate(.value = .n / sum(.n) * 100) %>%
      dplyr::ungroup()
  } else {
    stat$.value <- stat$.n
  }
  
  # reverse x-axis
  if (x.reverse) {
    stat$.group <- factor(stat$.group, levels = rev(sort(unique(stat$.group))))
  } else {
    stat$.group <- factor(stat$.group, levels = sort(unique(stat$.group)))
  }
  
  stat$.ident <- factor(stat$.ident)
  
  # colors
  n.colors <- length(unique(stat$.ident))
  if (is.null(colors)) {
    if (use.brewer) {
      colors <- colorRampPalette(brewer.pal(min(9, n.colors), brew.pal))(n.colors)
    } else {
      colors <- scales::hue_pal()(n.colors)
    }
  }
  
  # Build main plot
  p <- ggplot(stat, aes(x = .group, y = .value, fill = .ident))
  
  # stacked or dodged bars
  if (plot.type == "bar") {
    p <- p + geom_bar(
      stat = "identity",
      position = if (stack || percent.stack) "stack" else "dodge",
      color = if (show.contour) "black" else NA,
      linewidth = 0.2
    )
  }
  
  # point/box optional
  if (plot.type == "point") p <- p + geom_point(size = 2)
  if (plot.type == "box") p <- p + geom_boxplot()
  
  # percent stacked bar â†’ fix y-scale to 100%
  if (percent.stack) {
    p <- p + scale_y_continuous(limits = c(0,100), expand = expansion(mult = c(0, 0.05)))
    y.title <- "Percent (%)"
  }
  
  # prop.multi facet mode
  if (prop.multi) {
    p <- p +
      facet_wrap(~.ident, scales = "free_y", ncol = ncol) +
      scale_y_continuous(labels = function(x) paste0(x, "%"))
  }
  
  # axis reversing
  if (coord.flip) p <- p + coord_flip()
  if (y.reverse && !percent.stack && !prop.multi) p <- p + scale_y_reverse()
  
  # labels + theme
  p <- p +
    scale_fill_manual(values = colors) +
    plot_theme(theme = theme, font.size = font.size, x.angle = x.angle, x.lab = x.lab, xy.lab = xy.lab, ...) +
    labs(
      x = if (!is.null(x.title)) x.title else rlang::as_name(x_var),
      y = if (!is.null(y.title)) y.title else if (prop || prop.multi || percent.stack) "Percent (%)" else "Count",
      fill = if (!is.null(legend.title)) legend.title else rlang::as_name(y_var)
    ) +
    theme(
      legend.title = element_text(size = legend.text.size),
      legend.text = element_text(size = legend.text.size),
      legend.position = if (legend) legend.position else "none"
    ) +
    guides(fill = guide_legend(ncol = legend.ncol))
  
  # ADD P-VALUES
  if (add.pval) {
    pval.df <- stat %>%
      tidyr::pivot_wider(names_from = .ident, values_from = .n, values_fill = 0) %>%
      dplyr::rowwise() %>%
      mutate(
        pval =
          if (pval.test == "chisq")
            chisq.test(c_across(!.group))$p.value
        else if (pval.test == "fisher")
          fisher.test(matrix(c_across(!.group), nrow = 1))$p.value
        else NA_real_
      ) %>%
      ungroup() %>%
      mutate(
        label = paste0("p=", signif(pval, 2)),
        y.position = max(stat$.value) * 1.05
      )
    
    p <- p +
      geom_text(
        data = pval.df,
        aes(x = .group, y = y.position, label = label),
        inherit.aes = FALSE,
        size = pval.size
      )
  }
  
  return(p)
}


#' Pseudobulk Proportion Plot (Bar/Box) with LMM or KW Tests
#'
#' @description
#' Creates bar or box plots of pseudobulk proportions for multiple cell types,
#' optionally performing statistical testing using Linear Mixed Models (LMM)
#' or Kruskal-Wallis (KW) when LMM is not feasible.
#'
#' @param input A data frame or seurat object.
#' @param donor.col Column name identifying donors.
#' @param stage.col Column name identifying biological stages or groups.
#' @param cell.col Column name specifying cell type.
#' @param prop.col Column name containing proportions.
#' @param plot.type `"bar"` or `"box"`.
#' @param min.lmm Minimum donors required per stage for LMM (default 3).
#' @param facet.by Column used for facetting (default `"cell"`).
#' @param cell.order Optional vector specifying the display order of cell types.
#' @param x.angle Angle of x-axis text.
#' @param font.size Base font size.
#' @param palette Brewer palette if manual colors not provided.
#' @param donor.cols Named vector of donor-specific colors.
#' @param stage.cols Named vector of stage-specific colors.
#' @param show.p Logical: show p-values (default TRUE).
#' @param theme.style `"classic"`, `"minimal"`, `"bw"`, etc.
#' @param facet.bg Logical: show facet background.
#' @param title Plot title.
#' @param x.lab X-axis label.
#' @param y.lab Y-axis label.
#' @param leg.pos `"right"`, `"bottom"`, etc.
#' @param pt.size Size of jitter points.
#' @param ncol Number of facet columns.
#' @param ... Extra arguments passed to theme.
#'
#' @return A list containing:
#' \describe{
#'   \item{plot}{A ggplot object.}
#'   \item{stats}{A data frame of p-values and test type per cell type.}
#' }
#'
#' @examples
#' \dontrun{
#' pb_prop_plot(
#'     input = pb.data,
#'     donor.col = "donor",
#'     stage.col = "stage",
#'     cell.col  = "cell",
#'     prop.col  = "prop",
#'     stage.cols = c(Early="#1f77b4", Late="#ff7f0e"),
#'     plot.type = "bar"
#' )
#' }
#'
#' @export
#' 
pb_prop_plot <- function(
    input,
    donor.col = "sample",
    stage.col = "PCW",
    cell.col  = "ann2",
    prop.col  = NULL,
    plot.type = c("bar", "box"),
    min.lmm   = 3,
    facet.by  = "cell",
    cell.order = NULL,
    x.angle = 45,
    font.size = 10,
    palette = "Set3",
    donor.cols = NULL,
    stage.cols = NULL,
    show.p = TRUE,
    theme.style = "classic",
    facet.bg = TRUE,
    title = NULL,
    x.lab = NULL,
    y.lab = "Proportion",
    leg.pos = "right",
    pt.size = 2,
    ncol = NULL,
    ...
) {
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(lme4)
  
  plot.type <- match.arg(plot.type)
  
  # --- 1. If Seurat object, compute pseudobulk proportions ---
  if (inherits(input, "Seurat")) {
    meta <- input@meta.data %>% as.data.frame()
    
    meta <- meta %>%
      mutate(
        donor = .data[[donor.col]],
        stage = .data[[stage.col]],
        cell  = .data[[cell.col]]
      )
    
    pb_df <- meta %>%
      group_by(donor, stage, cell) %>%
      summarise(n_cells = n(), .groups = "drop") %>%
      group_by(donor, stage) %>%
      mutate(prop = n_cells / sum(n_cells)) %>%
      ungroup()
    
  } else {
    pb_df <- input %>%
      dplyr::rename(
        donor = all_of(donor.col),
        stage = all_of(stage.col),
        cell  = all_of(cell.col)
      )
    
    if (!is.null(prop.col)) {
      pb_df <- pb_df %>% dplyr::rename(prop = all_of(prop.col))
    } else if (!"prop" %in% colnames(pb_df)) {
      stop("prop.col must be provided or 'prop' column must exist in data frame")
    }
  }
  
  df <- pb_df
  
  # --- 2. Apply cell order ---
  if (!is.null(cell.order)) {
    cell.order <- intersect(cell.order, unique(df$cell))
    df$cell <- factor(df$cell, levels = cell.order)
  } else {
    df$cell <- factor(df$cell)
  }
  
  # --- 3. Count donors per cell/stage ---
  donor.n <- df %>%
    group_by(cell, stage) %>%
    summarise(n.donor = n_distinct(donor), .groups = "drop")
  
  # --- 4. LMM or Kruskal-Wallis statistics ---
  stats <- data.frame(cell = character(),
                      method = character(),
                      p.value = numeric())
  
  for(ct in unique(df$cell)) {
    tmp <- df %>% filter(cell == ct)
    n.ds <- donor.n %>% filter(cell == ct) %>% pull(n.donor)
    
    if (all(n.ds >= min.lmm)) {
      fit <- try(lmer(prop ~ stage + (1|donor), data = tmp), silent = TRUE)
      if (!inherits(fit, "try-error")) {
        pval <- try(anova(fit)$`Pr(>F)`[1], silent = TRUE)
        if (inherits(pval, "try-error")) pval <- NA
        stats <- rbind(stats, data.frame(cell = ct, method = "LMM", p.value = pval))
      } else {
        stats <- rbind(stats, data.frame(cell = ct, method = "LMM", p.value = NA))
      }
    } else if (length(unique(tmp$stage)) > 1) {
      kw <- kruskal.test(prop ~ stage, data = tmp)
      stats <- rbind(stats, data.frame(cell = ct, method = "KW", p.value = kw$p.value))
    } else {
      stats <- rbind(stats, data.frame(cell = ct, method = NA, p.value = NA))
    }
  }
  
  # --- 5. Prepare p-value annotation ---
  annot <- if (show.p) {
    stats %>% mutate(label = ifelse(is.na(p.value), "", paste0("p=", signif(p.value, 2))))
  } else NULL
  
  # --- 6. Plot ---
  fill.scale <- if (!is.null(stage.cols)) scale_fill_manual(values = stage.cols) else scale_fill_brewer(palette = palette)
  
  if (plot.type == "bar") {
    p <- ggplot(df, aes(x = stage, y = prop, fill = stage)) +
      stat_summary(fun = "mean", geom = "bar", color = "black", linewidth = 0.2) +
      geom_jitter(aes(color = donor), shape = 21, color = "black", size = pt.size, width = 0.1, alpha = 0.8)
  } else {
    p <- ggplot(df, aes(x = stage, y = prop, fill = stage)) +
      geom_boxplot(alpha = 0.5) +
      geom_jitter(aes(color = donor), shape = 21, color = "black", size = pt.size, width = 0.1, alpha = 0.8)
  }
  
  if (!is.null(donor.cols)) p <- p + scale_color_manual(values = donor.cols)
  
  p <- p +
    fill.scale +
    facet_wrap(as.formula(paste("~", facet.by)), scales = "free_y", ncol = ncol) +
    plot_theme(theme = theme.style, font.size = font.size, x.angle = x.angle,
               leg.pos = leg.pos, facet.bg = facet.bg, leg.size = font.size, ...) +
    labs(title = title, x = x.lab, y = y.lab)
  
  # --- 7. Add p-values ---
  if (show.p && !is.null(annot)) {
    df.annot <- df %>%
      dplyr::group_by(cell) %>%
      dplyr::summarise(ypos = max(prop, na.rm = TRUE), .groups = "drop") %>%
      dplyr::left_join(annot, by = "cell")
    
    p <- p + geom_text(data = df.annot, aes(x = 2, y = ypos * 1.05, label = label), inherit.aes = FALSE)
  }
  
  list(plot = p, stats = stats)
}





# plot_props_v4.1 ----------------------------------------------------------
plot_props_v4 <- function(
    data,
    x,                       # grouping variable (factor or character) - e.g. "ann_level_2"
    y,                       # identity / category variable - e.g. "Phase"
    plot.type = c("bar","point","box"),
    prop = FALSE,            # show proportions (counts -> %)
    prop.multi = FALSE,      # break into facets per identity (.ident)
    percent_stacked = FALSE, # when TRUE, stacked bars display % (like position = "fill")
    stack = FALSE,           # stacked instead of dodge
    coord.flip = FALSE,
    x.reverse = FALSE,       # reverse x-level order
    colors = NULL,
    use.brewer = FALSE,      # use RColorBrewer palette when colors not provided
    brew.pal = "Set1",
    font.size = 8,
    x.angle = 90,
    theme = c("classic","minimal","bw"),
    raster = FALSE,
    legend = TRUE,
    legend.title = NULL,
    legend.position = "right",
    legend.ncol = 1,
    legend.text.size = 8,
    tests.within = c("none","chi.gof","fisher.gof","gtest"), # within-group tests
    tests.pairwise = c("none","fisher","chisq","prop.test","multinom"),    # pairwise tests
    correction = c("none","bonferroni","holm","BH","BY","hochberg","fdr"),
    pval.display = c("none","value","stars","both"),
    pval.cutoffs = c(0.001,0.01,0.05),   # thresholds for stars: ***,**,*
    show.ci = FALSE,
    ci.type = c("wilson","agresti","wald","bootstrap"),
    ci.conf.level = 0.95,
    arrows = FALSE,
    arrows.n = 3,
    arrows.type = c("absolute","relative","increase","decrease","both"),
    arrows.color = "red",
    arrows.size = 0.8,
    arrows.alpha = 0.8,
    digits = 3,
    add.count.labels = FALSE,
    count.label.size = 3,
    sig.label.size = 4,
    draw_pairwise_brackets = FALSE,   # NEW: draw pairwise brackets on the plot
    pairwise_topk = 3,                # NEW: top-k most significant pairwise comparisons to draw
    bracket_nudge = 0.03,             # NEW: vertical offset fraction for stacked bracket placement
    bracket_text_size = 3.5,          # NEW: bracket pvalue text size
    return_pairwise_heatmap = FALSE,  # NEW: return a heatmap of pairwise p-values
    pairwise_heatmap_plot = TRUE,     # if TRUE and pheatmap available produce a plot
    publication_style = FALSE,        # NEW: compact publication style (Nature-like)
    return_data = FALSE,
    verbose = TRUE,
    ...
) {

  # Arg setup + checks
  plot.type <- match.arg(plot.type)
  theme <- match.arg(theme)
  tests.within <- match.arg(tests.within)
  tests.pairwise <- match.arg(tests.pairwise)
  correction <- match.arg(correction)
  pval.display <- match.arg(pval.display)
  ci.type <- match.arg(ci.type)
  arrows.type <- match.arg(arrows.type)
  
  # load minimal packages
  if (!requireNamespace("ggplot2", quietly = TRUE)) stop("ggplot2 required")
  if (!requireNamespace("dplyr", quietly = TRUE)) stop("dplyr required")
  if (!requireNamespace("rlang", quietly = TRUE)) stop("rlang required")
  if (!requireNamespace("tibble", quietly = TRUE)) install.packages("tibble")
  if (!requireNamespace("tidyr", quietly = TRUE)) install.packages("tidyr")
  
  # optional packages
  has_binom <- requireNamespace("binom", quietly = TRUE)
  has_ggsignif <- requireNamespace("ggsignif", quietly = TRUE)
  has_pheatmap <- requireNamespace("pheatmap", quietly = TRUE)
  has_nnet <- requireNamespace("nnet", quietly = TRUE)
  has_DescTools <- requireNamespace("DescTools", quietly = TRUE)
  
  # Accept Seurat objects
  is_seurat <- inherits(data, "Seurat")
  if (is_seurat) {
    if (verbose) message("Detected Seurat object â€” using object@meta.data")
    data <- as.data.frame(data@meta.data)
  } else {
    data <- as.data.frame(data)
  }
  
  # Tidy input vars
  xq <- rlang::enquo(x)
  yq <- rlang::enquo(y)
  xname <- rlang::as_name(xq)
  yname <- rlang::as_name(yq)
  
  if (!(xname %in% colnames(data))) stop(paste0("x column '", xname, "' not found"))
  if (!(yname %in% colnames(data))) stop(paste0("y column '", yname, "' not found"))
  
  data[[xname]] <- as.character(data[[xname]])
  data[[yname]] <- as.character(data[[yname]])
  
  # preserve original ordering when factor present
  if (is.factor(data[[xname]])) x_levels <- levels(data[[xname]]) else x_levels <- unique(data[[xname]])
  if (is.factor(data[[yname]])) y_levels <- levels(data[[yname]]) else y_levels <- unique(data[[yname]])
  
  if (x.reverse) x_levels <- rev(x_levels)
  data[[xname]] <- factor(data[[xname]], levels = x_levels)
  data[[yname]] <- factor(data[[yname]], levels = y_levels)
  
  # Compute counts / proportions
  library(dplyr)
  stat <- data %>%
    dplyr::group_by(.grp = .data[[xname]], .id = .data[[yname]]) %>%
    dplyr::summarise(.n = dplyr::n(), .groups = "drop") %>%
    dplyr::rename(.group = .grp, .ident = .id)
  
  # Add zero rows for missing combos
  all_combos <- expand.grid(.group = levels(data[[xname]]), .ident = levels(data[[yname]]), stringsAsFactors = FALSE)
  stat <- dplyr::right_join(all_combos, stat, by = c(".group", ".ident"))
  stat$.n[is.na(stat$.n)] <- 0
  
  totals <- stat %>% dplyr::group_by(.group) %>% dplyr::summarise(.tot = sum(.n), .groups = "drop")
  stat <- dplyr::left_join(stat, totals, by = ".group")
  
  if (prop || prop.multi || percent_stacked) {
    stat <- stat %>% dplyr::mutate(.value = ifelse(.tot==0, 0, .n / .tot * 100))
  } else {
    stat <- stat %>% dplyr::mutate(.value = .n)
  }
  
  # default palette
  if (is.null(colors)) {
    if (use.brewer) {
      pal_base <- RColorBrewer::brewer.pal(max(3, min(8, length(unique(stat$.ident)))), brew.pal)
      colors <- grDevices::colorRampPalette(pal_base)(length(unique(stat$.ident)))
      names(colors) <- unique(stat$.ident)
    } else {
      colors <- scales::hue_pal()(length(unique(stat$.ident)))
      names(colors) <- unique(stat$.ident)
    }
  } else {
    if (is.null(names(colors))) names(colors) <- unique(stat$.ident)
  }
  
  # Statistical tests
  p_to_stars <- function(p, cutoffs = pval.cutoffs) {
    ifelse(is.na(p), NA_character_,
           ifelse(p < cutoffs[1], "***",
                  ifelse(p < cutoffs[2], "**",
                         ifelse(p < cutoffs[3], "*", "ns"))))
  }
  
  # Within-group (goodness of fit) tests
  within_res <- NULL
  if (tests.within != "none") {
    within_list <- lapply(levels(stat$.group), function(g) {
      sub <- stat %>% dplyr::filter(.group == g)
      counts <- sub$.n
      test_name <- NA_character_; pval <- NA_real_
      if (tests.within == "chi.gof") {
        expect_p <- rep(1/length(counts), length(counts))
        t <- tryCatch(chisq.test(counts, p = expect_p), error = function(e) NULL)
        test_name <- "chi.gof"
        pval <- if (!is.null(t)) t$p.value else NA_real_
      } else if (tests.within == "gtest" && has_DescTools) {
        t <- tryCatch(DescTools::GTest(counts), error = function(e) NULL)
        test_name <- "gtest"
        pval <- if (!is.null(t)) t$p.value else NA_real_
      }
      data.frame(group = g, test = test_name, p.value = pval, stringsAsFactors = FALSE)
    })
    within_res <- dplyr::bind_rows(within_list)
    if (correction != "none") within_res$p.adj <- p.adjust(within_res$p.value, method = correction)
    within_res$stars <- p_to_stars(within_res$p.value)
  }
  
  # Pairwise comparisons per identity (.ident)
  pairwise_res <- NULL
  if (tests.pairwise != "none") {
    grps <- levels(stat$.group)
    combos <- t(combn(grps, 2))
    all_pairs <- list()
    for (ident in levels(stat$.ident)) {
      sub <- stat %>% dplyr::filter(.ident == ident)
      for (r in seq_len(nrow(combos))) {
        g1 <- combos[r,1]; g2 <- combos[r,2]
        c1 <- sub %>% dplyr::filter(.group==g1) %>% dplyr::pull(.n)
        c2 <- sub %>% dplyr::filter(.group==g2) %>% dplyr::pull(.n)
        t1 <- sub %>% dplyr::filter(.group==g1) %>% dplyr::pull(.tot) %>% unique()
        t2 <- sub %>% dplyr::filter(.group==g2) %>% dplyr::pull(.tot) %>% unique()
        pval <- NA_real_
        if (tests.pairwise == "fisher") {
          mat <- matrix(c(c1, t1 - c1, c2, t2 - c2), nrow = 2)
          t <- tryCatch(fisher.test(mat), error = function(e) NULL)
          pval <- if (!is.null(t)) t$p.value else NA_real_
        } else if (tests.pairwise == "chisq") {
          mat <- matrix(c(c1, t1 - c1, c2, t2 - c2), nrow = 2)
          t <- tryCatch(chisq.test(mat), error = function(e) NULL)
          pval <- if (!is.null(t)) t$p.value else NA_real_
        } else if (tests.pairwise == "prop.test") {
          t <- tryCatch(prop.test(c(c1,c2), c(t1,t2)), error = function(e) NULL)
          pval <- if (!is.null(t)) t$p.value else NA_real_
        } else if (tests.pairwise == "multinom" && has_nnet) {
          # fallback to prop.test per pair if multinom not requested or available
          t <- tryCatch(prop.test(c(c1,c2), c(t1,t2)), error = function(e) NULL)
          pval <- if (!is.null(t)) t$p.value else NA_real_
        }
        all_pairs[[length(all_pairs)+1]] <- data.frame(ident=ident, group1=g1, group2=g2, x1=c1, n1=t1, x2=c2, n2=t2, p.value=pval, stringsAsFactors = FALSE)
      }
    }
    pairwise_res <- dplyr::bind_rows(all_pairs)
    if (correction != "none") pairwise_res$p.adj <- p.adjust(pairwise_res$p.value, method = correction)
    pairwise_res$stars <- p_to_stars(pairwise_res$p.value)
  }
  
  # Confidence intervals (optional)
  ci_res <- NULL
  if (show.ci) {
    ci_list <- lapply(seq_len(nrow(stat)), function(i) {
      r <- stat[i, ]
      xcount <- r$.n; ntotal <- r$.tot
      if (ntotal == 0) {
        lo <- hi <- 0
      } else if (ci.type %in% c("wilson","agresti") && has_binom) {
        method <- ifelse(ci.type=="wilson","wilson","agresti-coull")
        b <- binom::binom.confint(xcount, ntotal, conf.level = ci.conf.level, methods = method)
        lo <- b$lower; hi <- b$upper
      } else {
        pt <- tryCatch(prop.test(xcount, ntotal, conf.level = ci.conf.level), error = function(e) NULL)
        if (!is.null(pt)) { lo <- pt$conf.int[1]; hi <- pt$conf.int[2] } else { lo <- NA; hi <- NA }
      }
      data.frame(.group = r$.group, .ident = r$.ident, x = xcount, n = ntotal, prop = ifelse(ntotal==0, 0, xcount/ntotal*100), ci.lo = lo*100, ci.hi = hi*100, stringsAsFactors = FALSE)
    })
    ci_res <- dplyr::bind_rows(ci_list)
  }
  
  # Build ggplot
  library(ggplot2)
  plotdata <- stat
  
  posn <- if (stack || percent_stacked) "stack" else position_dodge(width = 0.9)
  if (prop.multi && plot.type == "bar") {
    plt <- ggplot(plotdata, aes(x = .group, y = .value, fill = .ident)) +
      geom_col(position = position_dodge(width = 0.9), color = "black", linewidth = 0.2) +
      facet_wrap(~ .ident, scales = "free_y", ncol = 1)
  } else {
    if (plot.type == "bar") {
      if (stack || percent_stacked) {
        plt <- ggplot(plotdata, aes(x = .group, y = .value, fill = .ident)) +
          geom_col(position = "stack", color = "black", linewidth = 0.2)
      } else {
        plt <- ggplot(plotdata, aes(x = .group, y = .value, fill = .ident)) +
          geom_col(position = position_dodge(width = 0.9), color = "black", linewidth = 0.2)
      }
    } else if (plot.type == "point") {
      plt <- ggplot(plotdata, aes(x = .group, y = .value, color = .ident)) +
        geom_point(position = position_dodge(width = 0.6), size = 1.8)
    } else if (plot.type == "box") {
      plt <- ggplot(plotdata, aes(x = .group, y = .value, fill = .ident)) +
        geom_boxplot(position = position_dodge(width = 0.9))
    }
  }
  
  if (plot.type %in% c("bar","box")) {
    plt <- plt + scale_fill_manual(values = colors, na.value = "grey70")
  } else {
    plt <- plt + scale_color_manual(values = colors, na.value = "grey70")
  }
  
  # add CI
  if (show.ci && !is.null(ci_res)) {
    pd_ci <- dplyr::left_join(plotdata, ci_res, by = c(".group", ".ident"))
    if (plot.type == "bar" && !stack) {
      plt <- plt + geom_errorbar(data = pd_ci, aes(x = .group, ymin = ci.lo, ymax = ci.hi, group = .ident),
                                 position = position_dodge(width = 0.9), width = 0.2, inherit.aes = FALSE)
    } else if (plot.type == "bar" && stack) {
      # skip errorbars for stacked (complex)
    } else {
      plt <- plt + geom_errorbar(data = pd_ci, aes(x = .group, ymin = ci.lo, ymax = ci.hi, group = .ident),
                                 position = position_dodge(width = 0.9), width = 0.2, inherit.aes = FALSE)
    }
  }
  
  # add counts labels
  if (add.count.labels && !stack) {
    plt <- plt + geom_text(data = plotdata, aes(x = .group, y = .value, label = .n, group = .ident),
                           position = position_dodge(width = 0.9), vjust = -0.4, size = count.label.size, inherit.aes = TRUE)
  } else if (add.count.labels && stack) {
    totlab <- plotdata %>% dplyr::group_by(.group) %>% dplyr::summarise(total = sum(.n))
    plt <- plt + geom_text(data = totlab, aes(x = .group, y = total, label = total), inherit.aes = FALSE, vjust = -0.4, size = count.label.size)
  }
  
  # theme
  if (publication_style) {
    plt <- plt + theme_classic(base_size = font.size) +
      theme(legend.position = legend.position, axis.text = element_text(size = font.size - 1))
  } else {
    if (theme == "classic") plt <- plt + theme_classic(base_size = font.size)
    if (theme == "minimal") plt <- plt + theme_minimal(base_size = font.size)
    if (theme == "bw") plt <- plt + theme_bw(base_size = font.size)
    plt <- plt + theme(legend.position = legend.position, legend.text = element_text(size = legend.text.size))
  }
  
  plt <- plt + labs(x = xname, y = ifelse(prop || prop.multi || percent_stacked, "Percent (%)", "Count"), fill = legend.title, color = legend.title)
  plt <- plt + theme(axis.text.x = element_text(angle = x.angle, hjust = ifelse(x.angle==0, 0.5, 1)))
  
  if (coord.flip) plt <- plt + coord_flip()
  if (!legend) plt <- plt + theme(legend.position = "none")
  
  # Draw pairwise brackets (NEW)
  if (draw_pairwise_brackets && !is.null(pairwise_res) && nrow(pairwise_res)>0) {
    # pick top-k smallest p-values across all idents
    prs <- pairwise_res %>% dplyr::filter(!is.na(p.value)) %>% dplyr::arrange(p.value)
    if (nrow(prs) > 0) {
      topk <- head(prs, pairwise_topk)
      # compute x positions
      xlevels <- levels(data[[xname]])
      # helper to convert group -> x numeric
      to_x <- function(g) which(xlevels == g)
      # create bracket dataframe
      brdf <- topk %>% dplyr::mutate(xmin = sapply(group1, to_x), xmax = sapply(group2, to_x))
      # compute y position: max value of the two groups + small nudge
      maxvals <- plotdata %>% dplyr::group_by(.group) %>% dplyr::summarise(mx = max(.value, na.rm = TRUE))
      brdf <- brdf %>% dplyr::left_join(maxvals, by = c("group1" = ".group")) %>% dplyr::rename(y1 = mx) %>%
        dplyr::left_join(maxvals, by = c("group2" = ".group")) %>% dplyr::rename(y2 = mx)
      brdf <- brdf %>% dplyr::mutate(ypos = pmax(y1, y2) + bracket_nudge * pmax(1, max(plotdata$.value, na.rm = 1)))
      brdf$label <- if (pval.display == "value") sprintf("p=%.*g", digits, brdf$p.value) else if (pval.display == "stars") p_to_stars(brdf$p.value) else if (pval.display == "both") paste0(p_to_stars(brdf$p.value), " (", sprintf("%.*g", digits, brdf$p.value), ")") else ""
      # if ggsignif available, make mapping to group names and call geom_signif
      if (has_ggsignif) {
        # geom_signif expects x positions as factor labels: we will call via annotate segments+text for reliability
        for (i in seq_len(nrow(brdf))) {
          r <- brdf[i,]
          # draw segment and text
          plt <- plt + annotate("segment", x = as.numeric(r$xmin), xend = as.numeric(r$xmax), y = r$ypos, yend = r$ypos, colour = "black") +
            annotate("text", x = mean(c(r$xmin, r$xmax)), y = r$ypos + (0.02 * max(plotdata$.value, na.rm = 1)), label = r$label, size = bracket_text_size)
        }
      } else {
        # fallback: draw segments + text
        for (i in seq_len(nrow(brdf))) {
          r <- brdf[i,]
          plt <- plt + annotate("segment", x = as.numeric(r$xmin), xend = as.numeric(r$xmax), y = r$ypos, yend = r$ypos, colour = "black") +
            annotate("text", x = mean(c(r$xmin, r$xmax)), y = r$ypos + (0.02 * max(plotdata$.value, na.rm = 1)), label = r$label, size = bracket_text_size)
        }
      }
    }
  }
  
  # Pairwise p-value heatmap (optional)
  pairwise_heatmap <- NULL
  if (return_pairwise_heatmap && !is.null(pairwise_res) && nrow(pairwise_res)>0) {
    # Build matrix of min p-values across idents for each pair (group1,group2)
    grps <- levels(stat$.group)
    m <- matrix(NA_real_, nrow = length(grps), ncol = length(grps), dimnames = list(grps,grps))
    for (i in seq_len(nrow(pairwise_res))) {
      r <- pairwise_res[i,]
      g1 <- r$group1; g2 <- r$group2; pv <- r$p.value
      m[g1,g2] <- pv; m[g2,g1] <- pv
    }
    diag(m) <- NA
    pairwise_heatmap <- as.data.frame(m)
    if (pairwise_heatmap_plot && has_pheatmap) {
      mat <- m
      mat[is.na(mat)] <- 1
      # log transform for visualization: -log10(p)
      heat <- -log10(mat)
      heat[is.infinite(heat)] <- max(heat[is.finite(heat)], na.rm = TRUE)
      # pheatmap
      pheatmap::pheatmap(heat, cluster_rows = FALSE, cluster_cols = FALSE,
                         main = "Pairwise -log10(p)", display_numbers = round(mat, digits))
    }
  }
  
  # Output
  out <- list(plot = plt, data = plotdata, totals = totals, within_tests = within_res,
              pairwise_tests = pairwise_res, ci = ci_res, pairwise_heatmap = pairwise_heatmap)
  
  if (return_data) return(out) else return(plt)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Percentage of Cells Expressing Specific Genes
#'
#' This function calculates and visualizes the proportion of cells expressing
#' one or more genes across metadata-defined groups in a Seurat object.
#'
#' @param object A Seurat object.
#' @param gene Character vector of gene names to evaluate.
#' @param group.by Metadata column to group cells by. Default: "celltype".
#' @param unique.color.all Logical; if TRUE, use a single color for all groups. Default: TRUE.
#' @param set.unique.color.all Color for all groups when `unique.color.all = TRUE`. Default: "#2986cc".
#' @param custom.unique.colors Optional vector of custom colors for groups.
#' @param x.angle X-axis label rotation in degrees. Default: 90.
#' @param min.expr Minimum expression threshold to consider a gene "expressed". Default: 0.1.
#' @param show.empty Logical; if TRUE, show genes with zero expression as blank plots. Default: FALSE.
#' @param ncol Number of columns when arranging multiple plots. Default: NULL (automatic).
#' @param return.plot Logical; if TRUE, returns plots; otherwise returns only data. Default: TRUE.
#' @param theme Theme type passed to \code{plot_theme()}. Default: "classic".
#'
#' @return If `return.plot = TRUE`, a list with elements:
#'   \describe{
#'     \item{plot}{Patchwork plot combining individual gene plots.}
#'     \item{data}{Data frame with proportions per gene and group.}
#'   }
#'   Otherwise, only the data frame.
#'
#' @export
get_cells_expressing_gene <- function(object,
                                      gene,
                                      group.by = "celltype", 
                                      unique.color.all = TRUE,
                                      set.unique.color.all = "#2986cc",
                                      custom.unique.colors = NULL,
                                      x.angle = 90,  
                                      min.expr = 0.1,
                                      show.empty = FALSE,
                                      ncol = NULL,
                                      return.plot = TRUE,
                                      theme = "classic",
                                      ...) {
  
  if (!requireNamespace("RColorBrewer", quietly = TRUE)) {
    stop("RColorBrewer package needed. Please install it.")
  }
  
  if (!all(gene %in% rownames(object))) {
    missing.genes <- gene[!gene %in% rownames(object)]
    stop(paste("Gene(s) not found:", paste(missing.genes, collapse = ", ")))
  }
  
  if (!(group.by %in% colnames(object@meta.data))) {
    stop(paste(group.by, "not found in object metadata."))
  }
  
  all.prop.data <- list()
  gene.plots <- list()
  
  for (g in gene) {
    gene.data <- FetchData(object, vars = g)
    gene.data[[group.by]] <- object@meta.data[[group.by]]
    gene.data$cell <- rownames(gene.data)
    
    gene.data <- gene.data %>%
      dplyr::mutate(is.expressed = ifelse(.data[[g]] > min.expr, 1, 0))
    
    total.cells <- gene.data %>%
      dplyr::group_by(.data[[group.by]]) %>%
      dplyr::summarize(total = dplyr::n(), .groups = "drop")
    
    expressing.cells <- gene.data %>%
      dplyr::filter(is.expressed == 1) %>%
      dplyr::group_by(.data[[group.by]]) %>%
      dplyr::summarize(expressing = dplyr::n(), .groups = "drop")
    
    proportions <- total.cells %>%
      dplyr::left_join(expressing.cells, by = group.by) %>%
      dplyr::mutate(expressing = ifelse(is.na(expressing), 0, expressing),
                    proportion = (expressing / total) * 100,
                    gene = g)
    
    all.prop.data[[g]] <- proportions
    
    if (all(proportions$proportion == 0) & !show.empty) next
    
    num.groups <- dplyr::n_distinct(proportions[[group.by]])
    
    fill.colors <- if (unique.color.all) {
      rep(set.unique.color.all, num.groups)
    } else if (!is.null(custom.unique.colors)) {
      custom.unique.colors
    } else {
      colorRampPalette(RColorBrewer::brewer.pal(12, "Set1"))(num.groups)
    }
    
    plt <- ggplot(proportions, aes_string(x = group.by, y = "proportion", fill = group.by)) +
      geom_bar(stat = "identity", color = "black", linewidth = 0.2) +
      labs(title = g, y = paste0("Cells expressing ", g, " (%)")) +
      scale_fill_manual(values = fill.colors) +
      plot_theme(theme = theme, legend.position = "none",...) 
    
    gene.plots[[g]] <- plt
  }
  
  result.data <- dplyr::bind_rows(all.prop.data)
  
  if (return.plot && length(gene.plots) > 0) {
    plot.grid <- patchwork::wrap_plots(gene.plots, ncol = ncol)
    return(list(plot = plot.grid, data = result.data))
  } else {
    return(result.data)
  }
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Summarize and Plot Gene Set Expression
#'
#' @description
#' Computes the total expression of a given gene set across cells, optionally summarized 
#' in pseudobulk per group. Produces a bar plot showing summed expression per group/fill variable.
#'
#' @param object A Seurat object containing gene expression data.
#' @param gene.list A character vector of gene names to include.
#' @param group.var Metadata column to group cells by (x-axis). Default: "ann2".
#' @param fill.var Metadata column to use for fill colors (stacked or dodged bars). Default: "PCW".
#' @param sample.var Metadata column for pseudobulk (optional). If provided, aggregates by sample.
#' @param pseudobulk.mode Character. If "sum", sums expression per sample; if "cpm", normalizes counts per million. Default: NULL (no pseudobulk).
#' @param group.levels Optional factor levels for group.var.
#' @param fill.levels Optional factor levels for fill.var.
#' @param fill.colors Optional named vector of colors for fill levels.
#' @param expr.threshold Minimum expression to retain a gene. Default: 0.
#' @param theme ggplot2 theme. Default: "minimal".
#' @param leg.pos Legend position. Default: "right".
#' @param leg.dir Legend direction. Default: "vertical".
#' @param leg.ttl Legend title. Default: "".
#' @param font.size Base font size. Default: 10.
#' @param x.angle X-axis text angle. Default: 45.
#' @param x.lab X-axis label. Default: NULL.
#' @param y.lab Y-axis label. Default: "Total transcripts".
#' @param plot.ttl Plot title. Default: NULL.
#' @param flip Logical. If TRUE, flips coordinates. Default: FALSE.
#' @param return.data Logical. If TRUE, returns a list with plot and summarized data. Default: FALSE.
#' @param ... Additional arguments passed to `plot_theme`.
#'
#' @return A ggplot object (or list with plot and summarized data if `return.data = TRUE`).
#' @export
#'
#' @examples
#' genesum(
#'   object = seurat_obj,
#'   gene.list = c("OR1", "OR2"),
#'   group.var = "ann2",
#'   fill.var = "stage",
#'   sample.var = "sample",
#'   pseudobulk.mode = "cpm",
#'   plot.ttl = "OR pseudobulk across development"
#' )
#' 
genesum <- function(
    object,
    gene.list,
    group.var = "ann2",
    fill.var = "stage",
    sample.var = NULL,
    mode = c("cell", "pseudobulk"),
    pb.norm = c("none", "cpm"),
    group.levels = NULL,
    fill.levels = NULL,
    fill.colors = NULL,
    expr.threshold = 0,
    theme = "classic",
    leg.pos = "right",
    leg.dir = "vertical",
    leg.ttl = "",
    font.size = 10,
    x.angle = 45,
    x.lab = NULL,
    y.lab = "Total transcripts",
    plot.ttl = NULL,
    flip = FALSE,
    return.data = FALSE,
    ...
) {
  require(ggplot2)
  require(dplyr)
  require(reshape2)
  
  mode <- match.arg(mode)
  pb.norm <- match.arg(pb.norm)
  
  ## 1. Filter genes
  valid.genes <- intersect(
    gene.list,
    rownames(object[["RNA"]]@layers$counts)
  )
  filt <- subset(object, features = valid.genes)
  
  expr.mat <- as.matrix(filt[["RNA"]]@layers$counts)
  keep.genes <- rowSums(expr.mat) > expr.threshold
  filt <- subset(filt, features = names(keep.genes[keep.genes]))
  
  ## 2. Expression + metadata
  expr.df <- as.data.frame(t(filt[["RNA"]]@layers$counts))
  
  meta.vars <- c(group.var, fill.var)
  if (mode == "pseudobulk") {
    if (is.null(sample.var))
      stop("sample.var must be provided for pseudobulk mode")
    meta.vars <- c(meta.vars, sample.var)
  }
  
  meta.df <- filt@meta.data[, meta.vars, drop = FALSE]
  df <- cbind(meta.df, expr.df)
  
  ## 3. Long format
  melted <- reshape2::melt(
    df,
    id.vars = meta.vars,
    variable.name = "gene",
    value.name = "count"
  )
  
  ## 4. Aggregation
  if (mode == "cell") {
    summary.df <- melted %>%
      group_by(.data[[group.var]], .data[[fill.var]]) %>%
      summarise(total.expr = sum(count), .groups = "drop")
  }
  
  if (mode == "pseudobulk") {
    # 4a. Pseudobulk per sample
    pb <- melted %>%
      group_by(.data[[sample.var]],
               .data[[group.var]],
               .data[[fill.var]]) %>%
      summarise(total.expr = sum(count), .groups = "drop")
    
    # 4b. Optional CPM
    if (pb.norm == "cpm") {
      libsize <- pb %>%
        group_by(.data[[sample.var]]) %>%
        summarise(lib = sum(total.expr), .groups = "drop")
      
      pb <- pb %>%
        left_join(libsize, by = sample.var) %>%
        mutate(total.expr = total.expr / lib * 1e6)
    }
    
    # 4c. Aggregate across samples
    summary.df <- pb %>%
      group_by(.data[[group.var]], .data[[fill.var]]) %>%
      summarise(total.expr = mean(total.expr), .groups = "drop")
  }
  
  ## 5. Factors
  if (!is.null(group.levels))
    summary.df[[group.var]] <- factor(summary.df[[group.var]], levels = group.levels)
  
  if (!is.null(fill.levels))
    summary.df[[fill.var]] <- factor(summary.df[[fill.var]], levels = fill.levels)
  
  ## 6. Plot
  p <- ggplot(
    summary.df,
    aes(x = .data[[group.var]], y = total.expr, fill = .data[[fill.var]])
  ) +
    geom_bar(stat = "identity", position = position_dodge(),
             color = "black", linewidth = 0.2) +
    labs(x = x.lab, y = y.lab, title = plot.ttl) +
    plot_theme(
      theme = theme,
      leg.pos = leg.pos,
      leg.dir = leg.dir,
      font.size = font.size,
      x.angle = x.angle,
      leg.size = font.size,
      ...
    ) +
    guides(fill = guide_legend(title = leg.ttl))
  
  if (!is.null(fill.colors))
    p <- p + scale_fill_manual(values = fill.colors)
  
  if (flip)
    p <- p + coord_flip()
  
  if (return.data)
    return(list(plot = p, data = summary.df))
  
  return(p)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Stage-Adjusted Residuals for Cell Type Proportions
#'
#' This function calculates the stage-adjusted residuals of cell type proportions per sample,
#' optionally applies a log transformation, and plots them by group (e.g., sex).
#' It supports significance testing (Wilcoxon or Kruskal-Wallis) and adding effect sizes (requires custom function).
#'
#' @param data A \code{Seurat} object or a data frame containing metadata.
#' @param ident.col Character. Column name indicating cell type (default: "ann_level_2").
#' @param sample.col Character. Column name indicating sample/donor (default: "sample").
#' @param group.col Character. Column name for grouping variable (default: "group").
#' @param stage_col Character. Column name representing developmental stage (default: "PCW").
#' @param plot.title Character. Plot title (default: NULL).
#' @param colors Named vector of colors for groups. If NULL, default palette is used.
#' @param x.title Character. X-axis title (default: NULL).
#' @param y.title Character. Y-axis title (default: "Stage-adjusted residual").
#' @param x.lab Logical. Show x-axis labels? (default: TRUE)
#' @param y.lab Logical. Show y-axis labels? (default: TRUE)
#' @param font.size Numeric. Base font size for plot (default: 14).
#' @param theme Character. Theme for plot, passed to \code{plot_theme()} (default: "classic").
#' @param leg.pos Character or numeric vector. Legend position (default: "right").
#' @param log.transform Logical. Apply log transformation to residuals? (default: FALSE)
#' @param log.method Character. Log method: "log10" or "ln" (default: "log10").
#' @param log.offset Numeric. Small value added before log to avoid -Inf (default: 1).
#' @param effect.size Logical. If TRUE, effect size will be computed (requires custom function).
#' @param ... Additional arguments passed to \code{plot_theme()}.
#'
#' @return A \code{ggplot2} object showing residuals per cell type with optional significance labels.
#'
#' @details
#' - Computes donor-level fractions of each cell type.
#' - Fits a linear model of fraction ~ stage per cell type and extracts residuals.
#' - Optionally applies log transformation.
#' - Performs group comparisons: Wilcoxon test for 2 groups, Kruskal-Wallis for >2 groups.
#' - Adds significance labels for FDR < 0.05.
#'
#' @examples
#' \dontrun{
#' p <- plot_group_residuals(
#'   data = obj,
#'   ident.col = "ann_level_2",
#'   sample.col = "sample",
#'   group.col = "sex",
#'   stage_col = "PCW",
#'   log.transform = TRUE,
#'   log.method = "log10",
#'   colors = c("Female"="#b15928","Male"="#6a3d9a"),
#'   font.size = 8,
#'   theme = "classic"
#' )
#' p
#' }
#'
#' @export
plot_group_residuals <- function(
    data, ident.col="ann_level_2", sample.col="sample", group.col="group",
    stage_col="PCW", plot.title=NULL, colors=NULL, x.title=NULL,
    y.title="Stage-adjusted residual", x.lab=TRUE, y.lab=TRUE,
    font.size=14, theme="classic", leg.pos="right",
    log.transform=FALSE, log.method=c("log10","ln"), log.offset=1,
    effect.size=FALSE, ...
){
  log.method <- match.arg(log.method)
  if(inherits(data,"Seurat")) data <- data@meta.data
  
  donors <- data %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(c(sample.col, group.col, stage_col, ident.col)))) %>%
    dplyr::summarise(n=dplyr::n(), .groups="drop") %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(sample.col))) %>%
    dplyr::mutate(frac=n/sum(n)*100) %>% dplyr::ungroup() %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(ident.col))) %>%
    dplyr::mutate(resid={
      valid <- !is.na(frac) & !is.na(.data[[stage_col]])
      r <- frac
      if(sum(valid)>2){
        m <- try(stats::lm(frac ~ as.numeric(as.character(.data[[stage_col]])),
                           data=dplyr::cur_data_all()[valid,]), silent=TRUE)
        if(!inherits(m,"try-error")) r[valid] <- stats::resid(m)
      }; r
    }) %>% dplyr::ungroup()
  
  if(log.transform){
    donors <- donors %>% dplyr::mutate(
      resid = dplyr::case_when(
        log.method=="log10" ~ log10(resid+log.offset),
        log.method=="ln" ~ log(resid+log.offset),
        TRUE ~ resid
      )
    )
    y.title <- paste0(y.title," (",ifelse(log.method=="log10","log10","ln"),")")
  }
  
  stats <- donors %>%
    dplyr::group_by(dplyr::across(dplyr::all_of(ident.col))) %>%
    tidyr::nest() %>%
    dplyr::mutate(test=purrr::map(data, ~{
      df <- .x; n.grp <- length(unique(df[[group.col]]))
      if(n.grp<2) return(tibble::tibble(stat=NA,p=NA))
      t <- if(n.grp==2) try(stats::wilcox.test(resid ~ .data[[group.col]],data=df),silent=TRUE)
      else try(stats::kruskal.test(resid ~ .data[[group.col]],data=df),silent=TRUE)
      if(inherits(t,"try-error")) tibble::tibble(stat=NA,p=NA) else broom::tidy(t)
    })) %>% dplyr::select(-data) %>% tidyr::unnest(test) %>%
    dplyr::mutate(FDR=stats::p.adjust(p,method="BH")) %>% dplyr::arrange(FDR)
  
  mean.diff <- donors %>% dplyr::group_by(dplyr::across(dplyr::all_of(c(ident.col,group.col)))) %>%
    dplyr::summarise(mean_resid=mean(resid,na.rm=TRUE),.groups="drop") %>%
    tidyr::pivot_wider(names_from=group.col, values_from=mean_resid)
  stats <- dplyr::left_join(stats, mean.diff, by=ident.col)
  plot.df <- dplyr::left_join(donors, stats, by=ident.col)
  
  labels <- plot.df %>% dplyr::group_by(dplyr::across(dplyr::all_of(ident.col))) %>%
    dplyr::summarise(y=max(resid,na.rm=TRUE)*1.05) %>%
    dplyr::left_join(stats %>% dplyr::filter(FDR<0.05) %>% dplyr::mutate(label=paste0("* FDR=",signif(FDR,2))),
                     by=ident.col)
  
  if(is.null(colors)){ grps <- unique(plot.df[[group.col]]); colors <- stats::setNames(scales::hue_pal()(length(grps)), grps) }
  
  # plt <- ggplot(plot.df, aes_string(x=ident.col,y="resid",fill=group.col)) +
  #   geom_boxplot(outlier.shape=NA,width=1,alpha=1,color="black",linewidth = 0.2) +
  #   geom_jitter(aes_string(color=group.col),width=0.15,size=1,alpha=1) +
  #   scale_fill_manual(values=colors) +
  #   scale_color_manual(values=colors) +
  #   labs(x=x.title,y=y.title,title=plot.title) +
  #   plot_theme(theme=theme,x.lab=x.lab,y.lab=y.lab,legend.position=leg.pos,font.size=font.size,...)
  
  plt <- ggplot(plot.df, aes_string(x=ident.col, y="resid", fill=group.col)) +
    geom_boxplot(
      outlier.shape=NA,
      width=0.8,
      alpha=1,
      color="black",
      linewidth=0.2,
      position = position_dodge(width=0.8)
    ) +
    geom_jitter(
      aes_string(color=group.col),
      position = position_jitterdodge(
        dodge.width = 0.8,
        jitter.width = 0.15,
        jitter.height = 0
      ),
      size = 1,
      alpha = 1
    ) +
    stat_summary(
      aes_string(group = group.col),
      fun = mean,
      fun.min = function(x) mean(x) - sd(x)/sqrt(length(x)),
      fun.max = function(x) mean(x) + sd(x)/sqrt(length(x)),
      geom = "errorbar",
      width = 0.2,
      color = "gray20",
      size = 0.5,
      position = position_dodge(width=0.8)
    ) +
    stat_summary(
      aes_string(group = group.col),
      fun = mean,
      geom = "point",
      color = "gray20",
      size = 1,
      position = position_dodge(width=0.8)
    ) +
    scale_fill_manual(values=colors) +
    scale_color_manual(values=colors) +
    labs(x = x.title, y = y.title, title = plot.title) +
    plot_theme(theme = theme, x.lab = x.lab, y.lab = y.lab, legend.position = leg.pos, font.size = font.size, ...)
  
  if(effect.size) warning("Effect size calculation requires `effect_size_proportions()`.")
  
  if(nrow(labels)>0) plt <- plt + geom_text(
    data=labels, aes_string(x=ident.col,y="y",label="label"),
    inherit.aes=FALSE, size=3, vjust=0, color="black") + coord_cartesian(clip="off")
  
  return(plt)
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'#' Highlight selected clusters on UMAP/tSNE plots
#'
#' @description
#' Plots a dimensionality reduction (UMAP/tSNE) and highlights specified clusters.
#' Can highlight clusters individually (mode = "single") or
#' simultaneously (mode = "multi").
#'
#' @param object Seurat object
#' @param cluster.names Character vector of clusters to highlight.
#'   If NULL, all identities are used.
#' @param group.by Metadata column used for cluster identity.
#' @param reduction Dimensional reduction name (default: "umap")
#' @param mode "single" = one plot per cluster, "multi" = combined highlight
#' @param ncol Number of columns for "single" mode layout
#' @param custom.colors Named vector of colors corresponding to highlighted clusters.
#' @param pt.size Baseline point size for non-highlight cells
#' @param highlight.size Point size for highlighted cells
#' @param fontsize Base text size
#' @param show.cell.counts Logical, adds cell numbers to legend
#' @param background.color Color for all non-highlighted cells
#' @param label Whether to label clusters (multi mode only)
#' @param label.size Cluster label font size
#' @param plot.title Custom plot title (NULL removes the default title)
#' @param no_axes Remove axes (recommended for UMAP/tSNE)
#' @param legend.position Legend position ("none" by default)
#' @param item.size Size of legend point markers
#' @param legend.ncol Number of legend columns
#' @param legend.title Title for legend (NULL hides it)
#' @param legend.text.size Legend text size
#' @param ... Additional arguments to DimPlot
#'
#' @return A ggplot2 or patchwork object
#' @export
#'
highlight_clusters <- function(
    object,
    cluster.names = NULL,
    group.by = "seurat_clusters",
    reduction = "umap",
    mode = c("single", "multi"),
    ncol = 3,
    custom.colors = NULL,
    pt.size = 0.1,
    highlight.size = 0.5,
    fontsize = 10,
    show.cell.counts = FALSE,
    background.color = "lightgray",
    label = FALSE,
    label.size = 4,
    plot.title = NULL,
    no_axes = TRUE,
    legend.position = "none",
    item.size = 3,
    legend.ncol = 1,
    legend.title = NULL,
    legend.text.size = 10,
    ...
) {
  require(Seurat)
  require(ggplot2)
  require(patchwork)
  require(dplyr)
  require(ggrepel)
  
  mode <- match.arg(mode)
  object <- SetIdent(object, value = group.by)
  clusters <- levels(Idents(object))
  
  if (is.null(cluster.names)) cluster.names <- clusters
  valid.clusters <- cluster.names[cluster.names %in% clusters]
  if (length(valid.clusters) == 0)
    stop("No valid clusters found in metadata.")
  
  if (is.null(custom.colors)) {
    pal <- custom_palette(n = length(valid.clusters))
    names(pal) <- valid.clusters
    custom.colors <- pal
  }
  
  
  # MODE = SINGLE
  if (mode == "single") {
    plots <- lapply(valid.clusters, function(cl) {
      cells <- WhichCells(object, idents = cl)
      cnt <- length(cells)
      title <- if (show.cell.counts) paste0(cl, " (n=", cnt, ")") else cl
      
      p <- suppressWarnings({
        suppressMessages({DimPlot(
          object,
          reduction = reduction,
          group.by = group.by,
          cells.highlight = cells,
          cols = background.color,
          cols.highlight = custom.colors[cl],
          pt.size = pt.size,
          sizes.highlight = highlight.size,
          order = TRUE,
          ...
        ) })})+
        ggtitle(title) +
        theme(
          plot.title = element_text(hjust = 0.5, size = fontsize, face = "bold"),
          text = element_text(size = fontsize)
        ) &
        NoLegend()
      
      if (no_axes) p <- p & NoAxes()
      return(p)
    })
    
    return(wrap_plots(plots, ncol = ncol))
  }
  
  # MODE = MULTI
  cells.to.highlight <- CellsByIdentities(object, idents = valid.clusters)
  
  plt <- suppressWarnings({
    suppressMessages({DimPlot(
      object,
      reduction = reduction,
      group.by = group.by,
      cells.highlight = cells.to.highlight,
      cols.highlight = custom.colors[valid.clusters],
      cols = background.color,
      pt.size = pt.size,
      sizes.highlight = highlight.size,
      order = TRUE,
      ...
    ) }) })
  
  # Ensure consistent color scale ONLY once
  plt <- plt +
    scale_color_manual(
      values = custom.colors[valid.clusters],
      breaks = valid.clusters,
      na.value = background.color
    ) +
    guides(
      color = guide_legend(
        override.aes = list(
          size = item.size,
          shape = 21,
          fill = unname(custom.colors[valid.clusters]),
          stroke = 0.3,
          color = "black"
        ),
        ncol = legend.ncol,
        title = legend.title
      )
    ) #+
    # theme(
    #   legend.position = legend.position,
    #   legend.text = element_text(size = legend.text.size),
    #   text = element_text(size = fontsize)
    # )
    
    plt <- plt +
    theme(
      legend.position = legend.position,
      legend.text = element_text(size = legend.text.size),
      legend.title = element_text(size = legend.text.size, face = "bold"),
      
      legend.spacing.y = unit(1, "pt"),
      legend.key.height = unit(4, "pt"),
      legend.key.width  = unit(4, "pt"),
      legend.margin = margin(1, 1, 1, 1),
      
      text = element_text(size = fontsize)
    )
  
  # Plot title rule 
  if (is.null(plot.title)) {
    plt <- plt + theme(plot.title = element_blank())
  } else {
    plt <- plt + ggtitle(plot.title) +
      theme(plot.title = element_text(
        hjust = 0.5, size = fontsize + 2, face = "bold"
      ))
  }
  
  # Labels on highlighted clusters
  if (label) {
    emb <- Embeddings(object[[reduction]])
    df <- data.frame(emb, cluster = Idents(object)) %>%
      filter(cluster %in% valid.clusters) %>%
      group_by(cluster) %>%
      summarise(x = median(umap_1), y = median(umap_2), .groups = "drop")
    
    plt <- plt +
      geom_text_repel(
        data = df,
        aes(x = x, y = y, label = cluster),
        size = label.size,
        fontface = "bold"
      )
  }
  
  # Cell count labels in legend
  if (show.cell.counts) {
    cell.nb <- table(Idents(object))
    lbl <- paste0(valid.clusters, " (",cell.nb[valid.clusters], ")")
    names(lbl) <- valid.clusters
    
    plt <- plt +
      scale_color_manual(
        values = custom.colors[valid.clusters],
        breaks = valid.clusters,
        labels = lbl,
        na.value = background.color
      )
  }
  
  if (no_axes) plt <- plt & NoAxes()
  return(plt)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Feature Plot Wrapper for Seurat Objects
#'
#' This function creates feature plots for one or multiple features in a Seurat object.
#' It preserves the default Seurat behavior while providing options for custom color palettes,
#' viridis palettes, NA color, legend merging, orientation, and size.
#'
#' @param seurat_object A Seurat object.
#' @param features A character vector of feature names to plot (genes or metadata columns).
#' @param colors_use Optional vector of colors to use for the gradient. Must have at least 2 colors.
#' @param theme_color Color theme to use if `colors_use` is NULL. Default is "Reds".
#' @param use_viridis Logical, whether to use a viridis palette. Default is FALSE.
#' @param viridis_option Character, the viridis palette option to use ("viridis", "magma", "plasma", "inferno", "cividis", etc.). Default is "viridis".
#' @param reverse_colors Logical, whether to reverse the color scale. Default is FALSE.
#' @param na_color Color to use for NA values. Default is "lightgray".
#' @param na_cutoff Numeric cutoff for minimal expression to show. Default is 1e-9.
#' @param order Logical, whether to order points by expression. Default is FALSE.
#' @param pt.size Numeric, size of points. Default automatically adjusts to number of cells.
#' @param base_size Numeric, base font size for plot title and axes. Default is 14.
#' @param legend.text.size Numeric, font size for legend text. Default is 12.
#' @param reduction Character, which dimensional reduction to use. Default uses Seurat's `DefaultDimReduc()`.
#' @param raster Logical, whether to rasterize the plot for speed. Default TRUE for >2e5 cells.
#' @param raster.dpi Numeric vector of length 2, resolution for rasterized plots. Default c(512,512).
#' @param split.by Character, metadata column to split plots by.
#' @param ncol Number of columns when combining plots. Default NULL.
#' @param layer Character, which assay slot to use. Default is "data".
#' @param label Logical, whether to add cluster labels. Default FALSE.
#' @param no_axes Logical, whether to remove axes. Default FALSE.
#' @param blend Logical, whether to create a blend plot for exactly 2 features. Default FALSE.
#' @param merge_legend Logical, whether to merge legends for multiple plots. Default FALSE.
#' @param merge.leg.pos Position of merged legend ("right", "bottom", etc.). Default "right".
#' @param legend.orientation Legend orientation: "vertical" or "horizontal". Default "vertical".
#' @param legend.width Unit object specifying width of legend bar. Default `unit(1,"mm")`.
#' @param legend.height Unit object specifying height of legend bar. Default `unit(8,"mm")`.
#' @param ... Additional arguments passed to Seurat's `FeaturePlot()`.
#'
#' @return A ggplot object (or patchwork) containing the feature plots.
#' @export
#'
#' @examples
#' \dontrun{
#' cellfeat(
#'   seurat_object = obj,
#'   features = c("TEX15","TP63"),
#'   merge_legend = TRUE,
#'   merge.leg.pos = "bottom",
#'   legend.orientation = "horizontal",
#'   legend.width = unit(10,"mm"),
#'   legend.height = unit(1,"mm"),
#'   theme_color = "Reds",
#'   no_axes = TRUE,
#'   ncol = 1,
#'   na_cutoff = 0.5
#' )
#' }
cellfeat <- function(
    seurat_object,
    features,
    colors_use = NULL,
    theme_color = "Reds",
    use_viridis = FALSE,
    viridis_option = "viridis",
    reverse_colors = FALSE,
    na_color = "lightgray",
    na_cutoff = 1e-9,
    order = FALSE,
    pt.size = NULL,
    base_size = 10,
    legend.text.size = 10,
    reduction = NULL,
    raster = NULL,
    raster.dpi = c(512,512),
    split.by = NULL,
    ncol = NULL,
    layer = "data",
    label = FALSE,
    no_axes = FALSE,
    blend = FALSE,
    merge_legend = FALSE,
    merge.leg.pos = "right",
    legend.orientation = c("vertical","horizontal"),
    legend.title.pos = "left",
    legend.title.angle = 90,
    legend.width = grid::unit(0.6,"mm"),
    legend.height = grid::unit(6,"mm"),
    ...
){
  require(Seurat)
  require(ggplot2)
  require(patchwork)
  require(RColorBrewer)
  
  reduction <- reduction %||% DefaultDimReduc(seurat_object)
  legend.orientation <- match.arg(legend.orientation)
  
  if (merge_legend) {
    if (merge.leg.pos %in% c("right","left")) {
      legend.orientation <- "vertical"
      legend.title.pos   <- "left"
      legend.title.angle <- 90
    } else if (merge.leg.pos %in% c("bottom","top")) {
      legend.orientation <- "horizontal"
      legend.title.pos   <- "top"
      legend.title.angle <- 0
    }
  }
  
  # Handle colors
  if(!is.null(colors_use)){
    if(length(colors_use)<2) stop("colors_use must contain at least 2 colors")
    if(reverse_colors) colors_use <- rev(colors_use)
  } else if (isTRUE(use_viridis)){
    require(viridis)
    colors_use <- viridis::viridis(9, option = viridis_option)
    if(reverse_colors) colors_use <- rev(colors_use)
  } else {
    custom_palettes <- list(
      hotspot = c("navy", "lightblue", "yellow", "orange", "red"),
      five_rainbow = c("blue", "green", "yellow", "orange", "red")
    )
    if(theme_color %in% names(custom_palettes)){
      colors_use <- custom_palettes[[theme_color]]
    } else {
      colors_use <- RColorBrewer::brewer.pal(9, theme_color)
    }
    if(reverse_colors) colors_use <- rev(colors_use)
  }
  
  # Auto pt.size
  if(is.null(pt.size)){
    n_cells <- ncol(seurat_object)
    raster <- raster %||% (n_cells > 2e5)
    pt.size <- if(raster) 1 else min(1583 / n_cells,1)
  }
  
  # Check features
  available_features <- c(rownames(seurat_object), colnames(seurat_object@meta.data))
  all_found_features <- intersect(features, available_features)
  if(length(all_found_features)==0) stop("No features found in Seurat object")
  
  # Blend plot (leave as before but make consistent legend if requested) 
  if(blend){
    if(length(all_found_features)!=2) stop("blend=TRUE requires exactly 2 features")
    p <- FeaturePlot(
      seurat_object,
      features = all_found_features,
      blend = TRUE,
      pt.size = pt.size,
      reduction = reduction,
      raster = raster,
      raster.dpi = raster.dpi,
      label = label,
      ...
    )
    if(no_axes) p <- p & NoAxes()
    if(merge_legend){
      p <- p + plot_layout(guides="collect") & theme(legend.position = "none")
    }
    return(p)
  }
  
  # Compute global scale limits across all features 
  # Use Seurat::FetchData to fetch values (works for both assay features and meta.data)
  # If FetchData fails for features (rare), fallback to GetAssayData.
  fetch_ok <- TRUE
  vals_df <- tryCatch({
    Seurat::FetchData(seurat_object, vars = all_found_features, slot = layer)
  }, error = function(e){
    fetch_ok <<- FALSE
    NULL
  })
  if(!fetch_ok){
    # fallback: try to get from default assay
    assay_name <- Seurat::DefaultAssay(seurat_object)
    vals_df <- do.call(cbind, lapply(all_found_features, function(f){
      mm <- tryCatch(Seurat::GetAssayData(seurat_object[[assay_name]], slot = layer)[f, , drop = TRUE],
                     error = function(e) rep(NA, ncol(seurat_object)))
      return(mm)
    }))
    colnames(vals_df) <- all_found_features
    vals_df <- as.data.frame(vals_df)
  }
  
  # compute global max (ignore NA). Lower bound will be na_cutoff
  global_max <- suppressWarnings(max(as.matrix(vals_df), na.rm = TRUE))
  if(is.infinite(global_max) || is.na(global_max)) global_max <- NA_real_
  color_limits <- c(na_cutoff, global_max)
  # If all values are <= na_cutoff or NA, set an upper slightly > na_cutoff to allow scale to draw
  if(!is.na(global_max) && global_max <= na_cutoff){
    color_limits[2] <- na_cutoff + 1e-6
  }
  
  # Name for the legend (consistent across plots)
  legend_name <- "Expression level"
  
  # Create single plots (combine = FALSE) and enforce identical scale 
  plot_list <- lapply(all_found_features, function(feat){
    gglist <- FeaturePlot(
      seurat_object,
      features = feat,
      pt.size = pt.size,
      order = order,
      reduction = reduction,
      raster = raster,
      raster.dpi = raster.dpi,
      label = label,
      combine = FALSE,   # crucial: return a list of ggplot objects
      ...
    )
    # Extract ggplot object safely (FeaturePlot returns a list)
    p <- gglist[[1]]
    
    # Apply identical color scale and theme (use + to add ggplot scale)
    p <- p +
      scale_color_gradientn(
        colours = colors_use,
        limits = color_limits,
        na.value = na_color,
        name = legend_name,
        guide = guide_colorbar(
          title = legend_name,
          title.theme = element_text(angle = legend.title.angle, vjust = 0.5),
          title.position = legend.title.pos,
          direction = legend.orientation,
          barwidth = as.numeric(legend.width),
          barheight = as.numeric(legend.height),
          frame.colour = "black",size=0.2,
          ticks.colour = "black"
        )
      ) +
      theme(
        plot.title = element_text(hjust = 0.5, size = base_size, face = "bold.italic"),
        legend.title = element_text(size = legend.text.size, face = "bold", hjust = 0.5),
        legend.text = element_text(size = legend.text.size)
      )
    
    if(no_axes) p <- p & NoAxes()
    return(p)
  })
  
  # Combine plots and merge legend 
  plt <- wrap_plots(plot_list, ncol = ncol)
  
  if(merge_legend){
    # Use plot_layout(guides="collect") at patchwork level
    # then set overall legend position
    plt <- plt + plot_layout(guides = "collect") &
      theme(legend.position = merge.leg.pos, legend.justification = "center")
  }
  
  return(plt)
}


#' Generate Expression Heatmaps for Stage or Celltypeâ€“Sample Modes
#'
#' This function generates heatmaps from a Seurat object using either:
#' 1) **Stage mode**: aggregated expression across developmental or experimental stages; or  
#' 2) **Celltypeâ€“Sample mode**: paired annotation of cell types and samples.  
#'
#' It supports z-score normalization, gene filtering, palette selection, optional
#' flipping of heatmaps, row/column label position control, and integrated saving
#' through a custom `save.fig()` function.
#'
#' @param object A Seurat object.
#' @param features Character vector of gene names to include.
#' @param mode Plot mode: `"stage"` (default) or `"celltype-sample"`.
#' @param assay Assay to use (default `"RNA"`).
#' @param slot Data slot to extract (default `"counts"`).
#' @param zlim Numeric vector defining z-score color scaling boundaries
#'   (default `c(-2, 0, 2)`).
#' @param fontsize Base font size for labels.
#' @param palette Color palette. Either `"viridis"` or manual colors.
#' @param manual.colors Colors used when `palette != "viridis"`.
#' @param flip.heatmap Logical. If TRUE, transpose the heatmap and switch label sides.
#' @param group.by Metadata column used for averaging in `"stage"` mode.
#' @param column.title Optional column title for the heatmap.
#' @param celltype.col Metadata column defining cell types (for `"celltype-sample"` mode).
#' @param sample.col Metadata column defining samples (for `"celltype-sample"` mode).
#' @param celltype.palette Named color vector for cell types.
#' @param sample.palette Named color vector for samples.
#' @param show.annotation.legend Logical; show annotation legends (default TRUE).
#' @param row.names.side Side for row names: `"left"` or `"right"` (default `"left"`).
#' @param column.names.side Side for column names: `"top"` or `"bottom"` (default `"top"`).
#' @param row.names.rot Rotation angle of row labels.
#' @param column.names.rot Rotation angle of column labels.
#' @param output.pdf File path to save heatmap as PDF. If NULL, no file is saved.
#' @param pdf.width PDF width (inches).
#' @param pdf.height PDF height (inches).
#' @param heatmap.legend.side Side for heatmap legend.
#' @param annotation.legend.side Side for annotation legend.
#'
#' @details  
#' The function uses Seurat's `AverageExpression()` to compute aggregated values,
#' applies per-gene z-scoring, and uses `ComplexHeatmap` for rendering.  
#'
#' If `flip.heatmap = TRUE`, the matrix is transposed and label sides are swapped
#' automatically to maintain readability.  
#'
#' If `output.pdf` is provided, the function saves the heatmap using the userâ€™s
#' custom `save.fig()` helper, ensuring directory creation and figure consistency.
#'
#' @return Invisibly returns the ComplexHeatmap object used for plotting.
#'
#' @examples
#' \dontrun{
#' expression_heatmap(
#'   object,
#'   features = c("GATA3", "SOX2"),
#'   mode = "stage",
#'   group.by = "PCW.group",
#'   output.pdf = "plots/stage.heatmap.pdf"
#' )
#' }
#'
#' @import Seurat
#' @import dplyr
#' @import ComplexHeatmap
#' @import viridis
#' @import circlize
#' @import stringr
#' @import grid
#'
#' @export

expression_heatmap <- function(
    object,
    features,
    mode = c("stage", "celltype-sample"),
    assay = "RNA",
    slot = "counts",
    zlim = c(-2, 0, 2),
    fontsize = 12,
    palette = "viridis",
    manual.colors = c("purple","black","yellow"),
    flip.heatmap = FALSE,
    group.by = "PCW_group",
    column.title = NULL,
    celltype.col = "ann_level_2",
    sample.col = "sample",
    celltype.palette = NULL,
    sample.palette = NULL,
    show.annotation.legend = TRUE,
    row.names.side = "left",
    column.names.side = "top",
    row.names.rot = 0,
    column.names.rot = 90,
    output.pdf = NULL,
    pdf.width = 8,
    pdf.height = 6,
    heatmap.legend.side = "right",
    annotation.legend.side = "right"
){
  require(Seurat)
  require(dplyr)
  require(ComplexHeatmap)
  require(viridis)
  require(circlize)
  require(stringr)
  require(grid)
  
  mode <- match.arg(mode)
  
  ## Filter genes
  genes <- intersect(features, rownames(object))
  if (length(genes) == 0) stop("None of the genes exist in Seurat object.")
  
  sub <- subset(object, features = genes)
  DefaultAssay(sub) <- assay
  
  ## MODE 1: STAGE HEATMAP
  if (mode == "stage") {
    
    avg <- AverageExpression(
      sub, group.by = group.by, assays = assay, slot = slot
    )[[assay]]
    
    ## Z-score
    avg <- avg[!rowSums(is.na(avg)), ]
    avg <- t(scale(t(avg)))
    avg[is.na(avg)] <- 0
    
    ## Row ordering
    avg <- avg[order(apply(avg, 1, which.max)), , drop = FALSE]
    
    ## Flip heatmap
    if (flip.heatmap) {
      avg <- t(avg)
      row.names.side <- ifelse(row.names.side == "left", "right", "left")
      column.names.side <- ifelse(column.names.side == "top", "bottom", "top")
    }
    
    ## Gene labels
    gene.labels <- as.expression(lapply(
      rownames(avg),
      function(x) bquote(italic(.(x)))
    ))
    
    ## Color function
    col.fun <- if (palette == "viridis") {
      colorRamp2(seq(zlim[1], zlim[3], length.out = 256), viridis(256))
    } else {
      colorRamp2(zlim, manual.colors)
    }
    
    ht <- Heatmap(
      avg,
      name = "Z-score",
      row_labels = gene.labels,
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      col = col.fun,
      border = TRUE,
      row_names_side = row.names.side,
      row_names_rot = row.names.rot,
      column_names_side = column.names.side,
      column_names_rot = column.names.rot,
      row_names_gp = gpar(fontsize = fontsize),
      column_names_gp = gpar(fontsize = fontsize),
      column_title = column.title,
      heatmap_legend_param = list(
        title = "Z-score",
        legend_direction = "vertical",
        title_position = "leftcenter-rot",
        title_gp = gpar(fontface = "bold"),
        border = "black"
      )
    )
  }
  
  ## MODE 2: CELLTYPE Ã— SAMPLE HEATMAP
  if (mode == "celltype-sample") {
    
    avg <- AverageExpression(
      sub, group.by = c(celltype.col, sample.col),
      assays = assay, slot = slot
    )[[assay]]
    
    ## Z-score
    avg <- t(scale(t(avg)))
    avg[is.na(avg)] <- 0
    avg <- avg[order(apply(avg, 1, which.max)), , drop = FALSE]
    
    ## Parse annotation
    col.parts <- str_split_fixed(colnames(avg), "_", 2)
    anno.df <- data.frame(
      CellTypes = col.parts[, 1],
      Samples = col.parts[, 2]
    )
    rownames(anno.df) <- colnames(avg)
    
    anno.df$CellTypes <- factor(
      anno.df$CellTypes,
      levels = levels(object[[celltype.col]][, 1])
    )
    anno.df$Samples <- factor(
      anno.df$Samples,
      levels = levels(object[[sample.col]][, 1])
    )
    
    ## Set palettes if missing
    if (is.null(celltype.palette)) {
      celltype.palette <- setNames(
        viridis(length(levels(anno.df$CellTypes))),
        levels(anno.df$CellTypes)
      )
    }
    if (is.null(sample.palette)) {
      sample.palette <- setNames(
        viridis(length(levels(anno.df$Samples))),
        levels(anno.df$Samples)
      )
    }
    
    ## Flip heatmap
    if (flip.heatmap) {
      avg <- t(avg)
      row.names.side <- ifelse(row.names.side == "left", "right", "left")
      column.names.side <- ifelse(column.names.side == "top", "bottom", "top")
    }
    
    ## Gene labels
    gene.labels <- as.expression(lapply(
      rownames(avg),
      function(x) bquote(italic(.(x)))
    ))
    
    col.fun <- colorRamp2(zlim, manual.colors)
    
    top.anno <- HeatmapAnnotation(
      df = anno.df,
      col = list(
        CellTypes = celltype.palette,
        Samples = sample.palette
      ),
      show_legend = show.annotation.legend,
      annotation_name_gp = gpar(fontsize = fontsize, fontface = "bold")
    )
    
    ht <- Heatmap(
      avg,
      name = "Z-score",
      top_annotation = top.anno,
      row_labels = gene.labels,
      cluster_rows = FALSE,
      cluster_columns = FALSE,
      col = col.fun,
      border = TRUE,
      row_names_side = row.names.side,
      row_names_rot = row.names.rot,
      column_names_rot = column.names.rot,
      column_names_side = column.names.side,
      show_column_names = TRUE,
      row_names_gp = gpar(fontsize = fontsize),
      heatmap_legend_param = list(
        title = "Z-score",
        legend_direction = "vertical",
        title_position = "leftcenter-rot",
        border = "black"
      )
    )
  }
  
  ## SAVE OUTPUT
  if (!is.null(output.pdf)) {
    
    out.dir <- dirname(output.pdf)
    if (!dir.exists(out.dir)) dir.create(out.dir, recursive = TRUE)
    
    ComplexHeatmap::draw(
      ht,
      heatmap_legend_side = heatmap.legend.side,
      annotation_legend_side = annotation.legend.side,
      merge_legend = TRUE
    )
    
    savefig(
      fig = ComplexHeatmap::draw(
        ht,
        heatmap_legend_side = heatmap.legend.side,
        annotation_legend_side = annotation.legend.side,
        merge_legend = TRUE
      ),
      filename = output.pdf,
      type = "heatmap",
      format = c("pdf", "png", "tiff"),
      width = pdf.width,
      height = pdf.height,
      dpi = 600
    )
    
    cat("Saved heatmap to:", output.pdf, "\n")
    
  } else {
    
    ComplexHeatmap::draw(
      ht,
      heatmap_legend_side = heatmap.legend.side,
      annotation_legend_side = annotation.legend.side,
      merge_legend = TRUE
    )
  }
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
plot_expression_heatmap <- function(
    seurat_obj,
    gene_list,
    celltype_col = "ann_level_2",
    sample_col = "sample",
    gene_colors = c("purple", "black", "yellow"),
    sample_colors = NULL,
    celltype_palette = NULL,
    show_annotation_legend = TRUE,
    zlim = c(-2, 0, 2),
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    font.size = 8,
    output_pdf = NULL,
    pdf_width = NULL,
    pdf_height = NULL
    ) {
      
      require(Seurat)
      require(ComplexHeatmap)
      require(dplyr)
      require(stringr)
      require(circlize)
      require(grid)
      
      # Filter only genes present in object
      genes <- intersect(gene_list, rownames(seurat_obj))
      sub <- subset(seurat_obj, features = genes)
      
      # Compute group-average expression
      avg_expr <- AverageExpression(
        sub,
        group.by = c(celltype_col, sample_col),
        assays = "RNA",
        slot = "counts"
      )$RNA
      
      # Normalize rows (Z-score)
      avg_expr <- avg_expr[!rowSums(is.na(avg_expr)), ]
      avg_expr <- t(scale(t(avg_expr)))
      avg_expr[is.na(avg_expr)] <- 0
      
      # Order genes by where they peak
      avg_expr <- avg_expr[order(apply(avg_expr, 1, which.max)), ]
      
      # Extract annotations from column names
      col_parts <- str_split_fixed(colnames(avg_expr), "_", 2)
      anno_df <- data.frame(
        CellTypes = col_parts[,1],
        Samples = col_parts[,2]
      )
      rownames(anno_df) <- colnames(avg_expr)
      
      # âœ… Order based on levels in Seurat object (generalized)
      anno_df$CellTypes <- factor(
        anno_df$CellTypes,
        levels = levels(seurat_obj[[celltype_col]][,1])
      )
      anno_df$Samples <- factor(
        anno_df$Samples,
        levels = levels(seurat_obj[[sample_col]][,1])
      )
      
      # âœ… Auto-generate color palettes if missing
      if (is.null(celltype_palette)) {
        unique_ct <- levels(anno_df$CellTypes)
        celltype_palette <- setNames(viridis::viridis(length(unique_ct)), unique_ct)
      }
      if (is.null(sample_colors)) {
        unique_Sample <- levels(anno_df$Samples)
        sample_colors <- setNames(viridis::viridis(length(unique_Sample)), unique_Sample)
      }
      
      # Build annotation
      top_anno <- HeatmapAnnotation(
        df = anno_df,
        col = list(
          CellTypes = celltype_palette,
          Samples = sample_colors
        ),
        annotation_name_side = "right",
        which = "column",
        show_legend = show_annotation_legend,
        annotation_legend_param = list(
          "CellTypes" = list(
            ncol = 1,
            border = "black",
            title_gp = gpar(fontface = "bold"),
            title_position = "leftcenter-rot",
            legend.direction = "vertical"
          ),
          "Samples" = list(
            border = "black",
            title_gp = gpar(fontface = "bold"),
            title_position = "leftcenter-rot",
            legend.direction = "vertical"
          )
        ),
        annotation_name_gp = gpar(fontsize = font.size, fontface = "bold") 
      )
      
      # Italic gene names
      gene_labels <- as.expression(lapply(
        rownames(avg_expr),
        function(x) bquote(italic(.(x)))
      ))
      
      # Create heatmap
      ht <- Heatmap(
        avg_expr,
        name = "Z-score",
        top_annotation = top_anno,
        row_labels = gene_labels,
        row_names_gp = gpar(fontsize = 10),
        show_column_names = FALSE,
        cluster_rows = cluster_rows,
        cluster_columns = cluster_columns,
        border = TRUE,
        col = colorRamp2(zlim, gene_colors),
        column_title_gp = gpar(fontsize = font.size+2, 
                               fontface="bold.italic"),
        heatmap_legend_param = list(
          title = "Z-score",
          legend.direction = "vertical",  
          title_position = "leftcenter-rot", 
          legend_width = unit(4, "cm"),
          title_position = "topcenter",
          title_gp = gpar(fontface = "bold"),
          border = 'black'
        )
      )
      
      if(!is.null(output_pdf)){
        pdf(output_pdf, width = pdf_width, height = pdf_height, useDingbats = FALSE)
        draw(ht, heatmap_legend_side = "right", 
             annotation_legend_side = "right",
             merge_legends = TRUE)
        dev.off()
      } else {
        draw(ht, heatmap_legend_side = "right",
             annotation_legend_side = "right",
             merge_legends = TRUE)
      }
    }



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Average Gene Expression Heatmap
#'
#' This function generates a heatmap of the average expression (z-scored) of a given list of genes 
#' across cell groups in a Seurat object.  
#' It uses `ComplexHeatmap` for flexible visualization and allows customization of titles, 
#' label sizes, rotation, and color palettes from `viridis`.
#'
#' @param seurat_obj Seurat object containing the RNA assay data.
#' @param gene_list Character vector of gene names to include in the heatmap.
#' @param group_by Character, name of the metadata column to group cells by 
#'   (default: `"ann_level_3"`).
#' @param assay Character, name of the assay to use (default: `"RNA"`).
#' @param slot Character, which data slot to use (`"counts"`, `"data"`, `"scale.data"`; default: `"counts"`).
#' @param column_title Character, title to display above the heatmap (default: `NULL`).
#' @param legend_title Character, title for the heatmap color legend (default: `"z-score"`).
#' @param zlim Numeric vector of length 3, specifying z-score limits for the color scale 
#'   (default: `c(-2, 0, 2)`).
#' @param fontsize Numeric, font size for row and column labels (default: `10`).
#' @param column_names_side Character, side where column names are shown (`"top"` or `"bottom"`, default: `"top"`).
#' @param column_names_rot Numeric, rotation angle for column labels in degrees (default: `90`).
#' @param color_palette Character, viridis palette name (`"magma"`, `"inferno"`, `"plasma"`, 
#'   `"viridis"`, `"cividis"`, `"rocket"`, `"mako"`, `"turbo"`; default: `"viridis"`).
#' @param color_direction Integer, direction of viridis scale (`1` for normal, `-1` for reversed, default: `1`).
#'
#' @details
#' The function:
#' 1. Filters genes to those present in the Seurat object.
#' 2. Computes average expression per group using `AverageExpression()`.
#' 3. Z-scores the expression values for comparability across genes.
#' 4. Orders genes by the group where they have the highest expression.
#' 5. Creates a heatmap with `ComplexHeatmap`.
#'
#' **Note:** The Seurat object should already contain normalized data if 
#' `slot = "data"` or `slot = "scale.data"` is used.
#'
#' @return A ComplexHeatmap object is drawn to the active graphics device.
#'
#' @import Seurat
#' @import ComplexHeatmap
#' @import circlize
#' @import viridis
#' @export
#'
#' @examples
#' \dontrun{
#' heatmap_avg_expression(
#'   seurat_obj = my_seurat,
#'   gene_list = c("GNRH1", "KISS1R"),
#'   group_by = "cell_type",
#'   column_title = "GnRH neuron markers",
#'   zlim = c(-2, 0, 2),
#'   color_palette = "magma"
#' )
#' }
heatmap_avg_expression <- function(
    seurat_obj,
    gene_list,
    group_by = "ann_level_3",
    assay = "RNA",
    slot = "counts",
    column_title = NULL,
    legend_title = "z-score",
    zlim = c(-2, 0, 2),
    fontsize = 12,
    column_names_side = "top",
    column_names_rot = 90,
    palette = "manual", # "manual" or "viridis"
    color_direction = 1,
    output_pdf = NULL,
    pdf_width = NULL,
    pdf_height = NULL
) {
  require(Seurat)
  require(ComplexHeatmap)
  require(circlize)
  require(viridis)
  
  # Step 1: Filter genes
  genes <- intersect(gene_list, rownames(seurat_obj[[assay]]))
  if (length(genes) == 0) {
    stop("None of the provided genes were found in the Seurat object for assay: ", assay)
  }
  
  # Step 2: Subset and preprocess
  seurat_sub <- subset(seurat_obj, features = genes)
  DefaultAssay(seurat_sub) <- assay
  
  # Step 3: Compute average expression
  avg <- AverageExpression(
    seurat_sub,
    group.by = group_by,
    features = genes,
    assays = assay,
    slot = slot
  )[[assay]]
  
  # Step 4: Z-score
  avg <- avg[!rowSums(is.na(avg)), ]
  avg <- t(apply(avg, 1, function(x) (x - mean(x)) / sd(x)))
  avg[is.na(avg)] <- 0
  
  # Step 5: Order genes by max expression
  gene_order <- order(apply(avg, 1, which.max))
  avg <- avg[gene_order, ]
  
  # Step 6: Transpose the matrix
  avg_flipped <- t(avg)
  
  # Step 7: Color scale from viridis
  # viridis_colors <- viridis(256, option = color_palette, direction = color_direction)
  # col_fun <- circlize::colorRamp2(
  #   zlim,
  #   viridis_colors[c(1, 128, 256)]
  # )
  
  # Step 8: Color scale
  if (palette == "viridis") {
    col_fun <- circlize::colorRamp2(
      seq(zlim[1], zlim[3], length.out = 256),
      viridis::viridis(256)
    )
  } else {
    col_fun <- circlize::colorRamp2(zlim, c("purple", "black", "yellow"))
  }
  
  # Step 8: Plot heatmap
  ht <- Heatmap(
    matrix = avg_flipped,
    name = legend_title,
    column_title = column_title,
    row_labels = colnames(avg),
    show_column_names = TRUE,
    show_row_names = TRUE,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    column_names_centered = FALSE,
    show_row_dend = FALSE,
    column_dend_reorder = FALSE,
    column_names_rot = column_names_rot,
    border = "black",
    col = col_fun,
    row_names_gp = gpar(fontsize = fontsize),
    column_names_gp = gpar(fontsize = fontsize, fontface = "plain"),
    column_names_side = column_names_side,
    heatmap_legend_param = list(
      title = legend_title,
      legend.direction = "vertical",  
      title_position = "leftcenter-rot", 
      legend.direction = "vertical",  
      title_position = "leftcenter-rot", 
      legend_width = unit(4, "cm"),
      title_position = "topcenter",
      title_gp = gpar(fontface = "bold"),
      border = 'black'
    )
  )
  
  #draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
  
  # if(!is.null(output_pdf)){
  #   pdf(output_pdf, width = pdf_width, height = pdf_height, useDingbats = FALSE)
  #   draw(ht, heatmap_legend_side = "right", 
  #        annotation_legend_side = "right",
  #        merge_legends = TRUE)
  #   dev.off()
  # } else {
  #   draw(ht, heatmap_legend_side = "right",
  #        annotation_legend_side = "right",
  #        merge_legends = TRUE)
  # }
  
  if(!is.null(output_pdf)){
    save_fig(fig =  ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE), 
             filename = file.path(nat.com.fig, "fig3d"), type = "heatmap", format = "pdf", 
             output_pdf, width = pdf_width, height = pdf_height,, dpi = 300)
  } else {
    ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE)
  }
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'#' Plot gene set or single-gene expression in a Seurat object
#'
#' Computes a gene set score (mean expression across features) and visualizes it
#' on dimensionality reduction embeddings or as violin plots. Supports continuous
#' or binary (expressing/non-expressing) visualization.
#'
#' @param obj Seurat object containing RNA assay.
#' @param features Character vector of genes to include in the score.
#' @param assay Assay to use (default: "RNA").
#' @param reduction Dimensionality reduction to plot (default: "umap").
#' @param method Visualization method: one of "score" (continuous FeaturePlot),
#'        "kde" (density via Nebulosa), "violins" (violin plot by cluster),
#'        or "binary" (highlight expressing vs non-expressing cells).
#' @param col.feature Colors for continuous feature scores (low, high).
#' @param nebula.pal Palette for density plots (Nebulosa).
#' @param pt.size Point size for embedding plots.
#' @param col.violin Colors for violin plots (optional).
#' @param expr.cut Minimum expression to count as positive for binary plots.
#' @param meta.score Metadata column name to store numeric score (default: "score").
#' @param meta.flag Metadata column name to store binary flag (default: "flag").
#' @param overlay.labels Logical, whether to overlay cluster labels with binary plots.
#' @param verbose Logical, print progress messages (default: FALSE).
#' @param ... Additional arguments passed to plotting functions (FeaturePlot, Nebulosa::plot_density, DimPlot).
#'
#' @return A ggplot object or patchwork plot object.
#' @export
#'
#' @examples
#' # Plot continuous gene set score on UMAP
#' plot_gene_score(obj = seurat_obj, features = c("GAP43","GNG8"), method = "score")
#'
#' # Plot density (Nebulosa)
#' plot_gene_score(obj = seurat_obj, features = c("GAP43","GNG8"), method = "kde")
#'
#' # Violin plot by cluster
#' plot_gene_score(obj = seurat_obj, features = c("GAP43","GNG8"), method = "violins")
#'
#' # Binary highlighting (expressing vs non-expressing)
#' plot_gene_score(obj = seurat_obj, features = c("GAP43","GNG8"), method = "binary")
plot_gene_score <- function(
    obj, 
    features, 
    assay = "RNA", 
    reduction = "umap", 
    method = c("score", "kde", "violins", "binary"),
    col.feature = c("lightgray", "darkred"),
    nebula.pal = "magma",
    pt.size = 0.1,
    col.violin = NULL,
    expr.cut = 1,
    meta.score = "score",
    meta.flag  = "flag",
    label = TRUE,
    theme = "classic",
    plot.title = NULL,
    axis.title.x.show = FALSE,
    font.size = 8,
    ...
) {
  
  require(Seurat); require(ggplot2); require(Nebulosa); require(matrixStats); require(dplyr)
  
  method <- match.arg(method)
  
  # Filter features
  genes <- intersect(features, rownames(GetAssayData(obj, assay = assay)))
  if (!length(genes)) stop("No features found in object.")
  
  expr.mat <- as.matrix(GetAssayData(obj, assay = assay)[genes, , drop = FALSE])
  
  # Compute mean score
  score <- if(nrow(expr.mat) == 1) expr.mat[1, ] else colMeans(expr.mat)
  flag  <- Matrix::colSums(expr.mat > expr.cut) > 0
  
  obj[[meta.score]] <- score
  obj[[meta.flag]]  <- ifelse(flag, "Positive", "None")
  
  # th <- theme(
  #   plot.title = element_text(hjust=0.5, face="bold"),
  #   axis.text  = element_text(size=12),
  #   axis.title = element_text(size=12)
  # )
  
  # Plot switch
  if (method == "score") {
    p <- FeaturePlot(obj, features = meta.score, reduction = reduction,
                     cols = col.feature, pt.size = pt.size) + 
      plot_theme(theme = theme,...)
  } else if (method == "kde") {
    p <- plot_density(obj, features = meta.score, reduction = reduction,
                      viridis_palette = nebula.pal, pt.size = pt.size) +  
      plot_theme(theme = theme,...)
  } else if (method == "violins") {
    df <- data.frame(ident = Idents(obj), score = obj[[meta.score]][,1])
    df$ident <- reorder(df$ident, df$score, median)
    if (is.null(col.violin)) {
      levels_idents <- levels(df$ident)
      #col.violin <- setNames(viridis::viridis(length(levels_idents)), levels_idents)
      col.violin <- custom_palette(length(levels_idents))
      names(col.violin) <- levels_idents
    }
    p <- ggplot(df, aes(x = ident, y = score, fill = ident)) +
      geom_violin() +
      geom_jitter(width = 0.2, size = pt.size, alpha = 0.5) +
      scale_fill_manual(values = col.violin) +
      plot_theme(theme = theme,font.size = font.size,
                 axis.title.x.show = axis.title.x.show,...)
  } else if (method == "binary") {
    pal <- c("Positive" = col.feature[2], "None" = col.feature[1])
    p <- cellmap(obj, group.by = meta.flag, reduction = reduction, 
                  colors = pal, pt.size = pt.size, label = label,...)
    # if (overlay.labels) {
    #   emb <- as.data.frame(Embeddings(obj, reduction))
    #   emb$flag <- obj[[meta.flag]][,1]
    #   emb$group <- Idents(obj)
    #   cent <- emb %>% group_by(group) %>%
    #     summarise(x=mean(get(colnames(emb)[1])), y=mean(get(colnames(emb)[2])), .groups="drop")
    #   p <- p + geom_text(data=cent, aes(x=x,y=y,label=group), inherit.aes=FALSE, fontface="bold")
    # }
  }
  
  p <- p + labs(title = plot.title) 
  
  return(p)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'#' Plot a Transcription Factor Regulatory Network
#'
#' Visualizes a transcription factor (TF) regulatory network using selected source TFs and their top N targets based on absolute regulatory strength (mor score).
#' Supports visual differentiation of positive and negative regulation, with shape and color coding for source vs. target nodes.
#'
#' @param net A data frame representing the TF regulatory network with columns: \code{source}, \code{target}, and \code{mor} (mode of regulation).
#' @param selected_sources A character vector of TFs to be used as source nodes.
#' @param n_targets Integer specifying the number of top targets to display per source (default: 5).
#' @param label_size Numeric; font size of node labels (default: 2).
#' @param node_size Numeric; size of node points (default: 15).
#' @param repel Logical; whether to repel node labels to avoid overlap using \code{geom_node_text} (default: FALSE).
#' @param layout_type Layout type for the network graph; passed to \code{ggraph::ggraph()} (default: "fr").
#' @param positive_color Color for positively regulated targets (default: "darkgreen").
#' @param negative_color Color for negatively regulated targets (default: "#e59866").
#' @param plot_title Title of the plot (default: "TF Regulatory Network").
#'
#' @return A ggplot2 object representing the regulatory network.
#'
#' @import ggraph
#' @import igraph
#' @import dplyr
#' @export
#'
#' @examples
#' \dontrun{
#' plot_tf_network(net = tf_network_df,
#'                 selected_sources = c("SOX2", "FOXA1"),
#'                 n_targets = 10,
#'                 repel = TRUE)
#' }
plot_tf_network <- function(net, 
                            selected_sources,
                            n_targets = 5, 
                            label_size = 2, 
                            node_size = 15,
                            repel = FALSE,
                            layout_type = "graphopt",   # deterministic
                            max_edges = 500,
                            positive_color = "darkred", 
                            negative_color = "navy",
                            plot_title = "TF Regulatory Network") {
  
  require(ggraph)
  require(igraph)
  require(dplyr)
  
  # Filter network
  filtered_net <- net %>%
    filter(source %in% selected_sources) %>%
    group_by(source) %>%
    top_n(n = n_targets, wt = abs(mor)) %>%
    ungroup()
  
  if (nrow(filtered_net) > max_edges) {
    filtered_net <- filtered_net %>%
      arrange(desc(abs(mor))) %>%
      slice(1:max_edges)
    warning(paste("Edge count exceeds", max_edges, "â€” truncating to top", max_edges, "edges."))
  }
  
  # Build graph
  g <- graph_from_data_frame(filtered_net, directed = TRUE)
  filtered_net$edge_color <- ifelse(filtered_net$mor > 0, "Positive", "Negative")
  
  node_df <- data.frame(name = V(g)$name) %>%
    mutate(node_type = ifelse(name %in% selected_sources, "Source", "Target"),
           shape = ifelse(node_type == "Source", 22, 21),
           edge_color = ifelse(node_type == "Source", "Source",
                               ifelse(name %in% filtered_net$target[filtered_net$mor > 0], "Positive", "Negative")),
           label_color = ifelse(node_type == "Source", "black", "white"))
  
  node_color_map <- c("Positive" = positive_color,
                      "Negative" = negative_color,
                      "Source" = "white")
  
  # FIXED LAYOUT â†’ stable, reproducible!
  set.seed(42)   # <-- makes layout identical every run
  
  # Plot
  p <- ggraph(g, layout = layout_type) +
    geom_edge_link0(aes(edge_alpha = abs(mor), edge_colour = filtered_net$edge_color),
                    show.legend = TRUE) +
    
    geom_node_point(aes(fill = factor(name, levels = node_df$name, labels = node_df$edge_color)),
                    size = node_size, shape = node_df$shape, show.legend = FALSE) +
    
    geom_node_text(aes(label = name, color = factor(name, levels = node_df$name, labels = node_df$label_color)),
                   size = label_size, fontface = "bold.italic", repel = repel) +
    
    
    # Legend 
    scale_edge_color_manual(
      name = "Regulation",
      values = c("Positive" = positive_color, "Negative" = negative_color),
      guide = guide_legend(
        override.aes = list(size = 6),
        title.position = "top",
        title.theme = element_text(size = 18, face = "bold"),
        label.theme = element_text(size = 16)
      )
    ) +
    
    scale_fill_manual(values = node_color_map, guide = "none") +
    scale_color_manual(values = c("black", "white"), guide = "none") +
    guides(edge_alpha = "none") +
    
    theme_void() +
    ggtitle(plot_title) +
    
    theme(
      plot.margin = unit(c(1,1,1,1), "cm"),
      legend.text  = element_text(size = 16),
      legend.title = element_text(size = 18, face = "bold"),
      legend.key.size = unit(1.4, "cm"),
      legend.key.height = unit(1.4, "cm"),
      legend.key.width = unit(1.4, "cm"),
      legend.position = "right"
    ) +
    
    scale_x_discrete(expand = expansion(mult = c(0.1, 0.1))) +
    scale_y_discrete(expand = expansion(mult = c(0.1, 0.1)))
  
  return(p)
}


plot_tf_activity <- function(
    seurat_object,
    tf_list,
    assay_activity = "tfsulm",
    group.by = "seurat_clusters",
    low_color = "navy",
    high_color = "darkred",
    zscore = TRUE,
    zscore_mode = c("per_tf", "global"),
    fontsize = 10,
    legend.text.size = 10,
    theme = "classic",
    ncol = 1,
    hide_last_x_title = TRUE,
    leg.pos = "bottom"
) {
  require(Seurat)
  require(ggplot2)
  require(dplyr)
  require(patchwork)
  
  zscore_mode <- match.arg(zscore_mode)
  
  DefaultAssay(seurat_object) <- assay_activity
  found_activity <- intersect(tf_list, rownames(GetAssayData(seurat_object, slot = "data")))
  if (length(found_activity) == 0)
    stop("None of the TFs were found in the assay.")
  
  ## GLOBAL COLOR SCALE (DO NOT TOUCH BAR VALUES)
  if (zscore && zscore_mode == "global") {
    
    all_zvals <- lapply(found_activity, function(tf) {
      FetchData(seurat_object, vars = c(tf, group.by)) %>%
        group_by(.data[[group.by]]) %>%
        summarise(val = mean(.data[[tf]], na.rm = TRUE), .groups = "drop") %>%
        pull(val) %>%
        scale() %>%
        as.numeric()
    }) %>% unlist()
    
    global_abs_lim <- max(abs(all_zvals), na.rm = TRUE)
    
  } else {
    global_abs_lim <- NULL
  }
  
  plot_list <- list()
  total_tf <- length(tf_list)
  
  for (i in seq_along(tf_list)) {
    
    tf <- tf_list[i]
    
    if (tf %in% found_activity) {
      
      df <- FetchData(seurat_object, vars = c(tf, group.by)) %>%
        group_by(.data[[group.by]]) %>%
        summarise(mean_val = mean(.data[[tf]], na.rm = TRUE), .groups = "drop")
      
      ## BAR HEIGHTS
      df$zval <- if (zscore) scale(df$mean_val)[, 1] else df$mean_val
      
      show_x <- i == total_tf
      
      ## COLOR SCALE
      fill_scale <- scale_fill_gradient2(
        low = low_color,
        mid = "white",
        high = high_color,
        midpoint = 0,
        limits = if (!is.null(global_abs_lim)) c(-global_abs_lim, global_abs_lim) else NULL,
        name = if (zscore) "z-score" else "Mean activity"
      )
      
      p <- ggplot(df, aes(x = .data[[group.by]], y = zval, fill = zval)) +
        geom_col(color = "black", linewidth = 0.2, width = 0.5) +
        fill_scale +
        plot_theme(font.size = fontsize, theme = theme, axis.title.x.show = FALSE) +
        theme(
          axis.text.x = if (show_x) element_text(angle = 45, hjust = 1) else element_blank(),
          axis.ticks.x = if (show_x) element_line() else element_blank(),
          axis.title.x = if (show_x) element_text() else element_blank(),
          plot.title = element_text(face = "bold.italic", hjust = 0.5)
        ) +
        ggtitle(tf) +
        ylab(if (zscore) "z-score" else "Mean TF activity") +
        xlab(if (show_x) group.by else "") +
        guides(
          fill = guide_colorbar(
            frame.colour = "black",
            ticks.colour = "black",
            frame.linewidth = 0.2
          )
        )
      
    } else {
      p <- ggplot() + theme_void() + ggtitle(paste0(tf, " (not found)"))
    }
    
    plot_list[[tf]] <- p
  }
  
  ## LEGEND LOGIC
  horizontal_positions <- c("bottom", "top")
  
  legend_direction <- if (leg.pos %in% horizontal_positions) "horizontal" else "vertical"
  legend_title_pos <- if (leg.pos %in% horizontal_positions) "top" else "left"
  
  final_plot <- wrap_plots(
    plot_list,
    ncol = ncol,
    guides = "collect",
    axis_titles = "collect"
  ) &
    theme(
      axis.title.x = element_blank(),
      legend.position = leg.pos,
      legend.direction = legend_direction,
      legend.title.position = legend_title_pos,
      legend.title = element_text(size = legend.text.size, hjust = 0.5),
      legend.text  = element_text(size = legend.text.size),
      legend.key.height = unit(0.3, "cm"),
      legend.key.width  = unit(0.6, "cm")
    )
  
  return(final_plot)
}


#' Plot dominance score results
#'
#' @param df Data frame returned by `dominance_score()`$df
#' @param mode Plot mode: "bins", "high_cells", "top_genes"
#' @param ident.col Grouping column for "bins" and "high_cells" (default "ident")
#' @param stage.col Optional column to facet/stratify plots by, e.g., "stage" or "sample"
#' @param bin.col Column name for dominance bins (default "adjusted_bin")
#' @param gene.col Column name for genes (default "top_gene")
#' @param min.adjust Minimum adjusted dominance score (used in high_cells & top_genes)
#' @param min.top.expr Minimum top gene expression
#' @param max.n.genes Maximum number of expressed genes
#' @param top.n Number of top genes to show (mode = "top_genes")
#' @param colors Optional named vector of colors
#' @param font.size Base font size
#' @param theme ggplot theme name
#' @param leg.pos Legend position
#' @param x.angle X-axis text angle
#'
#' @return ggplot object
#' @export
plot_dominance_score <- function(
    df,
    mode = c("bins", "high_cells", "top_genes"),
    ident.col = "ident",
    stage.col = NULL,       
    bin.col = "adjusted_bin",
    gene.col = "top_gene",
    min.adjust = 1,
    min.top.expr = 1,
    max.n.genes = 3,
    top.n = 20,
    colors = NULL,
    font.size = 10,
    theme = "classic",
    plot.ttl = NULL,
    leg.pos = "top",
    leg.dir = "horizontal",
    x.angle = 45,
    ncol = 2
) {
  require(dplyr)
  require(ggplot2)
  mode <- match.arg(mode)
  
  if (is.null(colors)) {
    groups <- unique(df[[ident.col]])
    colors <- setNames(
      grDevices::colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(groups)),
      groups
    )
  }
  
  # MODE: dominance bins
  if (mode == "bins") {
    plot.df <- df %>%
      filter(!is.na(.data[[bin.col]])) %>%
      {
        if (!is.null(stage.col) && stage.col %in% colnames(.)) {
          group_by(., .data[[stage.col]], .data[[bin.col]], .data[[ident.col]]) 
        } else {
          group_by(., .data[[bin.col]], .data[[ident.col]])
        }
      } %>%
      summarise(n = n(), .groups = "drop") %>%
      {
        if (!is.null(stage.col) && stage.col %in% colnames(.)) {
          group_by(., .data[[stage.col]], .data[[bin.col]])
        } else group_by(., .data[[bin.col]])
      } %>%
      mutate(perc = 100 * n / sum(n)) %>%
      ungroup()
    
    p <- ggplot(plot.df,
                aes(x = .data[[bin.col]], y = perc, fill = .data[[ident.col]])) +
      geom_col(color = "black", linewidth = 0.2) +
      scale_fill_manual(values = colors) +
      labs(x = "Dominance score", y = "Cell type proportion (%)", fill = "", title = plot.ttl) +
      plot_theme(theme = theme, font.size = font.size, leg.pos = leg.pos,leg.dir = leg.dir, x.angle = 0)
  }
  
  # MODE: high-dominance cells
  else if (mode == "high_cells") {
    plot.df <- df %>%
      filter(
        adjust_score > min.adjust,
        top_expr >= min.top.expr,
        n_genes_expr <= max.n.genes
      ) %>%
      {
        if (!is.null(stage.col) && stage.col %in% colnames(.)) {
          group_by(., .data[[stage.col]], .data[[ident.col]])
        } else group_by(., .data[[ident.col]])
      } %>%
      summarise(n_cells = n(), .groups = "drop")
    
    x_col <- if (!is.null(stage.col) && stage.col %in% colnames(df)) stage.col else ident.col
    
    p <- ggplot(plot.df,
                aes(x = factor(.data[[x_col]]),
                    y = n_cells,
                    fill = .data[[ident.col]])) +
      geom_col(color = "black", linewidth = 0.2) +
      scale_fill_manual(values = colors) +
      labs(x = "", y = paste0("High-dominance cells\n(adjusted > ", min.adjust, ")"), fill = "", title = plot.ttl) +
      plot_theme(theme = theme, font.size = font.size, leg.pos = leg.pos, leg.dir = leg.dir, x.angle = x.angle)
  }
  
  # MODE: top dominant genes
  if (mode == "top_genes") {
    high.df <- df %>%
      filter(
        adjust_score > min.adjust,
        top_expr >= min.top.expr,
        n_genes_expr <= max.n.genes,
        !is.na(.data[[gene.col]])
      )
    
    # Ensure gene column is character
    high.df[[gene.col]] <- as.character(high.df[[gene.col]])
    
    if (!is.null(stage.col) && stage.col %in% colnames(high.df)) {
      plot.df <- high.df %>%
        group_by(.data[[stage.col]], .data[[gene.col]]) %>%
        summarise(n = n(), .groups = "drop") %>%
        arrange(.data[[stage.col]], desc(n)) %>%
        group_by(.data[[stage.col]]) %>%
        slice_head(n = top.n) %>%
        ungroup()
      
      # Ensure n is integer
      plot.df$n <- as.integer(plot.df$n)
      
      p <- ggplot(plot.df, aes(x = reorder(.data[[gene.col]], n), y = n)) +
        geom_col(fill = "steelblue", color = "black", linewidth = 0.2) +
        coord_flip() +
        facet_wrap(as.formula(paste0("~", stage.col)), ncol = ncol) +
        scale_y_continuous(breaks = scales::pretty_breaks()) +
        labs(x = "Top dominant OR genes", y = "Number of high-dominance cells", title = plot.ttl) +
        plot_theme(font.size = font.size,theme = theme, leg.pos = "none")
    } else {
      plot.df <- high.df %>%
        dplyr::count(!!rlang::sym(gene.col), sort = TRUE, name = "n") %>%
        slice_head(n = top.n)
      
      # Ensure n is integer
      plot.df$n <- as.integer(plot.df$n)
      
      p <- ggplot(
        plot.df,
        aes(x = reorder(!!rlang::sym(gene.col), n), y = n)
      ) +
        geom_col(fill = "steelblue", color = "black", linewidth = 0.2) +
        coord_flip() +
        scale_y_continuous(breaks = scales::pretty_breaks()) +
        labs( x = "",y = "Number of high-dominance cells",title = plot.ttl) +
        plot_theme(font.size = font.size,theme = theme, leg.pos = "none")
    }
  }
  if (!is.null(colors)) p <- p + scale_fill_manual(values = colors)
  return(p)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
#' Plot Heatmap Along Pseudotime
#'
#' Generates a heatmap of gene expression along pseudotime for selected lineages, with
#' flexible annotation and legend options. Supports automatic legend type detection
#' (discrete vs continuous), smooth scaling, z-score transformation, and flexible
#' legend title positioning.
#'
#' @param heatmap_matrices List of heatmap matrices produced by `identify_temporal_genes` or similar. Each element should have `expr_raw`, `ordered_cells`, `top_genes`.
#' @param seurat_obj Seurat object containing cell metadata.
#' @param lineage_name Character. Name of the lineage to plot. Defaults to first element of `heatmap_matrices`.
#' @param pseudotime_vec Numeric vector of pseudotime values. Defaults to sequential ordering of `ordered_cells`.
#' @param gene_list Character vector of genes to plot. Defaults to `hm$top_genes`.
#' @param annotation_col Column in `seurat_obj@meta.data` to use for annotation. Default `"ann_level_2"`.
#' @param celltype_colors Named vector of colors for annotation clusters. If `NULL`, colors are auto-generated.
#' @param zscore_limits Numeric vector of length 3, c(min, mid, max), used for color scaling. Default c(-2,0,2).
#' @param pseudotime_palette Character. Palette name for pseudotime continuous scale. Default `"YlGnBu"`.
#' @param row_cluster_colors Not currently used. Placeholder for future row annotations.
#' @param font_size Font size for heatmap labels and legends. Default 10.
#' @param output_pdf Path to save heatmap. If `NULL`, heatmap is drawn on screen.
#' @param fig_name Filename for saving heatmap. Default uses `plot_title`.
#' @param pdf_width Width of saved PDF/PNG. Default 6.
#' @param pdf_height Height of saved PDF/PNG. Default 10.
#' @param plot_title Title of heatmap. Default `NULL`.
#' @param show_annotation_legend Logical. Show legend for top annotations. Default `TRUE`.
#' @param smooth_df Degrees of freedom for smoothing spline. Default 3.
#' @param legend_dir `"vertical"` or `"horizontal"`. Orientation of legend. Default `"vertical"`.
#' @param ht_legend_side Side of heatmap legend (`"right"` or `"left"`). Default `"right"`.
#' @param ann_legend_side Side of top annotation legend (`"top"` or `"right"`). Default `"right"`.
#' @param legend_width_cm Width of legends in cm. Default 3.
#' @param cont_legend_cm Height of continuous legends in cm. Default 3.
#' @param merge_legends Logical. Merge annotation and heatmap legends. Default `FALSE`.
#' @param center_legend_titles Logical. Center all heatmap legend titles. Default `TRUE`.
#' @param center_cells_title Logical. Center "Cells" annotation legend title. Default `TRUE`.
#' @param center_pt_title Logical. Center "Pseudotime" annotation legend title. Default `TRUE`.
#' @param cells_title_pos Custom position for "Cells" title (overrides centering). Default `NULL`.
#' @param pt_title_pos Custom position for "Pseudotime" title (overrides centering). Default `NULL`.
#' @param hm_title_pos Custom position for heatmap legend title. Default `NULL`.
#'
#' @return `ComplexHeatmap` object invisibly. If `output_pdf` is provided, the heatmap is saved as PNG.
#' @export
#'
#' @examples
#' plot_heatmap_pseudotime(
#'   heatmap_matrices = l1$heatmap_matrices,
#'   seurat_obj = sub,
#'   lineage_name = "Lineage1",
#'   pseudotime_vec = pt_vec,
#'   gene_list = gene_list,
#'   celltype_colors = cols,
#'   font_size = 8,
#'   pdf_width = 4,
#'   pdf_height = 6,
#'   output_pdf = file.path(dir.results),
#'   plot_title = "Neuronal lineage",
#'   legend_dir = "vertical",
#'   ht_legend_side = "right",
#'   ann_legend_side = "right",
#'   annotation_col = "ann2",
#'   merge_legends = TRUE,
#'   center_legend_titles = TRUE,
#'   center_cells_title = TRUE,
#'   center_pt_title = FALSE,
#'   cells_title_pos = "topcenter",
#'   pt_title_pos = "leftcenter",
#'   hm_title_pos = "topcenter"
#' )
plot_heatmap_pseudotime <- function(
    heatmap_matrices,
    seurat_obj,
    lineage_name = NULL,
    pseudotime_vec = NULL,
    gene_list = NULL,
    annotation_col = "ann_level_2",
    celltype_colors = NULL,
    zscore_limits = c(-2, 0, 2),
    pseudotime_palette = "YlGnBu",
    row_cluster_colors = NULL,
    font_size = 10,
    output_pdf = NULL,
    fig_name = paste(plot_title),
    pdf_width = 6,
    pdf_height = 10,
    plot_title = NULL,
    show_annotation_legend = TRUE,
    smooth_df = 3,
    legend_dir = "vertical",
    ht_legend_side = "right",
    ann_legend_side = "right",
    legend_width_cm = 3,
    cont_legend_cm = 3,
    merge_legends = FALSE,
    center_legend_titles = TRUE,
    center_cells_title = TRUE,
    center_pt_title = TRUE,
    cells_title_pos = NULL,
    pt_title_pos = NULL,
    hm_title_pos = NULL
){
  require(ComplexHeatmap)
  require(circlize)
  require(RColorBrewer)
  
  # --- Setup lineage and genes
  if(is.null(lineage_name)) lineage_name <- names(heatmap_matrices)[1]
  if(!lineage_name %in% names(heatmap_matrices)) stop("Lineage not found")
  hm <- heatmap_matrices[[lineage_name]]
  if(is.null(gene_list)) gene_list <- hm$top_genes
  cells_hm <- hm$ordered_cells
  expr_mat <- as.matrix(hm$expr_raw[gene_list, cells_hm, drop = FALSE])
  
  # --- Smooth
  if(!is.null(smooth_df) && smooth_df > 0){
    expr_mat <- t(apply(expr_mat, 1, function(x){
      if(sd(x) == 0) return(x)
      tryCatch(smooth.spline(x, df = smooth_df)$y, error = function(e) x)
    }))
  }
  
  # --- Z-score scaling
  row_means <- rowMeans(expr_mat, na.rm = TRUE)
  row_sds <- apply(expr_mat, 1, sd, na.rm = TRUE)
  row_sds[row_sds == 0] <- 1
  expr_mat_scaled <- (expr_mat - row_means) / row_sds
  
  # --- Order genes by pseudotime peak
  gene_peak <- apply(expr_mat_scaled, 1, which.max)
  expr_mat_scaled <- expr_mat_scaled[order(gene_peak), ]
  
  # --- Clusters and annotation
  clusters <- seurat_obj@meta.data[cells_hm, annotation_col]
  if(!is.factor(clusters)){
    cluster_order <- unique(clusters)
    clusters <- factor(clusters, levels = cluster_order)
  } else {
    cluster_order <- levels(clusters)
  }
  clusters[is.na(clusters)] <- "Unknown"
  
  if(is.null(celltype_colors)){
    celltype_colors <- setNames(
      colorRampPalette(brewer.pal(8,"Dark2"))(length(cluster_order)),
      cluster_order
    )
  }
  
  if(is.null(pseudotime_vec)) pseudotime_vec <- seq_along(cells_hm)
  pseudotime <- pseudotime_vec[cells_hm]
  
  pt_col_fun <- colorRamp2(
    seq(min(pseudotime), max(pseudotime), length.out = 100),
    viridis::viridis(100, option = "C")
  )
  
  # --- Helper to resolve title positions
  resolve_title_pos <- function(title_pos, center, is_discrete, legend_dir){
    if(is_discrete){
      if(!is.null(title_pos)) return(title_pos)
      if(legend_dir == "vertical") return("left") else return("top")
    } else {
      if(!is.null(title_pos)) return(title_pos)
      if(center){
        if(legend_dir == "vertical") return("leftcenter-rot") else return("topcenter")
      } else {
        if(legend_dir == "vertical") return("lefttop-rot") else return("topcenter")
      }
    }
  }
  
  is_cells_discrete <- is.factor(clusters)
  is_pt_discrete <- !is.numeric(pseudotime)
  cells_pos <- resolve_title_pos(cells_title_pos, center_cells_title, is_cells_discrete, legend_dir)
  pt_pos <- resolve_title_pos(pt_title_pos, center_pt_title, is_pt_discrete, legend_dir)
  
  top_annot <- HeatmapAnnotation(
    "Cells" = factor(clusters, levels = cluster_order),
    "Pseudotime" = pseudotime,
    col = list("Cells" = celltype_colors, "Pseudotime" = pt_col_fun),
    show_legend = show_annotation_legend,
    annotation_legend_param = list(
      "Cells" = list(
        border = "black",
        labels_gp = gpar(fontsize = font_size),
        title_gp = gpar(
          fontsize = font_size,
          fontface = "bold",
          just = if(center_cells_title) "center" else "left"
        ),
        title_position = cells_pos,
        legend_direction = legend_dir,
        legend_width = unit(legend_width_cm, "cm"),
        legend_height = unit(cont_legend_cm, "cm"),
        nrow = if(legend_dir == "horizontal") 1 else NULL
      ),
      "Pseudotime" = list(
        border = "black",
        labels_gp = gpar(fontsize = font_size),
        title_gp = gpar(
          fontsize = font_size,
          fontface = "bold",
          just = if(center_pt_title) "center" else "left"
        ),
        title_position = pt_pos,
        legend_direction = legend_dir,
        legend_width = unit(legend_width_cm, "cm"),
        legend_height = unit(cont_legend_cm, "cm")
      )
    ),
    annotation_name_gp = gpar(fontsize = font_size, fontface = "bold")
  )
  
  ht <- Heatmap(
    expr_mat_scaled,
    name = "Z-score",
    col = colorRamp2(seq(-2, 2, length = 11), rev(brewer.pal(11, "Spectral"))),
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_column_names = FALSE,
    show_row_names = TRUE,
    row_names_gp = gpar(fontsize = font_size),
    top_annotation = top_annot,
    row_title_rot = 0,
    cluster_row_slices = FALSE,
    show_row_dend = FALSE,
    column_title = plot_title,
    column_title_gp = gpar(fontsize = font_size, fontface="bold"),
    heatmap_legend_param = list(
      title = "Z-score",
      legend_direction = legend_dir,
      title_position = resolve_title_pos(hm_title_pos, center_legend_titles, FALSE, legend_dir),
      legend_width = unit(legend_width_cm, "cm"),
      legend_height = unit(cont_legend_cm, "cm"),
      labels_gp = gpar(fontsize = font_size),
      title_gp = gpar(
        fontsize = font_size,
        fontface = "bold",
        just = if(center_legend_titles) "center" else "left"
      ),
      border = "black"
    )
  )
  
  if(!is.null(output_pdf)){
    ComplexHeatmap::draw(ht,
                         heatmap_legend_side = ht_legend_side,
                         annotation_legend_side = ann_legend_side,
                         merge_legends = merge_legends
    )
    save_heatmap(
      ht = ComplexHeatmap::draw(ht,
                                heatmap_legend_side = ht_legend_side,
                                annotation_legend_side = ann_legend_side,
                                merge_legends = TRUE
      ),
      filename = file.path(dir.results, fig_name),
      formats = c("png"),
      width = pdf_width,
      height = pdf_height
    )
  } else {
    ComplexHeatmap::draw(ht,
                         heatmap_legend_side = ht_legend_side,
                         annotation_legend_side = ann_legend_side,
                         merge_legends = TRUE
    )
  }
  
  invisible(ht)
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Infer Cell Types from Marker Genes
#'
#' This function infers cell types for unknown clusters by comparing gene marker overlap with annotated reference clusters.
#' It optionally visualizes the results using either a barplot or a heatmap.
#'
#' @param marker_table_annotated A data frame of annotated reference markers. Must contain gene, cluster, and p-value columns.
#' @param marker_table_unknown A data frame of markers for unknown clusters. Must contain gene, cluster, and p-value columns.
#' @param gene_column Name of the column containing gene symbols. Default is `"gene"`.
#' @param cluster_column Name of the column containing cluster IDs. Default is `"cluster"`.
#' @param pval_column Name of the column containing p-values for filtering. Default is `"p_val_adj"`.
#' @param pval_threshold Numeric threshold to filter marker genes by adjusted p-value. Default is `0.05`.
#' @param use_palette Logical indicating whether to apply a color palette in the barplot. Default is `TRUE`.
#' @param theme ggplot2 theme style to apply to plots (e.g., `"minimal"`, `"classic"`). Default is `"minimal"`.
#' @param heatmap_theme_color Viridis color palette option for the heatmap (e.g., `"viridis"`, `"magma"`, `"plasma"`). Default is `"viridis"`.
#' @param x.angle Integer angle to rotate x-axis text labels. Default is `90`.
#' @param plot_type Type of plot to generate. Either `"barplot"` or `"heatmap"`. Default is `"barplot"`.
#'
#' @return A list containing:
#' \describe{
#'   \item{`predictions`}{Data frame of predicted cell types for each unknown cluster.}
#'   \item{`annotated_markers`}{Updated marker table with predicted cell type column.}
#'   \item{`plot`}{A ggplot2 object showing the visualization.}
#' }
#'
#' @import dplyr ggplot2 tidyr rlang reshape2 viridis
#' @export
#'
#' @examples
#' # Example data
#' annotated <- data.frame(
#'   gene = c("CD3D", "CD3E", "CD79A", "CD79B"),
#'   cluster = c("T_cells", "T_cells", "B_cells", "B_cells"),
#'   p_val_adj = c(0.001, 0.002, 0.001, 0.002)
#' )
#'
#' unknown <- data.frame(
#'   gene = c("CD3D", "CD3E", "CD79A", "CD79B"),
#'   cluster = c("Cluster1", "Cluster1", "Cluster2", "Cluster2"),
#'   p_val_adj = c(0.001, 0.002, 0.001, 0.002)
#' )
#'
#' result <- infer_cell_types_from_markers(
#'   marker_table_annotated = annotated,
#'   marker_table_unknown = unknown,
#'   gene_column = "gene",
#'   cluster_column = "cluster",
#'   pval_column = "p_val_adj",
#'   plot_type = "heatmap"
#' )
#'
#' print(result$plot)
#' 
infer_cell_types_from_markers <- function(marker_table_annotated,
                                          marker_table_unknown,
                                          gene_column = "gene",
                                          cluster_column = "cluster",
                                          pval_column = "p_val_adj",
                                          pval_threshold = 0.05,
                                          use_palette = TRUE,
                                          theme = "minimal",
                                          heatmap_theme_color = "viridis",
                                          x.angle = 90,
                                          cluster_rows = FALSE,
                                          cluster_cols = FALSE,
                                          label_clusters = TRUE,
                                          plot_type = c("barplot", "heatmap")) {
  
  require(dplyr)
  require(ggplot2)
  require(tidyr)
  require(rlang)
  require(viridis)
  
  plot_type <- match.arg(plot_type)
  
  # Tidy evaluation for column names
  gene_col <- sym(gene_column)
  cluster_col <- sym(cluster_column)
  pval_col <- sym(pval_column)
  
  # Group markers by cluster
  annotated_list <- marker_table_annotated %>%
    dplyr::group_by(!!cluster_col) %>%
    dplyr::summarise(genes = list(unique(!!gene_col)), .groups = "drop")
  
  marker_table_unknown <- marker_table_unknown %>%
    dplyr::filter(!!pval_col <= pval_threshold)
  
  unknown_list <- marker_table_unknown %>%
    dplyr::group_by(!!cluster_col) %>%
    dplyr::summarise(genes = list(unique(!!gene_col)), .groups = "drop")
  
  # Generate overlap matrix
  predictions <- expand.grid(
    cluster = unknown_list[[cluster_column]],
    cell_type = annotated_list[[cluster_column]],
    stringsAsFactors = FALSE
  )
  
  predictions$overlap_score <- mapply(function(cl, ct) {
    genes_cluster <- unknown_list$genes[[which(unknown_list[[cluster_column]] == cl)]]
    genes_celltype <- annotated_list$genes[[which(annotated_list[[cluster_column]] == ct)]]
    length(intersect(genes_cluster, genes_celltype))
  }, predictions$cluster, predictions$cell_type)
  
  # Best matching cell type per unknown cluster
  predicted_labels <- predictions %>%
    dplyr::group_by(cluster) %>%
    dplyr::top_n(1, wt = overlap_score) %>%
    dplyr::arrange(cluster) %>%
    dplyr::ungroup()
  
  # Add predictions to marker table
  marker_table_unknown <- marker_table_unknown %>%
    dplyr::left_join(predicted_labels %>% 
                       dplyr::rename(predicted_cell_type = cell_type), by = cluster_column)
  
  stopifnot("predicted_cell_type" %in% colnames(marker_table_unknown))
  
  # Plot logic
  
  if (plot_type == "barplot") {
    plot_data <- marker_table_unknown %>%
      dplyr::group_by(!!cluster_col, predicted_cell_type) %>%
      dplyr::summarise(count = dplyr::n(), .groups = "drop")
    
    idents <- plot_data %>% pull(!!cluster_col) %>% unique()
    plot_data[[cluster_column]] <- factor(plot_data[[cluster_column]], levels = idents)
    
    if (use_palette) {
      colors <- custom_palette(n = length(idents))
      names(colors) <- as.character(idents)
    } else {
      colors <- NULL
    }
    
    # plot <- ggplot(plot_data, aes(x = predicted_cell_type, y = count, fill = !!cluster_col)) +
    #   geom_bar(stat = "identity", position = "stack") +
    #   labs(
    #     title = "Predicted Cell Types per Cluster",
    #     x = "Predicted Cell Type",
    #     y = "Gene Marker Count",
    #     fill = "Cluster"
    #   ) +
    #   plot_theme(theme = theme, x.angle = x.angle) 
    
    plot <- ggplot(plot_data, aes(x = predicted_cell_type, y = count, fill = !!cluster_col)) +
      geom_bar(stat = "identity", position = "stack") +
      labs(
        title = "Predicted Cell Types per Cluster",
        x = "Predicted Cell Type",
        y = "Gene Marker Count",
        fill = "Cluster"
      ) +
      plot_theme(theme = theme, x.angle = x.angle)
    
    if (label_clusters) {
      plot <- plot +
        geom_text(
          aes(label = !!cluster_col),
          position = position_stack(vjust = 0.5),
          color = "white",
          size = 3
        )
    }
    
    if (!is.null(colors)) {
      plot <- plot + scale_fill_manual(values = colors)
    }
    
    
    if (!is.null(colors)) {
      plot <- plot + scale_fill_manual(values = colors)
    }
  } else if (plot_type == "heatmap") {
    heatmap_data <- predictions %>%
      pivot_wider(names_from = cell_type, values_from = overlap_score, values_fill = 0)
    
    rownames_mat <- heatmap_data$cluster
    heatmap_mat <- as.matrix(heatmap_data[ , -1])
    rownames(heatmap_mat) <- rownames_mat
    
    # Optional clustering
    if (cluster_rows) {
      row_order <- hclust(dist(heatmap_mat))$order
      heatmap_mat <- heatmap_mat[row_order, , drop = FALSE]
    }
    if (cluster_cols) {
      col_order <- hclust(dist(t(heatmap_mat)))$order
      heatmap_mat <- heatmap_mat[, col_order, drop = FALSE]
    }
    
    library(reshape2)
    melted <- melt(heatmap_mat)
    colnames(melted) <- c("Unknown_Cluster", "Annotated_Cell_Type", "Overlap")
    melted$Unknown_Cluster <- factor(melted$Unknown_Cluster)
    
    plot <- ggplot(melted, aes(x = Annotated_Cell_Type, y = Unknown_Cluster, fill = Overlap)) +
      #geom_tile(color = "white") +
      #scale_fill_gradient(low = "white", high = "darkblue") +
      geom_tile(color = "black", size = 0.5) +  # Black gaps between heatmap cells
      scale_fill_viridis(option = heatmap_theme_color, name = "Overlap") +  # Viridis color scale
      guides(fill = guide_colorbar(frame.colour = "black", 
                                   ticks.colour = "black", 
                                   frame.linewidth = 0.2,
                                   barwidth = 0.8,  # Reduce width
                                   barheight = 5)) +
      labs(
        title = "Gene Overlap Heatmap",
        x = "Annotated Cell Type",
        y = "Unknown Cluster"
      ) +
      plot_theme(theme = theme, x.angle = x.angle)
  }
  
  return(list(
    predictions = predicted_labels,
    annotated_markers = marker_table_unknown,
    plot = plot
  ))
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' @title Cell Prediction Heatmap
#' @description Generates a heatmap to visualize cell predictions from Seurat metadata.
#' @details This function creates a heatmap of predicted cell annotations vs. Seurat clusters.
#' Optionally, it can perform hierarchical clustering on rows and/or columns.
#'
#' @param object A Seurat object containing metadata.
#' @param cluster_var A string specifying the column name in `meta.data` that contains cluster assignments. Default is `"seurat_clusters"`.
#' @param annotation_var A string specifying the column name in `meta.data` that contains predicted annotations. Default is `"predicted.annotation.l1"`.
#' @param base_size Numeric value controlling the base font size. Default is `12`.
#' @param plot_title A string for the heatmap title. Default is `"Azimuth Prediction (Cao et al., 2020)"`.
#' @param theme_color A string specifying the Viridis color scale option. Options: `"viridis"`, `"magma"`, `"plasma"`. Default is `"viridis"`.
#' @param x_title A string for the x-axis label. Default is `NULL` (no label).
#' @param y_title A string for the y-axis label. Default is `NULL` (no label).
#' @param cluster_rows Logical; if `TRUE`, applies hierarchical clustering to rows (annotations). Default is `FALSE`.
#' @param cluster_cols Logical; if `TRUE`, applies hierarchical clustering to columns (clusters). Default is `FALSE`.
#'
#' @import Seurat ggplot2 reshape2 viridis grid
#' @return A ggplot2 heatmap showing annotation proportions across clusters.
#' @examples
#' \dontrun{
#' cell_prediction_heatmap(object = my_seurat_object, cluster_rows = TRUE, cluster_cols = TRUE)
#' }
#' @export
cell_prediction_heatmap <- function(object, 
                                    cluster_var = "seurat_clusters", 
                                    annotation_var = "predicted.annotation.l1",
                                    base_size = 12,
                                    plot_title = "Cell prediction",
                                    theme_color = "viridis", # Options: "magma", "plasma"
                                    x_title = NULL,
                                    y_title = NULL,
                                    cluster_rows = FALSE,
                                    cluster_cols = FALSE) {
  
  require(Seurat)
  require(ggplot2)
  require(reshape2)
  require(viridis)
  require(grid)  # Required for setting legend height
  
  # Ensure cluster variable is a factor (to maintain order)
  object@meta.data[[cluster_var]] <- factor(object@meta.data[[cluster_var]])
  
  # Create contingency table
  data_matrix <- table(object@meta.data[[annotation_var]], object@meta.data[[cluster_var]])
  
  # Normalize to percentages per column
  data_prop <- prop.table(data_matrix, 2)  # Column-wise normalization
  
  # Convert to long format for ggplot
  df_long <- melt(data_prop)
  colnames(df_long) <- c("Annotation", "Cluster", "Percentage")
  
  # Ensure Cluster is a factor to keep the order
  df_long$Cluster <- factor(df_long$Cluster, levels = levels(object@meta.data[[cluster_var]]))
  
  # Perform hierarchical clustering if enabled
  if (cluster_rows) {
    row_order <- hclust(dist(data_prop))$order
    df_long$Annotation <- factor(df_long$Annotation, levels = rownames(data_prop)[row_order])
  }
  
  if (cluster_cols) {
    col_order <- hclust(dist(t(data_prop)))$order
    df_long$Cluster <- factor(df_long$Cluster, levels = colnames(data_prop)[col_order])
  }
  
  # Dynamically scale legend height using `npc` to match plot height
  legend_height <- unit(0.8, "npc")  # 90% of plot height
  
  # Create heatmap with auto-scaling legend height
  p <- ggplot(df_long, aes(x = Cluster, y = Annotation, fill = Percentage)) +
    geom_tile(color = "black", size = 0.5) +  # Black gaps between heatmap cells
    viridis::scale_fill_viridis(option = theme_color, name = "") +  # Viridis color scale
    guides(fill = guide_colorbar(frame.colour = "black", 
                                 ticks.colour = "black", 
                                 frame.linewidth = 0.2,
                                 barwidth = 0.8,  # Reduce width
                                 barheight = legend_height)) +  # Dynamically scale legend height
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = base_size*1.2, face = "bold.italic", color = "black"),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = base_size, color = "black"),
          axis.text.y = element_text(size = base_size, color = "black"),
          legend.position = "right",
          legend.justification = "center",  # Align legend better
          legend.box.margin = margin(0, 0, 0, 0),  # Reduce space
          legend.margin = margin(0, 0, 0, 0),  # Minimize legend spacing
          legend.key.height = legend_height) +  # Auto-scale legend height
    labs(title = plot_title, x = x_title, y = y_title)
  
  return(p)
}



#' Create Sankey Plot from Seurat Object
#'
#' This function generates a Sankey plot using the `networkD3` package from a Seurat object,
#' based on selected variables (metadata columns). It visualizes transitions between different 
#' levels or categories across the selected variables.
#'
#' @param object Seurat object containing the metadata.
#' @param selected_vars A character vector of metadata column names to visualize in the Sankey plot. 
#'                       Must contain at least two variables.
#' @param color_list A named list of colors where names correspond to the identity (e.g., cell type) 
#'                   and values correspond to the colors. If NULL, default colors are used.
#' @param sinksRight A boolean value indicating whether the sinks (final nodes) should be positioned on the right 
#'                   side of the plot. Defaults to FALSE.
#' @param fontSize An integer specifying the font size of node labels. Defaults to 13.
#' @param nodeWidth An integer specifying the width of the nodes. Defaults to 40.
#' @param nodePadding An integer specifying the padding between nodes. Defaults to 20.
#'
#' @return A Sankey plot object created using the `networkD3` package, which can be rendered in R Markdown or Jupyter Notebooks.
#'
#' @examples
#' \dontrun{
#' sankey_plot(seurat_obj, selected_vars = c("ann_level_1", "ann_level_2"))
#' }
#'
#' @import Seurat
#' @import dplyr
#' @import tidyr
#' @import networkD3
#' @import jsonlite
#' @export
sankey_plot <- function(seurat_obj, 
                          selected_vars = c("ann_level_1", "ann_level_2", "ann_level_3"),
                          plot.title = NULL,
                          custom_colors = list(),  
                          text.size = 14,
                          show_counts = TRUE,
                          show_percentages = TRUE,
                          show_labels = TRUE,
                          label.justify = "left", 
                          label.nudge = 0.1,
                          flow.alpha = 0.5,
                          x.label_position = "top",
                          custom_x.labels = NULL,  
                          show_x_axis = TRUE,
                          prevent_overlap = TRUE) {    
  
  require(Seurat)
  require(dplyr)
  require(ggplot2)
  require(ggsankey)
  require(viridis)  
  
  # Extract metadata
  metadata <- seurat_obj@meta.data
  
  # Ensure selected variables exist
  missing_cols <- setdiff(selected_vars, colnames(metadata))
  if (length(missing_cols) > 0) {
    stop(paste("Error: Missing columns in metadata:", paste(missing_cols, collapse = ", ")))
  }
  
  # Convert data to long format
  df <- metadata %>%
    dplyr::select(all_of(selected_vars)) %>%
    make_long(!!!syms(selected_vars))  
  
  # Calculate total per selected variable level
  dagg <- df %>%
    group_by(x, node) %>%
    tally() %>%
    dplyr::mutate(pct = n / sum(n))  
  
  # Merge back into the main dataframe
  df <- left_join(df, dagg, by = c("x", "node"))
  
  # Unique ID for each node
  df$full_node_name <- paste(df$x, df$node, sep = "_")  
  
  # Build color map
  color_map <- c()
  for (var in selected_vars) {
    if (!is.null(custom_colors[[var]])) {
      color_map <- c(color_map, setNames(custom_colors[[var]], paste(var, names(custom_colors[[var]]), sep = "_")))
    }
  }
  
  # # Default to viridis if no custom colors
  # if (length(color_map) == 0) {
  #   viridis_colors <- viridis::viridis(length(unique(df$full_node_name)))
  #   color_map <- setNames(viridis_colors, unique(df$full_node_name))
  # }
  
  # Default to custom_palette if no custom colors
  if (length(color_map) == 0) {
    n_nodes <- length(unique(df$full_node_name))
    palette_colors <- custom_palette(n_nodes, preset = "base")  # choose any preset you like
    color_map <- setNames(palette_colors, unique(df$full_node_name))
  }
  
  # Check missing nodes
  unique_nodes <- unique(df$full_node_name)
  missing_nodes <- setdiff(unique_nodes, names(color_map))
  if (length(missing_nodes) > 0) {
    stop(paste("Error: Missing colors for nodes:", paste(missing_nodes, collapse = ", ")))
  }
  
  # Assign colors
  color_scale <- scale_fill_manual(values = color_map)
  
  #- ADAPTIVE LABEL COLORS-
  get_text_color <- function(hex_color) {
    rgb_vals <- col2rgb(hex_color) / 255
    brightness <- sum(rgb_vals * c(0.299, 0.587, 0.114))  
    if (brightness > 0.5) "black" else "white"
  }
  df$label_color <- sapply(df$full_node_name, function(name) get_text_color(color_map[name]))
  
  #- Labels-
  df$label <- df$node  
  if (show_labels) {
    if (show_counts & show_percentages) {
      df$label <- paste0(df$node, " n=", df$n, " (", round(df$pct * 100, 2), "%)")
    } else if (show_counts) {
      df$label <- paste0(df$node, " n=", df$n)
    } else if (show_percentages) {
      df$label <- paste0(df$node, " (", round(df$pct * 100, 2), "%)")
    }
  } else {
    df$label <- ""  
  }
  
  # Adjust justification
  hjust_value <- ifelse(label.justify == "left", 1, ifelse(label.justify == "center", 0.5, 0))
  nudge_x_value <- ifelse(label.justify == "left", label.nudge, ifelse(label.justify == "right", -label.nudge, 1))
  
  # Prevent overlap by ordering
  if (prevent_overlap) {
    df <- df %>%
      group_by(x) %>%
      arrange(desc(n)) %>%
      mutate(node = factor(node, levels = unique(node)))
  }
  
  #- Plot-
  pl <- ggplot(df, aes(x = x, next_x = next_x, node = node, next_node = next_node, 
                       fill = full_node_name, label = label)) +
    geom_sankey(flow.alpha = flow.alpha, node.color = "black", show.legend = TRUE) +
    geom_sankey_label(aes(color = I(label_color)), size = 3, 
                      hjust = hjust_value, nudge_x = nudge_x_value) +
    theme_void() +
    theme(legend.position = "none",
          plot.margin = margin(1, 1, 1, 1, "cm"),
          axis.text.x = element_text(color = "black", size = text.size, face = "bold"),
          axis.text.y = element_blank(),
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank()) +
    scale_x_discrete(position = x.label_position) +
    color_scale +
    scale_x_discrete(expand = expansion(mult = c(0.1, 0.6))) +
    labs(title = plot.title, fill = "Nodes")
  
  # Custom x-axis labels
  if (!is.null(custom_x.labels) & length(custom_x.labels) == length(selected_vars)) {
    pl <- pl + scale_x_discrete(labels = custom_x.labels)
  }
  
  # Hide x-axis if needed
  if (!show_x_axis) {
    pl <- pl + theme(axis.text.x = element_blank())
  }
  
  return(pl)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Cell Fractions Over Time
#'
#' This function creates various types of visualizations to display the distribution 
#' of cell types over time using Seurat metadata.
#'
#' @param seurat_obj A Seurat object containing cell metadata.
#' @param x.col Character. The column name in metadata representing the x-axis (e.g., "Age").
#' @param fill.col Character. The column name in metadata representing cell types (e.g., "CellType").
#' @param plot.type Character. Type of plot to generate. Choose from:
#'   - "stacked_area" (default)
#'   - "stacked_bar"
#'   - "grouped_bar"
#'   - "point_smooth"
#'   - "heatmap"
#'   - "ridgeline"
#'   - "line"
#' @param text.size Numeric. Text size for axis labels and titles (default: 10).
#' @param legend.title Character. Custom title for the legend (default: NULL).
#' @param legend.position Character. Position of legend ("right", "bottom", "top", "left") (default: "right").
#' @param legend.ncol Numeric. Number of columns in the legend (default: 1).
#' @param custom.colors Character vector. Custom colors for cell types (default: NULL).
#' @param x.title Character. Custom x-axis title (default: same as `x.col`).
#' 
#' @return A ggplot object.
#' @import ggplot2 dplyr RColorBrewer ggridges scales
#' @export
#' 
#' @examples
#' # Example usage:
#' plot_cell_fractions(seurat_obj, plot.type = "ridgeline")
#' plot_cell_fractions(seurat_obj, plot.type = "stacked_area", text.size = 12)
plot_cell_fractions <- function(seurat_obj, 
                                x.col = "Age", 
                                fill.col = "CellType",
                                plot.type = "stacked_area",
                                text.size = 12,
                                pt.size = 2,
                                line.size = 0.5,
                                legend.title = NULL,
                                legend.position = "right",
                                legend.ncol = 1,
                                custom.colors = NULL,
                                x.title = x.col
) {
  
  # Load necessary libraries
  library(ggplot2)
  library(dplyr)
  library(RColorBrewer)
  library(ggridges)
  library(scales)
  
  # Ensure metadata contains the required columns
  metadata <- seurat_obj@meta.data %>%
    dplyr::select(all_of(c(x.col, fill.col))) %>%
    dplyr::group_by(!!sym(x.col), !!sym(fill.col)) %>%
    dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
    dplyr::group_by(!!sym(x.col)) %>%
    dplyr::mutate(fraction = count / sum(count)) %>%
    dplyr::ungroup()
  
  # Ensure x.col is numeric
  metadata[[x.col]] <- as.numeric(as.character(metadata[[x.col]]))
  
  # Define colors
  num_categories <- length(unique(metadata[[fill.col]]))
  if (is.null(custom.colors)) {
    custom.colors <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_categories), "Set3"))(num_categories)
  }
  
  # Create the plot based on plot type
  if (plot.type == "stacked_area") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_area(position = "stack", alpha = 1, colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "stacked_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "fill", colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "grouped_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = count, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "dodge", colour = "black", size = 0.2) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell Count") +
      theme_classic()
  }
  
  else if (plot.type == "point_smooth") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col))) +
      geom_point(size = pt.size) +
      geom_smooth(method = "loess", se = FALSE, size = line.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "heatmap") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), fill = fraction)) +
      geom_tile() +
      viridis::scale_fill_viridis_c(option = "plasma") +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_minimal()
  }
  
  else if (plot.type == "ridgeline") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), height = fraction, fill = !!sym(fill.col))) +
      geom_density_ridges(stat = "identity", scale = 1.5, alpha = 0.7) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_classic()
  } else if (plot.type == "line") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col), group = !!sym(fill.col))) +
      geom_line(size = line.size) + 
      geom_point(size = pt.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  } else {
    stop("Invalid plot type. Choose from: stacked_area, stacked_bar, grouped_bar, point_smooth, heatmap, line, ridgeline.")
  }
  
  # Adjust theme settings
  p <- p +
    theme(
      plot.title = element_text(size = text.size + 2, face = "bold", hjust = 0.5),
      axis.title = element_text(size = text.size),
      axis.text = element_text(size = text.size, color = "black"),
      legend.key.size = unit(0.4, 'cm'),
      legend.text = element_text(size = text.size-1),
      legend.position = legend.position,
      legend.spacing.y = unit(0.05, 'cm'),  # Reduce space between legend items
      legend.margin = margin(t = -10, b = 0, unit = 'pt') # Reduce space between plot and legend
    ) +
    guides(fill = guide_legend(
      ncol = legend.ncol, 
      override.aes = list(color = "black", size = 0.5) 
    ))
  
  return(p)
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Generate a Correlation Heatmap and Text Summary
#'
#' This function creates a correlation heatmap for cell clusters based on average expression values 
#' and provides a text summary describing the results.
#'
#' @param object A Seurat object containing the single-cell expression data.
#' @param group.by A metadata variable to group cells by. Default is "seurat_clusters".
#' @param fontsize Font size for the heatmap text. Default is 8.
#'
#' @return A list containing the heatmap object and a text summary.
#' @examples
#' # Example usage:
#' # result <- Heatmap_Correlation(seurat_obj, group.by = "cell_type", fontsize = 10)
#' # result$heatmap  # To visualize the heatmap
#' # result$summary  # To view the text summary
#'
#' @export
#' 
plot_cluster_correlation <- function(object, 
                                     group.by = "seurat_clusters",
                                     assay = "RNA", 
                                     slot = "data",  # Specify layer for Seurat v5
                                     plot.title = NULL,
                                     column_names_rot = 45,
                                     fontsize = 10,
                                     pdf_width = 5,
                                     pdf_height = 6,
                                     fig_name) {
  
  require(Seurat)
  require(ComplexHeatmap)
  require(RColorBrewer)
  
  # Ensure the assay exists in the object
  # if (!(assay %in% Assays(object))) {
  #   stop(paste("âŒ Assay", assay, "not found in the Seurat object."))
  # }
  
  # Set identity class based on the group.by column
  if (!group.by %in% colnames(object@meta.data)) {
    stop(paste("âŒ Column", group.by, "not found in metadata."))
  }
  
  Idents(object) <- object@meta.data[[group.by]]
  
  # Extract unique cluster identities
  uniq <- unique(Idents(object))
  
  # Extract expression data
  if (packageVersion("Seurat") >= "5.0.0") {
    expr_data <- object[[assay]][slot] # Seurat v5 fix
  } else {
    expr_data <- GetAssayData(object, slot = slot, assay = assay)  # Seurat v4
  }
  
  # Initialize an empty matrix with correct dimensions
  mnmat <- matrix(NA, nrow = nrow(expr_data), ncol = length(uniq))
  
  # Iterate over each cluster and compute the average expression
  for (i in seq_along(uniq)) {
    cluster_cells <- WhichCells(object, idents = uniq[i])
    
    # âœ… Check if the cluster contains valid cells
    valid_cells <- cluster_cells[cluster_cells %in% colnames(expr_data)]
    
    if (length(valid_cells) > 0) {
      mnmat[, i] <- Matrix::rowMeans(expr_data[, valid_cells, drop = FALSE])
    }
  }
  
  colnames(mnmat) <- as.vector(uniq)
  
  # Compute Pearson correlation matrix
  mat <- cor(mnmat, method = "pearson", use = "complete.obs")
  
  # Generate heatmap
  ht <- Heatmap(
    mat,
    name = 'Pearson correlation',
    #col = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100), # Red-Blue gradient
    col = viridis::viridis(100),
    border = "#8B8B8C",
    rect_gp = gpar(col = "#8B8B8C"),
    row_names_gp = gpar(fontsize = fontsize),  
    column_names_gp = gpar(fontsize = fontsize, fontface = "plain"),
    column_names_side = "bottom",
    column_names_rot = column_names_rot,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = TRUE,
    show_column_names = TRUE,
    show_column_dend = TRUE,
    show_row_dend = TRUE,
    heatmap_legend_param = list(
      title = 'Pearson correlation',
      title_position = 'leftcenter-rot',
      legend_height = unit(3.5, 'cm'),
      legend_width = unit(0.5, 'cm'),
      border = '#8B8B8C',
      #legend.direction = 'horizontal',
      labels_gp = gpar(fontsize = fontsize)
    )
  )
  
  save_heatmap(
    ht = ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right"),
    filename = file.path(dir.results, fig_name),
    formats = c("pdf", "png", "tiff"),
    width = pdf_width,
    height = pdf_height
  )
  
  # Draw heatmap with title
  ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
  grid::grid.text(
    plot.title,
    x = 0.5, y = unit(1, "npc") - unit(2, "mm"),
    gp = gpar(fontsize = fontsize + 2, fontface = "bold")
  )
  
  return(ht)
}



plot_cluster_correlation_spatial <- function(
    object,
    group.by = "seurat_clusters",
    reduction = "umap",       # or "harmony"
    expr.assay = NULL,
    expr.slot = "data",
    k = 3,                    # neighbors for graph
    plot.title = NULL,
    fontsize = 8,
    column_names_rot = 45
) {
  require(Seurat)
  require(ComplexHeatmap)
  require(igraph)
  require(FNN)
  require(viridis)
  
  ## identities
  Idents(object) <- object@meta.data[[group.by]]
  clusters <- unique(Idents(object))
  
  ## expression assay
  if (is.null(expr.assay)) expr.assay <- DefaultAssay(object)
  if (packageVersion("Seurat") >= "5.0.0") {
    expr.data <- object[[expr.assay]]@layers[[expr.slot]]
  } else {
    expr.data <- GetAssayData(object, assay = expr.assay, slot = expr.slot)
  }
  
  ## average expression per cluster
  avg.mat <- sapply(clusters, function(cl) {
    cells <- WhichCells(object, idents = cl)
    cells <- intersect(cells, colnames(expr.data))
    Matrix::rowMeans(expr.data[, cells, drop = FALSE])
  })
  colnames(avg.mat) <- as.character(clusters)
  
  ## correlation matrix
  corr <- cor(avg.mat)
  
  ## PATIAL CLUSTER ORDERING USING MST 
  
  ## get UMAP/Harmony embeddings
  emb <- Embeddings(object, reduction = reduction)
  
  ## compute cluster centroids
  centroids <- t(sapply(clusters, function(cl) {
    cells <- WhichCells(object, idents = cl)
    colMeans(emb[cells, , drop = FALSE])
  }))
  
  ## KNN graph between centroids
  knn <- get.knn(centroids, k = k)
  edges <- do.call(rbind, lapply(1:nrow(centroids), function(i) {
    data.frame(from = i, to = knn$nn.index[i, ])
  }))
  
  ## build graph
  g <- graph_from_data_frame(edges, directed = FALSE)
  
  ## add distances
  E(g)$weight <- apply(edges, 1, function(e) {
    i <- e["from"]; j <- e["to"]
    sqrt(sum((centroids[i,] - centroids[j,])^2))
  })
  
  ## compute MST
  mst <- mst(g)
  
  ## order nodes along MST path
  order_vec <- names(sort(betweenness(mst)))  # simple linearization
  
  ## reorder correlation matrix
  corr.ordered <- corr[order_vec, order_vec]
  
  ## HEATMAP 
  ht <- Heatmap(
    corr.ordered,
    name = "Pearson correlation",
    col = viridis(100),
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_gp = gpar(fontsize = fontsize),
    column_names_gp = gpar(fontsize = fontsize),
    column_names_rot = column_names_rot,
    border = "#8B8B8C"
  )
  draw(ht)
  
  if (!is.null(plot.title)) {
    grid::grid.text(plot.title,
                    x = 0.5,
                    y = unit(1, "npc") - unit(2, "mm"),
                    gp = gpar(fontsize = fontsize+2, fontface = "bold"))
  }
}



#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Marker Positivity Percentage Before/After DecontX
#'
#' This function reproduces the logic of
#' \code{plotDecontXMarkerPercentage()} but allows you to group cells
#' using any \code{colData(sce)} column (e.g., \code{ann_level_2})
#' rather than being restricted to \code{decontX_clusters}.
#'
#' It computes the percentage of cells expressing one or more markers
#' (above a given threshold) and visualizes these percentages for one
#' or multiple assays (e.g. raw counts vs DecontX-cleaned counts).
#'
#' @param sce A \code{SingleCellExperiment} object containing counts and,
#' optionally, DecontX-cleaned counts.
#' @param markers A character vector of gene names to evaluate. Genes
#' not present in \code{rownames(sce)} are dropped automatically.
#' @param group_by Column name in \code{colData(sce)} to group cells by
#' (e.g., cell type annotation).
#' @param assays Character vector of assay names to compare, typically
#' \code{c("counts", "decontXcounts")}.
#' @param expr_threshold Numeric expression threshold. Cells with
#' \code{expr > expr_threshold} are considered positive for that marker.
#' Default = 1.
#' @param plot_type Either \code{"bar"} (default) or \code{"heatmap"}.
#' @details
#' For each marker and each group, the percentage of positive cells is:
#'
#' \deqn{
#' 100 * \frac{\sum(expr > threshold)}{N_{\text{cells in group}}}
#' }
#'
#' @return A list with:
#' \describe{
#'   \item{table}{A data.frame of marker positivity percentages.}
#'   \item{plot}{A ggplot2 object showing the result.}
#' }
#'
#' @examples
#' \dontrun{
#' res <- plot_decontx_marker_percent(
#'   sce = clean$sce,
#'   markers = c("XIST","UTY","HBB"),
#'   group_by = "ann_level_2",
#'   assays = c("counts","decontXcounts"),
#'   plot_type = "bar"
#' )
#' res$plot
#' }
#'
#' @export
plot_decontx_marker_percent <- function(
    sce,
    markers,
    group_by = "ann2",
    assays = c("counts", "decontXcounts"),
    expr_threshold = 1,
    plot_type = c("bar","heatmap"),
    theme = "bw",
    fontsize = 10,
    x.angle = 45,
    x.lab = NULL,
    ncol = NULL,
    leg.pos = "right",
    leg.dir = "vertical",
    custom_colors = NULL,
    ...
){
  require(SingleCellExperiment)
  require(Matrix)
  require(dplyr)
  require(tidyr)
  require(ggplot2)
  
  plot_type <- match.arg(plot_type)
  
  if (!group_by %in% colnames(colData(sce))) {
    stop("group_by must be a column in colData(sce)")
  }
  
  # Check markers exist
  markers <- intersect(markers, rownames(sce))
  if (length(markers) == 0) stop("No markers found in SCE")
  
  # Build results table
  res_list <- list()
  
  for (assay_name in assays) {
    if (!assay_name %in% assayNames(sce))
      stop(paste("Assay", assay_name, "not found in sce"))
    
    mat <- assay(sce, assay_name)
    
    df <- lapply(markers, function(m){
      expr <- mat[m, ]
      is_pos <- as.numeric(expr > expr_threshold)
      
      data.frame(
        cell   = colnames(sce),
        group  = colData(sce)[[group_by]],
        marker = m,
        pos    = is_pos
      )
    }) %>% bind_rows()
    
    perc <- df %>%
      group_by(group, marker) %>%
      summarise(
        pct = mean(pos) * 100,
        .groups = "drop"
      ) %>%
      mutate(assay = assay_name)
    
    res_list[[assay_name]] <- perc
  }
  
  out <- bind_rows(res_list)
  
  # If custom_colors is NULL, assign default
  if (is.null(custom_colors)) {
    custom_colors <- c("counts" = "#E69F00", "decontXcounts" = "#56B4E9")
  }
  
  # PLOTS
  if (plot_type == "bar") {
    # BAR
    p <- ggplot(out, aes(x = group, y = pct, fill = assay)) +
      geom_bar(stat = "identity", position = "dodge",
               color = "black", linewidth = 0.2) +
      facet_wrap(~ marker, scales = "free_y", ncol = ncol) +
      plot_theme(theme = theme, font.size = fontsize, x.angle = x.angle, 
                 leg.pos = leg.pos, leg.dir = leg.dir,...) +
      labs(y = "% cells expressing", x = x.lab) +
      scale_fill_manual(values = custom_colors)
    
  } else if (plot_type == "heatmap") {
    # HEATMAP
    p <- ggplot(out, aes(x = marker, y = group, fill = pct)) +
      geom_tile() +
      facet_wrap(~ assay, ncol = ncol) +
      scale_fill_viridis_c() +
      plot_theme(theme = theme, font.size = fontsize, x.angle = x.angle, 
                 leg.pos = leg.pos, leg.dir = leg.dir,...) +
      labs(fill = "% positive", x = "Marker", y = group_by)
  }
  
  return(list(
    table = out,
    plot  = p
  ))
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Sex Chromosome QC
#'
#' Visualizes expression of X and Y chromosome marker genes per sample to assess sex
#' contamination and discordance in single-cell RNA-seq data. Optionally highlights
#' discordant cells flagged by `sex_contamination_qc()`.
#'
#' @param obj A \code{Seurat} object with RNA assay and metadata containing \code{sex_call} 
#' and optionally \code{sex_discordant} columns (as generated by `sex_contamination_qc()`).
#' @param genes Character vector of marker genes to plot. Default: c("XIST","UTY").
#' @param sample_col Character. Column in \code{obj@meta.data} specifying sample identity. Default: "sample".
#' @param highlight_discordant Logical. If TRUE, discordant cells are highlighted in black. Default: TRUE.
#' @param pt_size Numeric. Size of points in jitter overlay. Default: 0.5.
#' @param fontsize Numeric. Base font size for the plot. Default: 14.
#' @param palette Named character vector of colors for sex calls. Must include "female_like", "male_like", and "ambiguous". Default: c(female_like="#b15928", male_like="#6a3d9a","ambiguous"="gray70").
#'
#' @return A ggplot object displaying violin plots of normalized expression per sample for each gene.
#'
#' @details
#' This function generates violin plots for key sex chromosome markers (e.g., XIST, UTY)
#' across samples. Cells can be colored by sex call and discordant cells highlighted.
#' Useful for visual QC of sex assignment after sex contamination analysis.
#'
#' @examples
#' \dontrun{
#' qc_res <- sex_contamination_qc(obj)
#' p <- plot_sex_qc(qc_res$object)
#' print(p)
#' }
#'
#' @export
plot_sex_qc <- function(
    obj,
    genes = c("XIST","UTY"),
    sample_col = "sample",
    highlight_discordant = TRUE,
    pt_size = 0.5,
    fontsize = 14,
    palette = c("Female-like"="#b15928"," Male-like"="#6a3d9a","Ambiguous"="gray70")
){
  library(Seurat)
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  
  # Ensure RNA assay
  DefaultAssay(obj) <- "RNA"
  expr <- GetAssayData(obj, slot="data")[genes, , drop=FALSE] %>% t() %>% as.data.frame()
  expr$cell <- rownames(expr)
  
  # Add metadata
  meta <- obj@meta.data %>% 
    dplyr::select(all_of(sample_col), sex_call, sex_discordant) %>%
    dplyr::mutate(cell = rownames(.))
  
  df <- expr %>% 
    tidyr::pivot_longer(cols = all_of(genes), names_to = "gene", values_to = "expression") %>%
    dplyr::left_join(meta, by="cell")
  
  # Discordant coloring
  if(highlight_discordant & "sex_discordant" %in% colnames(df)){
    df$color_group <- ifelse(df$sex_discordant, "discordant", df$sex_call)
    palette <- c(palette, discordant="black")
  } else {
    df$color_group <- df$sex_call
  }
  
  p <- ggplot(df, aes(x=.data[[sample_col]], y=expression, fill=color_group)) +
    geom_violin(scale="width", trim=TRUE, adjust=1) +
    geom_jitter(width=0.1, size=pt_size, alpha=0.5) +
    facet_wrap(~gene, scales="free_y") +
    scale_fill_manual(values=palette, name="Sex Call") +
    plot_theme(theme = "classic", font.size=fontsize, x.angle = 45, legend.position = "top", legend.direction = "horizontal") +
    labs(x="Sample", y="Normalized expression", title="Sex Chromosome QC")
  
  return(p)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Generate QC plots for sex and erythroid contamination
#'
#' @param meta_df Metadata data frame from Seurat object (with sex_score, sex_call, eryth_sum)
#' @param tbl_summary Summary table per sample (n_cells, n_removed, median_eryth_sum)
#' @param theme ggplot theme type
#' @param font.size Base font size
#' @param x.angle Angle of x-axis labels
#' @param out_dir Optional directory to save plots
#'
#' @return List of ggplot objects
#' @export
plot_sex_eryth_qc <- function(meta_df, tbl_summary,
                              eryth_genes = c("HBB","HBA1","HBA2","ALAS2"),  # default markers
                              theme = "classic",
                              font.size = 8,
                              x.angle = 45,
                              out_dir = NULL) {
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  meta_df = obj@meta.data
  # Ensure eryth_sum exists
  # Ensure eryth_sum exists and is numeric
  if(!"eryth_sum" %in% colnames(meta_df)) {
    available_genes <- intersect(eryth_genes, colnames(meta_df))
    if(length(available_genes) > 0) {
      meta_df$eryth_sum <- rowSums(meta_df[, available_genes, drop=FALSE])
    } else {
      meta_df$eryth_sum <- NA
    }
  }
  # Convert to numeric in case it is factor/character
  meta_df$eryth_sum <- as.numeric(meta_df$eryth_sum)
  
  
  # 1) Sex classification fraction barplot
  df_sex_long <- tbl_summary %>%
    dplyr::select(sample, frac_female_like, frac_male_like, frac_ambiguous) %>%
    tidyr::pivot_longer(
      cols = starts_with("frac_"),
      names_to = "sex_class",
      values_to = "fraction"
    ) %>%
    mutate(sex_class = recode(sex_class,
                              frac_female_like="Female-like",
                              frac_male_like="Male-like",
                              frac_ambiguous="Ambiguous"))
  
  p1 <- ggplot(df_sex_long, aes(x=sample, y=fraction, fill=sex_class)) +
    geom_col(width=0.8, color="black", linewidth=0.2) +
    scale_fill_manual(values=c("Male-like" = "#6a3d9a", "Female-like" = "#b15928","Ambiguous" = "gray60"),
                      breaks = c("Female-like","Male-like","Ambiguous")) +
    plot_theme(theme = theme, x.angle=x.angle, font.size = font.size) +
    labs(#title = "Sex classification per sample",
      x = "", y = "Fraction of cells", fill = "Sex call")
  
  # 2) Sex score histogram
  p2 <- ggplot(meta_df, aes(x=sex_score, fill=sex_call)) +
    geom_histogram(bins=80, alpha=1) +
    scale_fill_manual(values=c("Male-like" = "#6a3d9a", "Female-like" = "#b15928","Ambiguous" = "gray60")) +
    plot_theme(theme = theme, font.size=font.size, x.angle=0, leg.pos = c(0.2, 0.85)) +
    labs(x="Log2(XIST / Y genes)", y="Number of cells", fill="Sex call")
  
  # 3) Erythroid gene sum histogram
  p3 <- ggplot(meta_df, aes(x=eryth_sum)) +
    geom_histogram(bins=80, fill="steelblue", alpha=1) +
    plot_theme(theme = theme, font.size = font.size) +
    labs(x="Erythroid gene sum", y="Number of cells")
  
  # 4) Median erythroid sum per sample
  p4 <- ggplot(tbl_summary, aes(x=sample, y=median_eryth_sum)) +
    geom_col(fill="tomato", color="black", linewidth=0.2) +
    plot_theme(theme = theme, font.size = font.size, x.angle=x.angle) +
    labs(x="Sample", y="Median erythroid sum")
  
  # 5) Cells before/after QC per sample (dodge bars)
  tbl2 <- tbl_summary %>%
    dplyr::mutate(n_before = n_cells,
           n_after  = n_before - n_removed) %>%
    dplyr::select(sample, n_before, n_after) %>%
    tidyr::pivot_longer(cols = c(n_before, n_after),
                 names_to = "stage",
                 values_to = "n_cells") %>%
    dplyr::mutate(stage = recode(stage, n_before="Pre-sex-QC", n_after="Post-sex-QC"),
                  stage = factor(stage, levels = c("Pre-sex-QC","Post-sex-QC")))  # enforce order
  
  p5 <- ggplot(tbl2, aes(x=sample, y=n_cells, fill=stage)) +
    geom_col(position = position_dodge(width = 0.6), color="black", width=0.6, linewidth=0.2) +
    scale_fill_manual(values = c("Pre-sex-QC"="#151A1F","Post-sex-QC"="#8CB9E6"),
                      breaks = c("Pre-sex-QC","Post-sex-QC")) +
    plot_theme(theme = theme, font.size=font.size, x.angle=x.angle, leg.pos = c(0.2, 0.9)) +
    labs(x="Sample", y="Number of cells", fill="Stage")
  
  # Save plots if out_dir is provided
  if(!is.null(out_dir)) {
    if(!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
    ggsave(file.path(out_dir, "Sex_class.pdf"), p1, width=5, height=4)
    ggsave(file.path(out_dir, "sex_score_hist.pdf"), p2, width=4, height=4)
    ggsave(file.path(out_dir, "eryth_sum_hist.pdf"), p3, width=4, height=4)
    ggsave(file.path(out_dir, "median_eryth_per_sample.pdf"), p4, width=4, height=4)
    ggsave(file.path(out_dir, "sex_cells_before_after_qc.pdf"), p5, width=4, height=4)
  }
  
  return(list(
    sex_class_fraction = p1,
    sex_score_hist = p2,
    eryth_sum_hist = p3,
    median_eryth = p4,
    cells_before_after = p5
  ))
}

#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot Trajectory with Slingshot Lineages and Cluster Centroids
#'
#' Generates a base R scatter plot of cells in a reduced dimension space (e.g., UMAP),
#' colors cells by cluster, overlays Slingshot-inferred lineages, and annotates
#' cluster centroids. Labels have a white outline for better visibility.
#'
#' @param dim.red Numeric matrix. Reduced dimensional embeddings (rows = cells, columns = dimensions).
#' @param palettes Vector of colors for each cell, typically by cluster.
#' @param lineages Slingshot lineage object returned by `slingshot::SlingshotDataSet()`.
#' @param centroids Data frame or matrix with cluster centroids. Columns: 1 = label, 2 = x, 3 = y.
#' @param font.size Numeric, optional. Font size of cluster centroid labels. Default is 1.5.
#'
#' @return A quoted expression containing the base R plotting code. Use `eval()` to render.
#' @importFrom plotrix thigmophobe.labels
#' @export
#' 
plot_trajectory <- function(
    dim.red, palettes, lineages, centroids,
    font.size = 1.5,
    pt.size = 0.8   # <-- new argument
){
  
  p <- bquote({
    
    ## Base scatter plot
    plot(.(dim.red),
         col = .(palettes),
         pch = 16,
         cex = .(pt.size),   
         xlab = "", ylab = "",
         axes = FALSE)
    
    ## Slingshot lineages
    lines(.(lineages),
          lwd = 2,
          type = "lineages",
          col = "black",
          show.constraints = TRUE)
    
    ## Extract centroid coordinates
    x <- .(centroids)[, 2]
    y <- .(centroids)[, 3]
    lab <- .(centroids)[, 1]
    
    ## White outline labels
    plotrix::thigmophobe.labels(
      x = x, y = y, labels = lab,
      font = 4,
      cex = .(font.size) * 1.1,
      col = "white",
      plot = TRUE, xpd = TRUE
    )
    
    ## Foreground labels
    plotrix::thigmophobe.labels(
      x = x, y = y, labels = lab,
      font = 4,
      cex = .(font.size),
      col = "black",
      plot = TRUE, xpd = TRUE
    )
  })
  
  return(p)
}



#' Plot Slingshot Lineages on a Dimensional Reduction (UMAP/TSNE/PCA)
#'
#' @description
#' This function visualizes Slingshot lineages on top of a dimensionality 
#' reduction (e.g., UMAP). Cells can be colored by cluster identity or pseudotime.
#' The function supports plotting a subset of lineages, faceting by lineage,
#' customizing color palettes, and adding cluster/lineage labels.
#'
#' @param obj A Seurat object containing the specified reduction.
#' @param sds A \code{SlingshotDataSet} object containing lineage and 
#'   pseudotime information.
#' @param cluster_col Metadata column in \code{obj} used for cluster coloring.
#' @param reduction Dimensional reduction to use (default: \code{"umap"}).
#' @param dims Vector of two integers specifying which dimensions to plot.
#' @param pt.size Point size for cell embeddings.
#' @param cluster_palette Optional named vector of colors for clusters.
#' @param lineage_colors Optional vector of colors for individual lineages.
#'   If NULL, defaults will be generated.
#' @param base.size Base font size for the plot theme.
#' @param show_cluster_labels Logical; if TRUE, cluster text labels are shown.
#' @param show_lineage_labels Logical; if TRUE, labels per lineage are shown.
#' @param label.size Text size for cluster/lineage labels.
#' @param label.fontface Fontface for text labels (e.g., \code{"bold"}).
#' @param legend.position Position of ggplot legend (e.g., \code{"right"}).
#' @param plot.title Optional title for the plot.
#' @param fig.plot Logical; if TRUE, the plot is displayed. If FALSE, it is returned.
#' @param font.size Global font size for text elements.
#' @param color.by One of \code{"cluster"} or \code{"pseudotime"} indicating
#'   how cells should be colored.
#' @param lineage.select Optional vector specifying which lineages to plot
#'   (e.g., \code{c("Lineage1", "Lineage3")}).
#' @param facet.by.lineage Logical; if TRUE, each lineage is plotted in a facet.
#' @param pt.lim Optional numeric vector of length 2 specifying pseudotime limits
#'   for color scaling when \code{color.by = "pseudotime"}.
#'
#' @return A ggplot2 object. If \code{fig.plot = TRUE}, the plot is also displayed.
#'
#'#' @examples
#' \dontrun{
#' library(Seurat)
#' library(slingshot)
#'
#' # Example dataset
#' data("pbmc_small")
#' obj <- pbmc_small
#'
#' # Run PCA and UMAP
#' obj <- RunPCA(obj, verbose = FALSE)
#' obj <- RunUMAP(obj, dims = 1:10, verbose = FALSE)
#'
#' # Convert to SingleCellExperiment for Slingshot
#' sce <- as.SingleCellExperiment(obj)
#'
#' # Run Slingshot on PCA embedding
#' sce <- slingshot(
#'   sce,
#'   clusterLabels = "RNA_snn_res.1",
#'   reducedDim = "PCA"
#' )
#'
#' # Extract SlingshotDataSet
#' sds <- SlingshotDataSet(sce)
#'
#' # Basic usage
#' plot_lineages(
#'   obj = obj,
#'   sds = sds,
#'   plot.title = "Slingshot lineages on UMAP"
#' )
#'
#' # Color cells by pseudotime
#' plot_lineages(
#'   obj = obj,
#'   sds = sds,
#'   color.by = "pseudotime",
#'   lineage.select = "Lineage1"
#' )
#'
#' # Show cluster and lineage labels
#' plot_lineages(
#'   obj = obj,
#'   sds = sds,
#'   show_cluster_labels = TRUE,
#'   show_lineage_labels = TRUE
#' )
#'
#' # Facet each lineage separately
#' plot_lineages(
#'   obj = obj,
#'   sds = sds,
#'   facet.by.lineage = TRUE
#' )
#' }
#' @export
#' 
plot_lineages <- function(
    obj,
    sds,
    cluster_col = "ann_level_2",
    reduction = "umap",
    dims = c(1,2),
    pt.size = 0.5,
    cluster_palette = NULL,
    lineage_colors = NULL,
    base.size = 14,
    show_cluster_labels = FALSE,
    show_lineage_labels = FALSE,
    show_lineages = TRUE,
    lineage_rename = NULL,
    label.size = 4,
    theme = "classic",
    label.fontface = "bold",
    legend.position = "right",
    plot.title = NULL,
    fig.plot = TRUE,
    no.axes = FALSE,
    font.size = 8,
    alpha = 0.8,
    linewidth = 1,
    color.by = c("cluster", "pseudotime"),
    lineage.select = NULL,
    facet.by.lineage = FALSE,
    pt.lim = NULL
) {
  
  require(ggplot2)
  require(dplyr)
  require(mgcv)
  require(ggrepel)
  require(patchwork)
  require(viridis)
  
  color.by <- match.arg(color.by)
  
  # Base UMAP coordinates
  umap.df <- as.data.frame(Embeddings(obj, reduction))
  umap.df$cluster <- obj[[cluster_col, drop = TRUE]]
  colnames(umap.df)[dims[1]] <- "UMAP1"
  colnames(umap.df)[dims[2]] <- "UMAP2"
  
  # Handle pseudotime matrix
  if (!is.null(sds)) {
    pt.mat <- slingPseudotime(sds)
    lineage.names <- colnames(pt.mat)
    
    if (!is.null(lineage.select)) {
      pt.mat <- pt.mat[, lineage.select, drop = FALSE]
      lineage.names <- colnames(pt.mat)
    }
    
    # Short lineage labels
    lineage_label_short <- paste0("Lin", seq_len(ncol(pt.mat)))
    names(lineage_label_short) <- lineage.names
  }
  
  # Short lineage labels
  lineage_label_short <- paste0("Lin", seq_len(ncol(pt.mat)))
  names(lineage_label_short) <- lineage.names
  
  # --- NEW: Optional user-specified renaming ---
  if (!is.null(lineage_rename)) {
    # lineage_rename should be a *named vector*: c(old = "new")
    valid_rename <- intersect(names(lineage_rename), lineage.names)
    if (length(valid_rename) > 0) {
      lineage_label_short[valid_rename] <- lineage_rename[valid_rename]
    }
  }
  
  # Color points
  if (color.by == "cluster") {
    if (is.null(cluster_palette)) {
      cluster_palette <- RColorBrewer::brewer.pal(
        min(12, length(unique(umap.df$cluster))), "Set3"
      )
      names(cluster_palette) <- unique(umap.df$cluster)
    }
    umap.df$color_value <- umap.df$cluster
    color_scale <- scale_color_manual(values = cluster_palette)
    
  } else if (color.by == "pseudotime") {
    # If no specific lineage is selected, combine all pseudotimes
    if (is.null(lineage.select)) {
      # Average pseudotime across lineages (like in plot_slingshot_umap)
      umap.df$color_value <- rowMeans(pt.mat, na.rm = TRUE)
      pt.lim <- range(umap.df$color_value, na.rm = TRUE)
      
    } else {
      # Existing behavior for a single lineage
      umap.df$color_value <- pt.mat[, lineage.select]
      if (is.null(pt.lim)) pt.lim <- range(umap.df$color_value, na.rm = TRUE)
    }
    
    color_scale <- scale_color_viridis(
      option = "C",
      limits = pt.lim,
      na.value = "grey80",
      name = "Pseudotime",
      guide = guide_colorbar(
        direction = "vertical",
        title.position = "left",
        title.hjust = 0.5,
        frame.colour = "black",
        frame.linewidth = 0.2,
        title.theme = element_text(angle = 90, vjust = 0.5),
        barheight = 5,
        barwidth = 0.8
      )
    )
    
    legend.position <- "right"
  }
  
  # Faceting by lineage
  if (facet.by.lineage && !is.null(sds)) {
    facet.df <- umap.df
    facet.df$lineage <- NA
    for (i in seq_len(ncol(pt.mat))) {
      pts <- pt.mat[, i]
      facet.df$lineage[!is.na(pts)] <- lineage_label_short[lineage.names[i]]
    }
    p <- ggplot(facet.df, aes(UMAP1, UMAP2, color = color_value)) +
      geom_point(size = pt.size, alpha = alpha) +
      color_scale +
      theme_void(base_size = font.size) +
      facet_wrap(~ lineage, ncol = 2) +
      theme(
        strip.text = element_text(size = base.size, face = "bold"),
        legend.position = legend.position
      ) +
      labs(title = plot.title)
    return(p)
  }
  
  # Base plot (points)
  plt <- ggplot(umap.df, aes(x = UMAP1, y = UMAP2, color = color_value)) +
    geom_point(size = pt.size, alpha = alpha) +
    color_scale +
    plot_theme(theme = theme) +
    labs(title = plot.title) +
    theme(legend.position = legend.position)
  
  # Lineages
  if (!is.null(sds) && show_lineages) {
    if (is.null(lineage_colors)) lineage_colors <- viridis::viridis(ncol(pt.mat))
    
    for (i in seq_len(ncol(pt.mat))) {
      df_lineage <- umap.df
      df_lineage$pt <- pt.mat[, i]
      df_lineage <- df_lineage %>% filter(!is.na(pt))
      
      if (nrow(df_lineage) > 20) {
        g1 <- mgcv::gam(UMAP1 ~ s(pt, k = 20), data = df_lineage)
        g2 <- mgcv::gam(UMAP2 ~ s(pt, k = 20), data = df_lineage)
        grid <- seq(min(df_lineage$pt), max(df_lineage$pt), length.out = 200)
        
        curve_df <- data.frame(
          UMAP1 = predict(g1, newdata = data.frame(pt = grid)),
          UMAP2 = predict(g2, newdata = data.frame(pt = grid))
        )
        
        # Lineage curves behind points
        plt <- plt + geom_path(
          data = curve_df,
          aes(UMAP1, UMAP2),
          color = lineage_colors[i],
          linewidth = linewidth,
          inherit.aes = FALSE
        )
        
        # Lineage labels
        if (show_lineage_labels) {
          end.pt <- curve_df[nrow(curve_df), , drop = FALSE]
          end.pt$label <- lineage_label_short[lineage.names[i]]
          plt <- plt + ggrepel::geom_text_repel(
            data = end.pt,
            aes(UMAP1, UMAP2, label = label),
            color = lineage_colors[i],
            fontface = label.fontface,
            size = label.size,
            bg.color = "grey95",
            bg.r = 0.1,
            seed = 42
          )
        }
      }
    }
  }
  
  # Cluster labels on top
  if (show_cluster_labels && color.by == "cluster") {
    centroids <- umap.df %>% group_by(cluster) %>%
      summarise(UMAP1 = mean(UMAP1), UMAP2 = mean(UMAP2))
    plt <- plt + ggrepel::geom_text_repel(
      data = centroids,
      aes(UMAP1, UMAP2, label = cluster),
      size = label.size,
      color = "black",
      fontface = label.fontface,
      bg.color = "grey95",
      bg.r = 0.1,
      seed = 42
    )
  }
  
  if (no.axes) plt <- plt & NoAxes()
  
  # Optional axis arrows
  if (fig.plot) {
    x.lab.reduc <- plt$labels$x %||% paste0(toupper(reduction), dims[1])
    y.lab.reduc <- plt$labels$y %||% paste0(toupper(reduction), dims[2])
    plt <- plt & NoAxes()
    
    L <- 0.12
    axis.df <- data.frame(x0 = c(0,0), y0 = c(0,0), x1 = c(L,0), y1 = c(0,L))
    axis.plot <- ggplot(axis.df) +
      geom_segment(aes(x=x0,y=y0,xend=x1,yend=y1),
                   linewidth=0.6,lineend="round") +
      xlab(x.lab.reduc) + ylab(y.lab.reduc) +
      coord_fixed() + theme_classic(base_size=font.size) +
      theme(plot.background=element_rect(fill="transparent",colour=NA),
            panel.background=element_rect(fill="transparent",colour=NA),
            axis.text=element_blank(), axis.ticks=element_blank(),
            axis.line=element_blank(), panel.border=element_blank(),
            axis.title=element_text(size=font.size, face="bold"),
            plot.margin=margin(0,0,0,0))
    
    figure.layout <- c(
      patchwork::area(t = 1, l = 1, b = 11, r = 11),
      patchwork::area(t = 10, l = 1, b = 11, r = 2)
    )
    
    return(plt + axis.plot + patchwork::plot_layout(design = figure.layout))
  }
  
  return(plt)
}



plot_slingshot_umap <- function(
    res,
    palette,
    mode = c("clusters", "pseudotime", "none"),
    point_size = 0.3,
    curve_size = 1.4,
    alpha = 0.7,
    label_root_terminal = TRUE
){
  library(ggplot2)
  library(dplyr)
  
  mode <- match.arg(mode)
  
  # Extract metadata
  umap_df <- as.data.frame(res$seurat@reductions$umap@cell.embeddings)
  colnames(umap_df) <- c("UMAP1", "UMAP2")
  
  clusters <- res$seurat$ann_level_2
  pt <- res$pseudotime
  
  df <- data.frame(
    UMAP1 = umap_df$UMAP1,
    UMAP2 = umap_df$UMAP2,
    cluster = clusters,
    pseudotime = rowMeans(pt, na.rm = TRUE)
  )
  
  # Base plot depending on selected mode
  if (mode == "clusters") {
    gg <- ggplot(df, aes(UMAP1, UMAP2, color = cluster)) +
      geom_point(size = point_size, alpha = alpha) +
      scale_color_manual(values = palette)
    
  } else if (mode == "pseudotime") {
    gg <- ggplot(df, aes(UMAP1, UMAP2, color = pseudotime)) +
      geom_point(size = point_size, alpha = alpha) +
      scale_color_viridis_c()
    
  } else if (mode == "none") {
    gg <- ggplot(df, aes(UMAP1, UMAP2)) +
      geom_point(color = "gray80", size = point_size, alpha = alpha)
  }
  
  gg <- gg + theme_void() + theme(legend.position = "none")
  
  # Add lineage curves (each in different color)
  lineage_cols <- c("#000000", "#0072B2", "#D55E00", "#009E73", "#CC79A7")
  lineage_cols <- lineage_cols[seq_along(res$curve_umap)]
  
  for (i in seq_along(res$curve_umap)) {
    cu <- res$curve_umap[[i]]
    colnames(cu) <- c("UMAP1", "UMAP2")
    
    gg <- gg + geom_path(
      data = cu,
      aes(UMAP1, UMAP2),
      inherit.aes = FALSE,
      color = lineage_cols[i],
      size = curve_size,
      lineend = "round"
    )
  }
  
  # Add root + terminal labels
  if (label_root_terminal) {
    root <- res$detected_root
    terminals <- res$detected_terminals
    
    centroids <- df %>%
      mutate(cluster = clusters) %>%
      group_by(cluster) %>%
      summarize(
        UMAP1 = mean(UMAP1),
        UMAP2 = mean(UMAP2)
      )
    
    label_df <- centroids %>%
      filter(cluster %in% c(root, terminals)) %>%
      mutate(type = ifelse(cluster == root, "Root", "Terminal"))
    
    gg <- gg +
      geom_label(
        data = label_df,
        aes(UMAP1, UMAP2, label = paste0(type, "\n", cluster)),
        inherit.aes = FALSE,
        label.size = 0,
        size = 3,
        fill = "white",
        alpha = 0.9
      )
  }
  
  return(gg)
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#'
plot_umap_lineage <- function(lineage.col,
                              umap.df,
                              sds,
                              palette = viridis::viridis(100),
                              pt.name = lineage.col,
                              pt.size = 2,
                              reduction = "UMAP",
                              dims = c(1,2),
                              base.size = 14,
                              fig.plot = TRUE,
                              plot.title = NULL) {
  
  require(mgcv)
  require(dplyr)
  require(ggplot2)
  require(patchwork)
  
  df <- umap.df
  
  # --- SAFELY ADD PSEUDOTIME ---
  if (!lineage.col %in% colnames(sds)) {
    stop(paste0("Lineage column '", lineage.col, "' not found in pseudotime matrix"))
  }
  
  # Align pseudotime to UMAP cells
  # Assumes df$cell contains cell names
  if (!"cell" %in% colnames(df)) stop("umap.df must have a 'cell' column")
  pt_vec <- sds[as.character(df$cell), lineage.col]
  
  # Convert to numeric vector (handle possible 1-column matrix)
  if (is.matrix(pt_vec)) pt_vec <- as.numeric(pt_vec[,1])
  df$pt <- as.numeric(pt_vec)
  
  if (is.null(plot.title)) {
    plot.title <- paste0("Pseudotime: ", pt.name)
  }
  
  # --- MAIN UMAP / TRAJECTORY PLOT ---
  x_col <- colnames(df)[dims[1] + 1]  # +1 because first column is cell
  y_col <- colnames(df)[dims[2] + 1]
  
  p <- ggplot(df, aes(x = !!sym(x_col), y = !!sym(y_col))) +
    geom_point(aes(color = pt), size = pt.size, alpha = 0.9) +
    scale_color_gradientn(
      colours = palette,
      name = "Pseudotime",
      na.value = "grey80"
    ) +
    labs(title = plot.title) +
    theme_void() +
    guides(color = guide_colorbar(
      title.position = "left",
      title.vjust = 1,             
      frame.colour = "black",
      frame.linewidth = 0.4,
      barheight = 5, 
      barwidth = 0.8
    )) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      legend.title = element_text(angle = 90, vjust = 1, hjust = 0.5,size = 12),
      legend.position = "right"      
    )
  
  # --- ADD SMOOTHED TRAJECTORY IF ENOUGH CELLS ---
  ccells <- df %>% dplyr::filter(!is.na(pt))
  if (nrow(ccells) > 10) {
    g1 <- mgcv::gam(UMAP1 ~ s(pt, k = 20), data = ccells)
    g2 <- mgcv::gam(UMAP2 ~ s(pt, k = 20), data = ccells)
    pts.grid <- seq(min(ccells$pt), max(ccells$pt), length.out = 200)
    curve_df <- data.frame(
      UMAP1 = predict(g1, newdata = data.frame(pt = pts.grid)),
      UMAP2 = predict(g2, newdata = data.frame(pt = pts.grid))
    )
    p <- p + geom_path(data = curve_df,
                       aes(UMAP1, UMAP2),
                       color = "black", linewidth = 1)
  }
  
  if (!fig.plot) return(p)
  
  # --- AXIS PANEL UNDERNEATH ---
  x.lab <- paste0(toupper(reduction), "_", dims[1])
  y.lab <- paste0(toupper(reduction), "_", dims[2])
  
  axis.plot <- ggplot(data.frame(x = c(0,1), y = c(0,1)), aes(x,y)) +
    geom_blank() +
    xlab(x.lab) + ylab(y.lab) +
    theme_classic(base_size = base.size) +
    theme(
      plot.background  = element_rect(fill="transparent", colour=NA),
      panel.background = element_rect(fill="transparent"),
      axis.title       = element_text(size = base.size * 0.8, face = "bold", colour = "black"),
      axis.title.x     = element_text(margin = margin(t = 8)), 
      axis.title.y     = element_text(margin = margin(r = 8)),   
      axis.text        = element_blank(),
      axis.ticks       = element_blank(),
      axis.line        = element_line(
        colour = "black",
        arrow = arrow(angle = 18, length = unit(.35, "cm"),
                      type = "closed")
      )
    )
  
  # --- LAYOUT: LARGE UMAP + TINY AXIS PANEL BELOW ---
  design <- c(
    patchwork::area(t=1, l=1, b=12, r=12),
    patchwork::area(t=11, l=1, b=12, r=3)
  )
  
  return(p + axis.plot + patchwork::plot_layout(design = design))
}


#'------------------------------------------------------------------------------
#'------------------------------------------------------------------------------
#' Plot gene-set distribution across cell types / stages
#'
#' Compute and plot how many genes from a gene set are expressed per cell,
#' aggregated / shown by cell type (and optionally by stage). Supports three
#' plotting modes: "standard" (dodged bars), "stacked" (stacked bars) and
#' "faceted" (separate panels by stage).
#'
#' @param obj Seurat obj.
#' @param geneset Character vector of genes (gene symbols matching rownames(obj)).
#' @param group.by Metadata column name for cell-type (default "ann2").
#' @param stage Metadata column name for stage/facet (default "PCW").
#' @param mode Plot mode, one of "standard", "stacked", "faceted".
#' @param assay Assay name to pull expression from (default "RNA").
#' @param slot Slot in assay ("data", "counts", "scale.data").
#' @param expr.thresh Expression cutoff to consider a gene "expressed" (>=).
#' @param breaks Numeric vector of breaks used to bin counts.
#' @param bin.labels Character labels for expression bins (length = length(breaks)-1).
#' @param fill.cols Optional named vector of fill colors (names must match factor levels).
#' @param theme Name forwarded to `plot_theme()` (keeps your existing theme system).
#' @param leg.pos Legend position (e.g. "right","bottom","top","left","none").
#' @param x.angle Angle for x-axis text.
#' @param font.size Base font size.
#' @param x.lab x-axis label (default "Number of genes expressed").
#' @param module.score If TRUE, compute module score using AddModuleScore and attach to output.
#' @param module.name Prefix used by AddModuleScore (default "GeneSetScore").
#' @param pb.logical If TRUE compute pseudobulk sums per celltype (returned for inspection).
#' @param pb.norm One of "none" or "per_million".
#' @param ann.counts Add counts on bars or inside stacks.
#' @param show.sig Show significance stars from chi-square standardized residuals.
#' @param pval Add chi-square p-value text in the plot.
#' @param label.size Size for annotation count text.
#' @param sig.size Size for significance stars.
#' @param facet.label.size Size for facet strip text.
#' @param lab.size Axis text size.
#' @param leg.size Legend text size.
#' @param leg.ttl.size Legend title size.
#' @param panel.fill Panel background fill color.
#' @param verbose Logical; print progress messages.
#' @param ... Additional args forwarded to `plot_theme()` or ggplot2.
#'
#' @return A list with: plot (ggplot), binned.data (data.frame), chi.test, residuals (stdres), pseudobulk (if computed).
#' @export
gsetplot <- function(
    obj,
    geneset,
    group.by = "ann2",
    stage = "stage",
    mode = c("standard", "stacked", "faceted"),
    assay = "RNA",
    slot = "data",
    expr.thresh = 0,
    breaks = c(-1, 0, 1, 2, Inf),
    bin.labels = c("0", "1", "2", "3+"),
    fill.cols = NULL,
    theme = "classic",
    leg.pos = "right",
    x.angle = 0,
    font.size = 10,
    x.lab = "Number of genes expressed",
    module.score = FALSE,
    module.name = "GeneSetScore",
    pb.logical = TRUE,
    pb.norm = c("none", "per_million"),
    ann.counts = FALSE,
    show.sig = TRUE,
    pval = TRUE,
    facet.ncol = 2,
    label.size = 3,
    sig.size = 4,
    facet.label.size = 10,
    lab.size = 10,
    leg.size = 10,
    leg.ttl.size = 10,
    panel.fill = "white",
    facet.bg = TRUE,
    verbose = TRUE,
    ...
) {
  ## packages
  require(Seurat)
  require(dplyr)
  require(ggplot2)
  require(RColorBrewer)
  require(scales)
  
  mode <- match.arg(mode)
  pb.norm <- match.arg(pb.norm)
  
  if (verbose) message("Checking gene set membership in obj...")
  genes.available <- intersect(geneset, rownames(obj))
  if (length(genes.available) == 0) stop("No genes from geneset found in obj.")
  
  if (verbose) message("Extracting expression matrix...")
  expr.mat <- GetAssayData(obj, assay = assay, slot = slot)[genes.available, , drop = FALSE]
  if (!is.matrix(expr.mat)) expr.mat <- as.matrix(expr.mat)
  
  # number of genes expressed per cell in the set
  n.expr <- colSums(expr.mat > expr.thresh, na.rm = TRUE)
  
  # metadata
  meta <- obj@meta.data
  if (!group.by %in% colnames(meta)) stop("group.by not found in obj@meta.data")
  if (mode == "faceted" && !stage %in% colnames(meta)) stop("stage not found in obj@meta.data")
  
  df <- data.frame(
    .cell = colnames(expr.mat),
    .cell.type = as.character(meta[[group.by]]),
    .n.expr = n.expr,
    stringsAsFactors = FALSE
  )
  
  if (mode == "faceted") {
    df$.stage <- factor(meta[[stage]], levels = sort(unique(meta[[stage]])))
  }
  
  # bin counts
  if (length(breaks) - 1 != length(bin.labels)) {
    stop("Length of bin.labels must equal length(breaks)-1")
  }
  df$.expr.bin <- cut(df$.n.expr, breaks = breaks, labels = bin.labels, right = TRUE, include.lowest = TRUE)
  
  # optional module score (computed on a copy so original is not modified)
  module.scores <- NULL
  if (module.score) {
    if (verbose) message("Computing module score using AddModuleScore (temporary obj)...")
    tmp <- obj
    tmp <- AddModuleScore(tmp, features = list(genes.available), name = module.name)
    score.col <- paste0(module.name, "1")
    if (!score.col %in% colnames(tmp@meta.data)) {
      warning("Module score column not found after AddModuleScore()")
    } else {
      module.scores <- tmp@meta.data[[score.col]]
      names(module.scores) <- rownames(tmp@meta.data)
      df$.module.score <- module.scores[df$.cell]
    }
    rm(tmp)
  }
  
  # pseudobulk (per cell type) sums across genes in geneset
  pb.df <- NULL
  if (pb.logical) {
    if (verbose) message("Computing pseudobulk per cell type...")
    # fast approach: split cell names by cell.type and sum columns
    by_type <- split(df$.cell, df$.cell.type)
    pb.sum <- sapply(by_type, function(cells) sum(colSums(expr.mat[, cells, drop = FALSE]), na.rm = TRUE))
    pb.df <- data.frame(.cell.type = names(pb.sum), pb.sum = as.numeric(pb.sum), stringsAsFactors = FALSE)
    if (pb.norm == "per_million") {
      n.cells <- table(df$.cell.type)
      pb.df$pseudobulk_norm <- pb.df$pb.sum / (as.numeric(n.cells[pb.df$.cell.type]) / 1e6)
    }
  }
  
  # chi-square test across cell types vs bins
  tab <- table(df$.cell.type, df$.expr.bin)
  chi.res <- tryCatch(chisq.test(tab), error = function(e) {
    warning("chisq.test failed: ", conditionMessage(e)); return(NULL)
  })
  
  residuals.df <- NULL
  if (!is.null(chi.res) && show.sig) {
    stdres <- chi.res$stdres
    residuals.df <- as.data.frame(as.table(stdres))
    colnames(residuals.df) <- c(".cell.type", ".expr.bin", ".stdres")
    residuals.df$.sig <- dplyr::case_when(
      abs(residuals.df$.stdres) >= 3.29 ~ "***",
      abs(residuals.df$.stdres) >= 2.58 ~ "**",
      abs(residuals.df$.stdres) >= 1.96 ~ "*",
      TRUE ~ ""
    )
  }
  
  # helper: default palette if user didn't pass fill.cols
  default_fill_for <- function(levels_vec, palette = "Set2") {
    n <- length(levels_vec)
    pal <- RColorBrewer::brewer.pal(max(3, min(8, n)), palette)
    if (n <= length(pal)) pal <- pal[seq_len(n)] else pal <- colorRampPalette(pal)(n)
    setNames(pal, levels_vec)
  }
  
  # --- BUILD PLOT DATA & PLOT FOR EACH MODE ---
  if (mode == "standard") {
    plot.df <- df %>%
      dplyr::group_by(.cell.type, .expr.bin) %>%
      dplyr::summarise(.count = n(), .groups = "drop") %>%
      dplyr::group_by(.cell.type) %>%
      dplyr::mutate(.prop = .count / sum(.count) * 100) %>%
      dplyr::ungroup()
    
    if (!is.null(residuals.df)) {
      plot.df <- dplyr::left_join(plot.df, residuals.df, by = c(".cell.type", ".expr.bin"))
    } else {
      plot.df$.sig <- ""
    }
    
    # fill.cols keyed to cell types
    if (is.null(fill.cols)) {
      types <- unique(plot.df$.cell.type)
      fill.cols <- default_fill_for(types, palette = "Set2")
    }
    
    p <- ggplot(plot.df, aes(x = .expr.bin, y = .prop, fill = .cell.type)) +
      geom_col(position = position_dodge(width = 0.9), color = "black", linewidth = 0.2) +
      scale_fill_manual(values = fill.cols) +
      labs(x = x.lab, y = "Proportion (%)", fill = "") +
      plot_theme(theme = theme, font.size = font.size, x.angle = x.angle, leg.pos = leg.pos, ...) +
      theme(
        strip.text = element_text(size = facet.label.size),
        legend.text = element_text(size = leg.size),
        legend.title = element_text(size = leg.ttl.size),
        panel.background = element_rect(fill = panel.fill, colour = NA)
      )
    
    if (ann.counts) {
      p <- p + geom_text(aes(label = .count), position = position_dodge(width = 0.9), vjust = -0.4, size = label.size)
    }
    if (show.sig && !is.null(residuals.df)) {
      p <- p + geom_text(aes(label = .sig), position = position_dodge(width = 0.9), vjust = -1.2, size = sig.size)
    }
    if (pval && !is.null(chi.res)) {
      p <- p + annotate("text", x = Inf, y = Inf, label = paste0("Chi-square p = ", signif(chi.res$p.value, 3)),
                        hjust = 1.05, vjust = 1.8, size = rel(leg.size / 4))
    }
  } else if (mode == "stacked") {
    plot.df <- df %>%
      dplyr::group_by(.cell.type, .expr.bin) %>%
      dplyr::summarise(.count = n(), .groups = "drop") %>%
      dplyr::group_by(.expr.bin) %>%
      dplyr::mutate(.prop = .count / sum(.count) * 100) %>%
      dplyr::ungroup()
    
    if (!is.null(residuals.df)) {
      plot.df <- dplyr::left_join(plot.df, residuals.df, by = c(".cell.type", ".expr.bin"))
    } else {
      plot.df$.sig <- ""
    }
    
    # fill.cols keyed to expression bins
    if (is.null(fill.cols)) {
      bins <- unique(plot.df$.expr.bin)
      fill.cols <- default_fill_for(bins, palette = "Set3")
    }
    
    p <- ggplot(plot.df, aes(x = .cell.type, y = .prop, fill = .expr.bin)) +
      geom_col(color = "black", linewidth = 0.2) +
      scale_fill_manual(values = fill.cols, name = x.lab) +
      labs(x = "Cell type", y = "Proportion (%)") +
      plot_theme(theme = theme, font.size = font.size, x.angle = x.angle, leg.pos= leg.pos,
                 ...) +
      theme(
        strip.text = element_text(size = facet.label.size),
        legend.text = element_text(size = leg.size),
        legend.title = element_text(size = leg.ttl.size),
        panel.background = element_rect(fill = panel.fill, colour = NA)
      )
    
    if (ann.counts) {
      p <- p + geom_text(aes(label = .count), position = position_stack(vjust = 0.5), size = label.size, colour = "black")
    }
    
    if (show.sig && !is.null(residuals.df)) {
      # collapse sig per cell type (concatenate unique sig strings) and place above each bar
      sig.df <- plot.df %>%
        dplyr::group_by(.cell.type) %>%
        dplyr::summarise(.sig = paste0(unique(.sig[.sig != ""]), collapse = " "), .groups = "drop")
      if (nrow(sig.df) > 0) {
        # place at 101% so visible above stack
        p <- p + geom_text(data = sig.df, aes(x = .cell.type, y = 101, label = .sig), inherit.aes = FALSE, size = sig.size, vjust = 0)
      }
    }
    
    if (pval && !is.null(chi.res)) {
      p <- p + annotate("text", x = Inf, y = Inf, label = paste0("Chi-square p = ", signif(chi.res$p.value, 3)),
                        hjust = 1.05, vjust = 1.8, size = rel(leg.size / 4))
    }
  } else if (mode == "faceted") {
    plot.df <- df %>%
      dplyr::group_by(.stage, .cell.type, .expr.bin) %>%
      dplyr::summarise(.count = n(), .groups = "drop") %>%
      dplyr::group_by(.stage, .cell.type) %>%
      dplyr::mutate(.prop = .count / sum(.count) * 100) %>%
      dplyr::ungroup()
    
    if (!is.null(residuals.df)) {
      plot.df <- dplyr::left_join(plot.df, residuals.df, by = c(".cell.type", ".expr.bin"))
    } else plot.df$.sig <- ""
    
    if (is.null(fill.cols)) {
      types <- unique(plot.df$.cell.type)
      fill.cols <- default_fill_for(types, palette = "Set2")
    }
    
    p <- ggplot(plot.df, aes(x = .expr.bin, y = .prop, fill = .cell.type)) +
      geom_col(position = position_dodge(width = 0.9), color = "black", linewidth = 0.2) +
      scale_fill_manual(values = fill.cols) +
      labs(x = x.lab, y = "Proportion (%)", fill = "") +
      facet_wrap(~ .stage, ncol = facet.ncol) +
      plot_theme(theme = theme, font.size = font.size, leg.pos = leg.pos, 
                 facet.bg = facet.bg,...) +
      theme(
        strip.text = element_text(size = facet.label.size),
        legend.text = element_text(size = leg.size),
        legend.title = element_text(size = leg.ttl.size),
        panel.background = element_rect(fill = panel.fill, colour = NA)
      )
    
    if (ann.counts) {
      p <- p + geom_text(aes(label = .count), position = position_dodge(width = 0.9), vjust = -0.4, size = label.size)
    }
    if (show.sig && !is.null(residuals.df)) {
      p <- p + geom_text(aes(label = .sig), position = position_dodge(width = 0.9), vjust = -1.2, size = sig.size)
    }
    if (pval && !is.null(chi.res)) {
      p <- p + annotate("text", x = Inf, y = Inf, label = paste0("Chi-square p = ", signif(chi.res$p.value, 3)),
                        hjust = 1.05, vjust = 1.8, size = rel(leg.size / 4))
    }
  } else {
    stop("Unsupported mode")
  }
  
  # final return
  out <- list(
    plot = p,
    binned.data = if (exists("plot.df")) plot.df else NULL,
    chi.test = chi.res,
    residuals = residuals.df,
    pseudobulk = pb.df,
    module.scores = module.scores
  )
  
  return(out)
}
