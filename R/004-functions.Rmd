plot_theme <- function(theme_type = c("minimal", "bw", "classic", "test","void"), 
                       font_size = 10, 
                       xyval = TRUE, 
                       x_angle = 0, 
                       x_hjust = NULL,
                       x_vjust = NULL, 
                       x_lab = TRUE,
                       y_lab = TRUE,
                       xy_lab = TRUE,
                       facet_title = "bold",
                       legend_position = "right",
                       legend_direction = "vertical"){ 
  
  # Validate theme selection
  theme_type <- match.arg(theme_type)
  
  # Automatically set hjust and vjust based on x_angle
  if (is.null(x_hjust) | is.null(x_vjust)) {
    x_angle <- as.numeric(x_angle)  # Ensure it's numeric
    
    if (x_angle == 0) {
      x_hjust <- 0.5
      x_vjust <- 1
    } else if (x_angle == 45) {
      x_hjust <- 1
      x_vjust <- 1
    } else if (x_angle == 90) {
      x_hjust <- 1
      x_vjust <- 0.5
    } else if (x_angle == 270) {
      x_hjust <- 0
      x_vjust <- 0.5
    } else {
      x_hjust <- 1
      x_vjust <- 1
    }
  }
  
  # Base theme structure
  base_theme <- theme(
    plot.title = element_text(hjust = 0.5, size = font_size+2, face = facet_title),
    text = element_text(size = font_size, color = "black"), 
    axis.title = element_text(face = "plain", size = font_size, color = "black"), 
    axis.text = element_text(size = font_size, color = "black"), 
    axis.text.x = element_text(angle = x_angle, 
                               hjust = x_hjust, 
                               vjust = x_vjust, 
                               color = "black"), 
    strip.text = element_text(face = "plain", color = "black"), 
    legend.title = element_text(size = font_size),
    legend.text  = element_text(size = font_size),
    legend.position.inside = if (is.numeric(legend_position)) legend_position else NULL,
    legend.position = if (!is.numeric(legend_position)) legend_position else NULL,
    legend.justification = "center",
    legend.direction = legend_direction,
    legend.background = element_blank(),
    legend.key.height = unit(0.3, 'cm'),
    legend.key.width = unit(0.3, 'cm'),
    legend.key = element_rect(colour = NA, fill = NA) 
  )
  
  minimal_theme <- function(x) { 
    min_thm <-  theme(
      axis.line.x = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.major.x = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(colour = "grey", linewidth = 0.15),
      panel.grid.minor.y = element_blank(),
      axis.ticks.x = element_line(colour = "grey", linewidth = 0.15),
      axis.ticks.y = element_line(colour = "grey", linewidth = 0.15)
    )
    return(min_thm)
  } 

  #' save_plot: Save a Plot in Multiple Formats
#'
#' @description
#' This function saves a given plot to a specified file in one or more formats.
#' It allows for saving the plot in multiple formats (e.g., PNG, PDF, JPEG) at once, 
#' with customizable dimensions and resolution.
#'
#' @param plot A ggplot object. The plot to be saved.
#' @param filename Character, base name for the output file. The function appends the appropriate file extension(s).
#' @param formats Character vector specifying the file formats to save the plot in (default is `c("png", "pdf", "jpeg")`).
#' @param width Numeric, width of the saved plot in inches (default is `8`).
#' @param height Numeric, height of the saved plot in inches (default is `6`).
#' @param dpi Numeric, resolution of the saved plot in dots per inch (default is `300`).
#'
#' @details
#' The `save_plot` function automates the process of saving a ggplot object in multiple formats by looping over the specified
#' formats and using `ggsave` to save the plot. The output file names are generated by appending the format extension
#' (e.g., ".png", ".pdf") to the provided base filename.
#'
#' The dimensions (`width` and `height`) and resolution (`dpi`) can be customized. The `limitsize = FALSE` argument is used to 
#' allow saving plots with larger dimensions than usual.
#'
#' @examples
#' # Save a plot in default formats (PNG, PDF, and JPEG)
#' save_plot(plot = my_plot, filename = "my_plot")
#'
#' # Save a plot in PNG and SVG formats with custom dimensions
#' save_plot(plot = my_plot, filename = "custom_plot", formats = c("png", "svg"), width = 10, height = 7, dpi = 400)
#'
#' @export
save_plot <- function(plot, filename, formats = c("png", "pdf", "jpeg"), width = 8, height = 6, dpi = 300) {
  for (format in formats) {
    ggsave(
      filename = paste0(filename, ".", format),
      plot = plot,
      device = format,
      width = width,
      height = height,
      dpi = dpi, 
      limitsize = FALSE
    )
  }
}


#' Summarize Seurat Object Metadata
#'
#' This function summarizes metadata from a Seurat object and generates a bar plot 
#' for visualization. It allows grouping and conditioning by metadata columns, 
#' supports color customization, and provides options for reordering bars.
#'
#' @param object A Seurat object containing single-cell RNA-seq data.
#' @param group.by A string specifying the metadata column to group by (default: "sample").
#' @param condition.by A string specifying a second metadata column for conditional grouping (default: NULL).
#' @param pal.setup A string specifying the color palette from RColorBrewer (default: "Set1").
#' @param custom.colors A vector of custom colors to use instead of the default palette (default: NULL).
#' @param use.discrete.colors Logical; if TRUE, uses discrete colors from Set1 (default: FALSE).
#' @param angle.x An integer specifying the angle of x-axis labels (default: 90).
#' @param vjust.x Vertical justification of x-axis labels (default: NULL).
#' @param hjust.x Horizontal justification of x-axis labels (default: NULL).
#' @param x.title A string for the x-axis title (default: same as `group.by`).
#' @param remove.axis.x.text Logical; if TRUE, removes x-axis text (default: FALSE).
#' @param reorder.bars Logical; if TRUE, reorders bars based on a specified column (default: FALSE).
#' @param reorder.column A string specifying the column to reorder bars by (default: NULL).
#' @param plot.variable A string specifying the metric to plot: "total_counts", "total_transcripts", 
#'  "mean_transcripts", "median_transcripts", or "proportion" (default: "total_counts").
#' @param title A string specifying the plot title (default: same as `plot.variable`).
#' @param legend Logical; if FALSE, removes the legend (default: TRUE).
#' @param text.size An integer specifying the text size in the plot (default: 10).
#'
#' @return A list containing:
#'   \item{summary_table}{A summary table with calculated statistics.}
#'   \item{plot}{A ggplot2 object representing the bar plot.}
#'
#' @import Seurat dplyr ggplot2 RColorBrewer
#' @export
#'
#' @examples
#' \dontrun{
#'   result <- Summarize_Seurat(object = seurat_obj, group.by = "cell_type", plot.variable = "total_counts")
#'   print(result$plot)
#' }
Summarize_Seurat <- function(object, 
                             group.by = "sample",
                             assay = "RNA",
                             slot = "counts",
                             condition.by = NULL,  
                             pal.setup = "Set1",
                             custom.colors = NULL,
                             use.discrete.colors = FALSE,
                             theme_type = "classic", 
                             x_angle = 45, 
                             x.title = group.by,
                             remove.axis.x.text = FALSE,
                             reorder.bars = FALSE,
                             reorder.column = NULL,
                             plot.variable = c("total_transcripts", "mean_transcripts", "median_transcripts", 
                                               "num_expressed_genes", "mean_genes_per_cell", "num_cells"),
                             plot.title = plot.variable,
                             legend = TRUE,
                             legend.title = NULL,
                             legend.key.size = 0.3,
                             legend.position = "right",
                             legend.ncol = 1,
                             legend.alpha = 1,
                             text.size = 10,
                             remove.x.labels = FALSE,
                             remove.x.title = FALSE,
                             remove.y.title = FALSE,
                             y.title = NULL) {
  
  # Load required libraries
  require(Seurat)
  require(dplyr)
  require(ggplot2)
  require(RColorBrewer)
  
  # Validate the plotting method choice
  plot.variable <- match.arg(plot.variable)
  
  # Extract metadata and gene expression matrix
  metadata <- object@meta.data
  gene_counts <- object[[assay]][slot]
  
  # Ensure group.by exists
  if (!group.by %in% colnames(metadata)) {
    stop(paste("The specified group.by column", group.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Ensure condition.by exists if provided
  if (!is.null(condition.by) && !condition.by %in% colnames(metadata)) {
    stop(paste("The specified condition.by column", condition.by, "does not exist in the Seurat object's metadata."))
  }
  
  # Compute expressed genes per cell
  expressed_genes_per_cell <- Matrix::colSums(gene_counts > 0)  # Number of genes expressed per cell
  metadata$num_expressed_genes <- expressed_genes_per_cell
  
  # Group data
  if (!is.null(condition.by)) {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by), !!sym(condition.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      ) %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::mutate(proportion = total_counts / sum(total_counts)) %>%  
      dplyr::ungroup()
  } else {
    summary_stats <- metadata %>%
      dplyr::group_by(!!sym(group.by)) %>%
      dplyr::summarise(
        total_counts = dplyr::n(),  
        total_transcripts = sum(nCount_RNA),  
        mean_transcripts = mean(nCount_RNA),  
        median_transcripts = median(nCount_RNA),  
        num_expressed_genes = sum(num_expressed_genes),  
        mean_genes_per_cell = mean(num_expressed_genes),  
        .groups = 'drop'  
      )
  }
  
  # Add the number of cells per group (corrected)
  num_cells_per_group <- metadata %>%
    dplyr::group_by(!!sym(group.by)) %>%
    dplyr::summarise(num_cells = n(), .groups = 'drop')
  summary_stats <- left_join(summary_stats, num_cells_per_group, by = group.by)
  
  # Ensure plot.variable exists
  if (!(plot.variable %in% colnames(summary_stats))) {
    stop(paste("The specified plot.variable", plot.variable, "does not exist in the summary statistics table."))
  }
  
  # Define colors
  unique_groups <- unique(summary_stats[[ifelse(is.null(condition.by), group.by, condition.by)]])
  num_groups <- length(unique_groups)
  
  if (!is.null(custom.colors)) {
    if (length(custom.colors) < num_groups) {
      stop(paste("Insufficient colors in custom.colors. Needed:", num_groups, "Provided:", length(custom.colors)))
    }
    colors_to_use <- custom.colors
  } else if (use.discrete.colors) {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set1"))(num_groups)
  } else {
    colors_to_use <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_groups), pal.setup))(num_groups)
  }
  
  # Reorder bars globally if required
  if (reorder.bars) {
    if (is.null(reorder.column)) {
      reorder.column <- plot.variable  # Default to reordering by the plot variable
    }
    if (!reorder.column %in% colnames(summary_stats)) {
      stop(paste("The specified reorder.column", reorder.column, "does not exist in the summary statistics table."))
    }
    
    # Ensure reorder.column is evaluated correctly
    summary_stats <- summary_stats %>%
      dplyr::mutate(!!reorder.column := as.numeric(summary_stats[[reorder.column]])) %>%
      dplyr::arrange(dplyr::desc(!!sym(reorder.column))) %>%
      dplyr::mutate(!!sym(group.by) := factor(!!sym(group.by), levels = unique(!!sym(group.by))))
  }
  
  # Create base bar plot
  p <- ggplot(summary_stats, aes(x = !!sym(group.by), y = !!sym(plot.variable))) +
    geom_bar(stat = "identity", position = "stack", color = "black", size = 0.3) +  
    plot_theme(theme_type = theme_type, x_angle = x_angle, font_size = text.size) +
    theme(legend.position = legend.position,
          legend.key.size = unit(legend.key.size, "cm")) +
    guides(color = guide_legend(ncol = legend.ncol, alpha = legend.alpha, title = legend.title)) +
    labs(title = plot.title, y = plot.variable, x = x.title, colour = paste(legend.title)) 
  
  # Add fill aesthetic
  if (!is.null(condition.by)) {
    p <- p + aes(fill = !!sym(condition.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  } else {
    p <- p + aes(fill = !!sym(group.by)) + scale_fill_manual(values = colors_to_use, name = legend.title)
  }
  
  if (remove.x.title) {
    p <- p + theme(axis.title.x = element_blank())
  }
  
  if (remove.y.title) {
    p <- p + theme(axis.title.y = element_blank())
  }
  
  if (remove.x.labels) {
    p <- p + theme(axis.text.x = element_blank(),
                   axis.ticks.x = element_blank())
  }
  
  if (!is.null(y.title)) {
    p <- p + ylab(y.title)
  }
  
  # Hide legend if specified
  if (!legend) {
    p <- p & NoLegend()
  }
  
  # Return results
  return(list(summary_table = summary_stats, plot = p))
}

Seurat_Subset <- function(object, cluster_id, 
                          npcs = 30,
                          features = NULL,
                          ndims = 20, 
                          reduction = "pca",
                          resolution = 0.2,
                          min.dist = 0.5) {
  sub <- subset(object, idents = cluster_id)
  #DefaultAssay(sub) <- "integrated"
  #features <- VariableFeatures(sub)
  sub <- ScaleData(sub)
  sub <- RunPCA(sub, npcs = npcs, features = features)
  sub <- RunUMAP(sub, dims = 1:ndims, reduction = reduction,min.dist = min.dist)
  sub <- FindNeighbors(sub, dims = 1:ndims, reduction = reduction)
  sub <- FindClusters(sub, resolution = resolution)
  DefaultAssay(sub) <- "RNA"
  sub <- NormalizeData(sub)
  sub <- FindVariableFeatures(sub)
  sub <- ScaleData(sub)
  return(sub)
}

#' Plot Cell Fractions Over Time
#'
#' This function creates various types of visualizations to display the distribution 
#' of cell types over time using Seurat metadata.
#'
#' @param seurat_obj A Seurat object containing cell metadata.
#' @param x.col Character. The column name in metadata representing the x-axis (e.g., "Age").
#' @param fill.col Character. The column name in metadata representing cell types (e.g., "CellType").
#' @param plot.type Character. Type of plot to generate. Choose from:
#'   - "stacked_area" (default)
#'   - "stacked_bar"
#'   - "grouped_bar"
#'   - "point_smooth"
#'   - "heatmap"
#'   - "ridgeline"
#'   - "line"
#' @param text.size Numeric. Text size for axis labels and titles (default: 10).
#' @param legend.title Character. Custom title for the legend (default: NULL).
#' @param legend.position Character. Position of legend ("right", "bottom", "top", "left") (default: "right").
#' @param legend.ncol Numeric. Number of columns in the legend (default: 1).
#' @param custom.colors Character vector. Custom colors for cell types (default: NULL).
#' @param x.title Character. Custom x-axis title (default: same as `x.col`).
#' 
#' @return A ggplot object.
#' @import ggplot2 dplyr RColorBrewer ggridges scales
#' @export
#' 
#' @examples
#' # Example usage:
#' Plot_Cell_Fractions(seurat_obj, plot.type = "ridgeline")
#' Plot_Cell_Fractions(seurat_obj, plot.type = "stacked_area", text.size = 12)
Plot_Cell_Fractions <- function(seurat_obj, 
                                x.col = "Age", 
                                fill.col = "CellType",
                                plot.type = "stacked_area",
                                text.size = 10,
                                pt.size = 2,
                                line.size = 0.5,
                                legend.title = NULL,
                                legend.position = "right",
                                legend.ncol = 1,
                                custom.colors = NULL,
                                x.title = x.col
) {
  
  # Load necessary libraries
  library(ggplot2)
  library(dplyr)
  library(RColorBrewer)
  library(ggridges)
  library(scales)
  
  # Ensure metadata contains the required columns
  metadata <- seurat_obj@meta.data %>%
    dplyr::select(all_of(c(x.col, fill.col))) %>%
    dplyr::group_by(!!sym(x.col), !!sym(fill.col)) %>%
    dplyr::summarise(count = dplyr::n(), .groups = "drop") %>%
    dplyr::group_by(!!sym(x.col)) %>%
    dplyr::mutate(fraction = count / sum(count)) %>%
    dplyr::ungroup()
  
  # Ensure x.col is numeric
  metadata[[x.col]] <- as.numeric(as.character(metadata[[x.col]]))
  
  # Define colors
  num_categories <- length(unique(metadata[[fill.col]]))
  if (is.null(custom.colors)) {
    custom.colors <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_categories), "Set3"))(num_categories)
  }
  
  # Create the plot based on plot type
  if (plot.type == "stacked_area") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_area(position = "stack", alpha = 1, colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "stacked_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "fill", colour = "black", size = 0.2) +
      scale_y_continuous(labels = scales::percent) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "grouped_bar") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = count, fill = !!sym(fill.col))) +
      geom_bar(stat = "identity", position = "dodge", colour = "black", size = 0.2) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell Count") +
      theme_classic()
  }
  
  else if (plot.type == "point_smooth") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col))) +
      geom_point(size = pt.size) +
      geom_smooth(method = "loess", se = FALSE, size = line.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  }
  
  else if (plot.type == "heatmap") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), fill = fraction)) +
      geom_tile() +
      viridis::scale_fill_viridis_c(option = "plasma") +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_minimal()
  }
  
  else if (plot.type == "ridgeline") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = !!sym(fill.col), height = fraction, fill = !!sym(fill.col))) +
      geom_density_ridges(stat = "identity", scale = 1.5, alpha = 0.7) +
      scale_fill_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Cell type", fill = "Fraction of cells") +
      theme_classic()
  } else if (plot.type == "line") {
    p <- ggplot(metadata, aes(x = !!sym(x.col), y = fraction, color = !!sym(fill.col), group = !!sym(fill.col))) +
      geom_line(size = line.size) + 
      geom_point(size = pt.size) +
      scale_y_continuous(labels = scales::percent) +
      scale_color_manual(values = custom.colors, name = legend.title) +
      labs(x = x.title, y = "Fraction of cells") +
      theme_classic()
  } else {
    stop("Invalid plot type. Choose from: stacked_area, stacked_bar, grouped_bar, point_smooth, heatmap, line, ridgeline.")
  }
  
  # Adjust theme settings
  p <- p +
    theme(
      plot.title = element_text(size = text.size + 2, face = "bold", hjust = 0.5),
      axis.title = element_text(size = text.size),
      axis.text = element_text(size = text.size, color = "black"),
      legend.key.size = unit(0.3, 'cm'),
      legend.position = legend.position,
      legend.spacing.y = unit(0.05, 'cm'),  # Reduce space between legend items
      legend.margin = margin(t = -10, b = 0, unit = 'pt') # Reduce space between plot and legend
    ) +
    guides(fill = guide_legend(
      ncol = legend.ncol, 
      override.aes = list(color = "black", size = 0.2) 
    ))
  
  return(p)
}




plot_gene_set_expression <- function(object,
                               features,
                               threshold = 0.5,
                               plot_log = TRUE,
                               x_angle = 0,
                               theme_type = "classic",
                               font_size = 10,
                               legend_position = c(0.25, 0.9)) {

  # Subset the Seurat object for the selected genes
  filt <- subset(object, features = features)
  filt <- filt[rowSums(filt@assays$RNA@counts > 0) > 0, ]

  # Extract normalized expression data for these genes
  expr_data <- FetchData(filt, vars = rownames(filt))

  # Calculate the mean expression for each receptor across all cells
  mean_expression <- colMeans(expr_data)

  # Create a data frame for plotting
  expr_df <- data.frame(Receptor = names(mean_expression),
                        Expression = mean_expression)

  # Order by expression levels
  expr_df <- expr_df[order(expr_df$Expression), ]

  # Calculate the number of olfactory receptors (excluding VN1R1 and VN1R2)
  num_olfactory_receptors <- sum(!expr_df$Receptor %in% c("VN1R1", "VN1R2"))

  # Create a label for the olfactory receptors that includes the count
  olfactory_label <- paste0("Olfactory receptors (", num_olfactory_receptors, ")")

  # Modify the Receptor_Group to include specific labels
  expr_df$Receptor_Group <- ifelse(expr_df$Receptor %in% c("VN1R1", "VN1R2"),
                                   expr_df$Receptor, olfactory_label)

  # Set colors for the plot
  fill_colors <- c("VN1R1" = "red", "VN1R2" = "orange", "Olfactory receptors (0)" = "#20679B")
  fill_colors[olfactory_label] <- "#20679B"

  # Count the number of cells expressing each receptor
  expressing_cells <- expr_data > threshold
  cell_counts <- colSums(expressing_cells)
  expr_df$Cell_Count <- cell_counts[match(expr_df$Receptor, names(cell_counts))]

  # Optionally calculate -log10(expression) for better visualization
  if (plot_log) {
    expr_df$Log_Expression <- -log10(expr_df$Expression)
    y_var <- "Log_Expression"
    y_label <- "-Log10(Normalized Expression)"
  } else {
    expr_df$Log_Expression <- expr_df$Expression
    y_var <- "Expression"
    y_label <- "Normalized Expression"
  }

  # Plot the expression levels
  p <- ggplot(expr_df, aes(x = reorder(Receptor, !!sym(y_var)), y = !!sym(y_var), fill = Receptor_Group)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = fill_colors, name = "Receptor types") +
    labs(x = "Receptors", y = y_label) +
    plot_theme(theme_type = theme_type,
               legend_position = legend_position,
               font_size = font_size,
               x_angle = x_angle) +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

  return(p)
}


# Function to analyze and visualize OR gene expression
plot_common_genes <- function(seurat_obj, 
                            gene_list, 
                            cell_type_col, 
                            legend_position = c(0.90, 0.8),
                            theme_type = "classic",
                            font_size = 10,
                            x_angle = 90,
                            colors = NULL) {
  
  require(Seurat)
  require(ggplot2)
  require(dplyr)
  require(tidyr)
  require(forcats)
  require(rlang)
  
  # Step 1: Extract OR gene expression data
  features <- intersect(gene_list, rownames(seurat_obj[["RNA"]]@counts))
  sub <- subset(seurat_obj, features = features)
  OR_counts <- GetAssayData(sub, assay = "RNA", slot = "counts")
  
  # Step 2: Filter for OR genes
  OR_genes <- intersect(rownames(OR_counts), features)
  OR_counts <- OR_counts[OR_genes, ]
  
  # Step 3: Identify expressed ORs in each cell
  expressed_ORs <- OR_counts > 0  # Boolean matrix: TRUE if an OR is expressed
  
  # Step 4: Combine with metadata for cell type
  cell_data <- data.frame(
    Cell_Barcode = colnames(sub),
    Cell_Type = sub@meta.data[[cell_type_col]]  # Use specified metadata column
  )
  
  # Convert OR expression matrix to long format
  OR_long <- as.data.frame(t(expressed_ORs)) %>%
    dplyr::mutate(Cell_Barcode = rownames(.)) %>%
    pivot_longer(
      cols = -Cell_Barcode,
      names_to = "OR_Gene",
      values_to = "Expressed"
    ) %>%
    filter(Expressed)  # Only keep expressed ORs
  
  # Step 5: Join cell type information with OR expression
  OR_long <- OR_long %>%
    dplyr::left_join(cell_data, by = "Cell_Barcode")
  
  # Step 6: Count cells expressing each OR, grouped by cell type
  OR_summary <- OR_long %>%
    dplyr::group_by(OR_Gene, Cell_Type) %>%
    dplyr::summarize(Number_of_Cells = n(), .groups = "drop")
  
  # Step 7: Filter ORs expressed in at least two cell types
  OR_summary_filtered <- OR_summary %>%
    dplyr::group_by(OR_Gene) %>%
    dplyr::filter(n_distinct(Cell_Type) >= 2) %>%
    dplyr::ungroup()
  
  # Step 8: Reorder OR_Gene by total number of cells expressing each OR
  OR_summary_filtered <- OR_summary_filtered %>%
    dplyr::group_by(OR_Gene) %>%
    dplyr::mutate(Total_Cells = sum(Number_of_Cells)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(OR_Gene = forcats::fct_reorder(OR_Gene, Total_Cells, .desc = TRUE))
  
  # Set default colors if none provided
  if (is.null(colors)) {
    unique_cell_types <- unique(OR_summary_filtered$Cell_Type)
    colors <- setNames(rainbow(length(unique_cell_types)), unique_cell_types)
  }
  
  # Step 9: Generate the plot
  p <- ggplot(OR_summary_filtered, aes(x = OR_Gene, y = Number_of_Cells, fill = Cell_Type)) +
    geom_bar(stat = "identity", position = "stack", color = "black", size = 0.1) +
    labs(
      x = "",
      y = "Number of ORs"
    ) +
    plot_theme(theme_type = theme_type, 
               legend_position = legend_position, 
               font_size = font_size, x_angle = x_angle) +
    scale_fill_manual(values = colors, name = "") 
    
  
  return(p)
}

analyze_OR_distribution <- function(seurat_obj, gene_list, meta_column, expr_cutoff = 1, 
                                    breaks = c(-1, 0, 1, 2, Inf),
                                    bin_labels = c("0", "1", "2", "3+"),
                                    fill_colors = NULL,
                                    theme_type = "minimal",
                                    legend_pos = c(0.25, 0.90)) {
  
  require(dplyr)
  require(ggplot2)
  require(tidyr)
  
  # Extract genes expressed above cutoff
  genes <- intersect(gene_list, rownames(seurat_obj@assays$RNA@counts))
  expr <- as.matrix(seurat_obj@assays$RNA@counts[genes, ])
  expr_counts <- Matrix::colSums(expr > expr_cutoff)
  
  # Create metadata df
  df <- data.frame(
    OR_count = expr_counts,
    Stage = seurat_obj@meta.data[[meta_column]]
  )
  
  # Bin OR counts
  df$OR_bin <- cut(df$OR_count, breaks = breaks, labels = bin_labels, right = TRUE)
  
  # Build contingency table
  table_OR <- table(df$Stage, df$OR_bin)
  chi_test <- chisq.test(table_OR)
  
  # Extract residuals
  residuals_df <- as.data.frame(chi_test$stdres)
  colnames(residuals_df) <- c("Stage", "OR_bin", "Std_Resid")
  residuals_df$Sig <- case_when(
    abs(residuals_df$Std_Resid) >= 3.29 ~ "***",
    abs(residuals_df$Std_Resid) >= 2.58 ~ "**",
    abs(residuals_df$Std_Resid) >= 1.96 ~ "*",
    TRUE ~ ""
  )
  
  # Count and percentage per group
  count_df <- df %>%
    dplyr::group_by(Stage, OR_bin) %>%
    dplyr::summarise(n = n(), .groups = "drop") %>%
    dplyr::group_by(Stage) %>%
    dplyr::mutate(Percentage = n / sum(n) * 100) %>%
    dplyr::ungroup()
  
  # Merge
  plot_df <- left_join(residuals_df, count_df, by = c("Stage", "OR_bin"))
  
  # Color palette fallback
  if (is.null(fill_colors)) {
    unique_stages <- unique(df$Stage)
    fill_colors <- setNames(RColorBrewer::brewer.pal(length(unique_stages), "Set2"), unique_stages)
  }
  
  # Plot
  p <- ggplot(plot_df, aes(x = OR_bin, y = Percentage, fill = Stage)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black", size = 0.1) +
    geom_text(aes(label = Sig), position = position_dodge(width = 0.9), vjust = -0.5, size = 4) +
    labs(x = "Olfactory receptors", y = "Proportion (%)", fill = "") +
    scale_fill_manual(values = fill_colors) +
    plot_theme(theme_type = theme_type, legend_position = legend_pos)
  
  return(list(
    plot = p,
    chi_result = chi_test,
    residuals = residuals_df
  ))
}



# Function to plot unique ORs detected per cell
plot_unique_gene_per_cell <- function(seurat_obj, gene_list, font_size = 10, theme_type = "classic",
                                      x_title = "Number of cells", y_title = "Number of ORs") {
  # Find common genes between gene_list and Seurat object
  features <- intersect(gene_list, rownames(seurat_obj[["RNA"]]@counts))
  
  # Subset the Seurat object to include only the selected features
  filt <- subset(seurat_obj, features = features)
  
  # Filter out genes that are not expressed in any cell
  filt <- filt[rowSums(filt@assays$RNA@counts > 0) > 0, ]
  
  # Extract normalized expression data
  expr_data <- FetchData(filt, vars = rownames(filt))
  
  # Count the number of unique ORs detected per cell (above threshold)
  unique_OR_counts <- apply(expr_data, 1, function(cell_expr) sum(cell_expr > 0))
  
  # Create a data frame for plotting
  plot_data <- data.frame(
    Cell = names(unique_OR_counts),
    Unique_ORs = unique_OR_counts
  )
  
  # Filter out cells with no ORs
  plot_data <- subset(plot_data, Unique_ORs != 0)
  plot_data$Unique_ORs <- factor(plot_data$Unique_ORs)
  
  # Create the plot
  p <- ggplot(plot_data, aes(x = Cell, y = Unique_ORs)) +
    geom_bar(stat = "identity", position = position_dodge(), colour = "#20679B") +
    labs(
      x = x_title,
      y = y_title
    ) +
    plot_theme(theme_type = theme_type, 
               legend_position = "none", 
               font_size = font_size) +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Create a table to show the number of OSNs expressing each gene
  # Count non-zero entries per column (number of cells expressing each gene)
  count_non_zero <- colSums(expr_data > 0)
  
  # Convert to a data frame
  gene_expr_table <- data.frame(features = names(count_non_zero), count_non_zero = count_non_zero)
  
  # Order by count_non_zero in ascending order
  gene_expr_table <- gene_expr_table[order(gene_expr_table$count_non_zero, decreasing = FALSE), ]
  
  # Return the plot and the expression table
  return(list(Plot = p, Expression_Table = gene_expr_table))
}

#' Test variable genes along pseudotime using GAM (Generalized Additive Model)
#'
#' This function tests the association between gene expression and pseudotime for the most variable genes,
#' using a generalized additive model (GAM) on a subset of selected cell types.
#'
#' @param seurat_obj A Seurat object containing expression data.
#' @param sce_obj A SingleCellExperiment object containing expression data and pseudotime.
#' @param pseudotime_col Name of the column containing pseudotime values in \code{sce_obj}. Default is "slingPseudotime_1".
#' @param annotation_level Name of the cell type annotation column. Default is "ann_level_2".
#' @param selected_celltypes Vector of cell types to include in the analysis. Default is c("Olf. HBCs", "GBCs", "preOSNs", "iOSNs", "mOSNs").
#' @param n_variable_genes Number of variable genes to test. Default is 500.
#' @param verbose Whether to display progress messages. Default is TRUE.
#'
#' @return A list containing:
#' \describe{
#'   \item{sce}{The subsetted SCE object.}
#'   \item{result}{A sorted data.frame of tested genes with p-value and q-value.}
#'   \item{ptime}{Vector of pseudotime values used.}
#'   \item{lineage_cells}{Names of cells included in the analysis.}
#' }
#'
#' @details
#' Genes are individually tested for association with pseudotime using a GAM (gam::gam).
#' P-values are adjusted using the FDR method.
#'
#' @import gam
#' @import SingleCellExperiment
#' @import Seurat
#' @importFrom tibble tibble
#' @importFrom dplyr arrange
#' @export
#' 
test_pseudotime_genes_gam <- function(seurat_obj,
                                      sce_obj,
                                      pseudotime_col = "slingPseudotime_1",
                                      annotation_level = "ann_level_2",
                                      selected_celltypes = c("Olf. HBCs", "GBCs", "preOSNs", "iOSNs", "mOSNs"),
                                      n_variable_genes = 500,
                                      verbose = TRUE) {
  require(gam)
  require(SingleCellExperiment)
  require(Seurat)
  
  # Subset the SCE by selected annotation
  if (verbose) message("Subsetting SCE object by selected cell types...")
  selected_cells <- sce_obj[[annotation_level]] %in% selected_celltypes
  subset_sce <- sce_obj[, selected_cells]
  
  # Extract pseudotime and keep only cells in the lineage
  if (verbose) message("Extracting pseudotime values and filtering NA...")
  ptime <- subset_sce[[pseudotime_col]]
  lineage_cells <- colnames(subset_sce)[!is.na(ptime)]
  ptime <- ptime[!is.na(ptime)]
  
  # Match Seurat object to same cell subset
  if (verbose) message("Subsetting Seurat object to match cell types...")
  Idents(seurat_obj) <- annotation_level
  seurat_sub <- Seurat_Subset(seurat_obj, cluster_id = selected_celltypes)
  seurat_sub <- Filter_Unwanted_Genes(seurat_sub, scale_data = TRUE)
  
  # Select top variable genes
  if (verbose) message(paste0("Selecting top ", n_variable_genes, " variable genes..."))
  genes_to_test <- head(VariableFeatures(seurat_sub), n_variable_genes)
  
  # Get logcounts from SCE
  if (verbose) message("Extracting log-normalized counts...")
  cnts <- logcounts(subset_sce)[genes_to_test, lineage_cells]
  
  # Fit GAM for each gene
  if (verbose) message("Fitting GAM models...")
  gam_pval <- apply(cnts, 1, function(z) {
    d <- data.frame(z = z, ptime = ptime)
    tmp <- suppressWarnings(gam::gam(z ~ gam::lo(ptime), data = d))
    p <- summary(tmp)[4][[1]][1, 5]
    p
  })
  
  gam_pval <- na.omit(gam_pval)
  
  # Return results as a sorted data frame
  if (verbose) message("Returning sorted results...")
  # result <- data.frame(
  #   gene = names(gam_pval),
  #   pval = gam_pval
  # )
  
  result <- tibble(id = names(gam_pval), pvals = gam_pval, qval = p.adjust(gam_pval, method = "fdr")) %>%
  arrange(qval)
  
  #result <- result[order(result$pval), ]
  return(list("sce" = subset_sce, "result" = result, "ptime" = ptime, "lineage_cells" = lineage_cells))
}


#' Plot a heatmap of gene expression along pseudotime
#'
#' This function generates a heatmap of scaled gene expression for a set of genes along pseudotime,
#' with cell type and pseudotime annotations, using the ComplexHeatmap package.
#'
#' @param sce A SingleCellExperiment object containing expression data.
#' @param pseudotime_col Name of the column in \code{colData(sce)} with pseudotime values. Default is "slingPseudotime_1".
#' @param annotation_col Name of the column in \code{colData(sce)} with cell type annotations. Default is "ann_level_2".
#' @param lineage_cells Character vector of cell names to include in the heatmap.
#' @param ptime_order Character vector specifying the order of cells along pseudotime.
#' @param gene_list Character vector of gene names to include in the heatmap.
#' @param celltype_order Character vector specifying the order of cell types in the annotation.
#' @param celltype_colors Named vector of colors for each cell type.
#' @param pseudotime_palette Name of the RColorBrewer palette for pseudotime annotation. Default is "YlGnBu".
#' @param zscore_limits Numeric vector of length 3 for the color scale limits (e.g., c(-2, 0, 2)).
#' @param output_pdf File path to save the heatmap as a PDF. If NULL, the plot is shown in the current device.
#' @param show_legend Logical, whether to show the heatmap legend. Default is TRUE.
#' @param show_annotation_legend Logical, whether to show the annotation legend. Default is TRUE.
#' @param cluster_rows Logical, whether to cluster the rows (genes). Default is TRUE.
#' @param font_size Integer, font size for row names and annotations. Default is 10.
#' @param pdf_width Numeric, width of the PDF output (if used). Default is 6.
#' @param pdf_height Numeric, height of the PDF output (if used). Default is 10.
#' @param plot_title Optional title for the heatmap.
#'
#' @return No return value. The function generates a heatmap plot, either displayed or saved as a PDF.
#'
#' @details
#' The function scales gene expression (row-wise Z-score), orders cells by pseudotime, and annotates columns by cell type and pseudotime.
#' Colors and clustering options are customizable.
#'
#' @import ComplexHeatmap
#' @import circlize
#' @import RColorBrewer
#' @import SingleCellExperiment
#' @export
#' 
plot_heatmap_pseudotime <- function(sce,
                                    pseudotime_col = "slingPseudotime_1",
                                    annotation_col = "ann_level_2",
                                    lineage_cells,
                                    ptime_order,
                                    gene_list,
                                    celltype_order,
                                    celltype_colors,
                                    pseudotime_palette = "YlGnBu",
                                    zscore_limits = c(-2, 0, 2),
                                    output_pdf = NULL,
                                    show_legend = TRUE,
                                    show_annotation_legend = TRUE,
                                    cluster_rows = TRUE,
                                    font_size = 10,
                                    pdf_width = 6,
                                    pdf_height = 10,
                                    plot_title = NULL) {
  
  require(ComplexHeatmap)
  require(circlize)
  require(RColorBrewer)
  require(SingleCellExperiment)

  # Filter and order expression matrix
  expr_mat <- logcounts(sce)[gene_list, lineage_cells, drop = FALSE]
  expr_mat <- expr_mat[, ptime_order]
  expr_mat_scaled <- as.matrix(t(scale(t(expr_mat))))  # Row-wise Z-score

  # Annotations
  annotations <- as.data.frame(colData(sce)[lineage_cells, c(pseudotime_col, annotation_col)])
  colnames(annotations) <- c("Pseudotime", "Cell types")
  annotations <- annotations[colnames(expr_mat_scaled), ]
  rownames(annotations) <- colnames(expr_mat_scaled)
  annotations$`Cell types` <- factor(annotations$`Cell types`, levels = celltype_order)

  # Pseudotime color function
  ptime_vector <- annotations$Pseudotime
  if (any(is.na(ptime_vector))) {
    stop("Pseudotime vector contains NA values. Filter or impute them before plotting.")
  }
  ptime_breaks <- seq(min(ptime_vector), max(ptime_vector), length.out = 100)
  ptime_colors <- colorRampPalette(rev(brewer.pal(n = 7, name = pseudotime_palette)))(100)
  ptime_color_fun <- circlize::colorRamp2(ptime_breaks, ptime_colors)

  # Annotation bar
  top_annot <- HeatmapAnnotation(
    "Cell types" = annotations$`Cell types`,
    "Pseudotime" = annotations$Pseudotime,
    col = list(
      "Cell types" = celltype_colors,
      "Pseudotime" = ptime_color_fun
    ),
    annotation_legend_param = list(
      "Cell types" = list(ncol = 1, border = "black", legend_direction = "vertical"),
      "Pseudotime" = list(border = "black")
    ),
    show_legend = show_annotation_legend,
    annotation_name_gp = gpar(fontsize = font_size)
  )

  # Heatmap
  ht <- ComplexHeatmap::Heatmap(expr_mat_scaled,
                name = "Z-score",
                show_column_names = FALSE,
                show_row_names = TRUE,
                cluster_rows = cluster_rows,
                cluster_columns = FALSE,
                show_row_dend = FALSE,
                column_dend_reorder = FALSE,
                col = colorRamp2(zscore_limits, c("blue", "white", "red")),
                border = TRUE,
                rect_gp = gpar(col = NA),
                heatmap_legend_param = list(
                  title = "Z-score",
                  title_position = "topcenter",
                  legend_direction = "horizontal",
                  legend_height = unit(0.3, 'cm'), 
                  legend_width = unit(3, 'cm'),
                  #legend_height = unit(1, 'cm'),
                  #legend_width = unit(2.7, 'cm'),
                  border = 'black'),
                row_names_gp = gpar(fontface = "italic", fontsize = font_size),
                top_annotation = top_annot)

  # Export or show with optional title
  options(ComplexHeatmap.raster_device = NULL)
  
  if (!is.null(output_pdf)) {
    pdf(output_pdf, useDingbats = FALSE, width = pdf_width, height = pdf_height)
    ComplexHeatmap::draw(ht,
                         use_raster = FALSE,
                         raster_device = NULL,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "right",
                         column_title = plot_title,
                         column_title_gp = gpar(fontsize = font_size + 2, fontface = "bold"))
    dev.off()
    
  } else {
    ComplexHeatmap::draw(ht,
                         use_raster = FALSE,
                         heatmap_legend_side = "bottom",
                         annotation_legend_side = "right",
                         column_title = plot_title,
                         column_title_gp = gpar(fontsize = font_size + 2, fontface = "bold"))
  }
}


#' Generate a Correlation Heatmap and Text Summary
#'
#' This function creates a correlation heatmap for cell clusters based on average expression values 
#' and provides a text summary describing the results.
#'
#' @param object A Seurat object containing the single-cell expression data.
#' @param group.by A metadata variable to group cells by. Default is "seurat_clusters".
#' @param fontsize Font size for the heatmap text. Default is 8.
#'
#' @return A list containing the heatmap object and a text summary.
#' @examples
#' # Example usage:
#' # result <- Heatmap_Correlation(seurat_obj, group.by = "cell_type", fontsize = 10)
#' # result$heatmap  # To visualize the heatmap
#' # result$summary  # To view the text summary
#'
#' @export
#' 
plot_cluster_correlation <- function(object, 
                                     group.by = "seurat_clusters",
                                     assay = "RNA", 
                                     slot = "data",  # Specify layer for Seurat v5
                                     plot.title = "Heatmap correlation",
                                     column_names_rot = 45,
                                     fontsize = 8) {
  
  require(Seurat)
  require(ComplexHeatmap)
  require(RColorBrewer)
  
  # Ensure the assay exists in the object
  # if (!(assay %in% Assays(object))) {
  #   stop(paste("❌ Assay", assay, "not found in the Seurat object."))
  # }
  
  # Set identity class based on the group.by column
  if (!group.by %in% colnames(object@meta.data)) {
    stop(paste("❌ Column", group.by, "not found in metadata."))
  }
  
  Idents(object) <- object@meta.data[[group.by]]
  
  # Extract unique cluster identities
  uniq <- unique(Idents(object))
  
  # Extract expression data
  if (packageVersion("Seurat") >= "5.0.0") {
    expr_data <- object[[assay]][slot] # Seurat v5 fix
  } else {
    expr_data <- GetAssayData(object, slot = slot, assay = assay)  # Seurat v4
  }
  
  # Initialize an empty matrix with correct dimensions
  mnmat <- matrix(NA, nrow = nrow(expr_data), ncol = length(uniq))
  
  # Iterate over each cluster and compute the average expression
  for (i in seq_along(uniq)) {
    cluster_cells <- WhichCells(object, idents = uniq[i])
    
    # ✅ Check if the cluster contains valid cells
    valid_cells <- cluster_cells[cluster_cells %in% colnames(expr_data)]
    
    if (length(valid_cells) > 0) {
      mnmat[, i] <- Matrix::rowMeans(expr_data[, valid_cells, drop = FALSE])
    }
  }
  
  colnames(mnmat) <- as.vector(uniq)
  
  # Compute Pearson correlation matrix
  mat <- cor(mnmat, method = "pearson", use = "complete.obs")
  
  # Generate heatmap
  ht <- Heatmap(
    mat,
    name = 'Pearson correlation',
    #col = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100), # Red-Blue gradient
    col = viridis::viridis(100),
    border = "#8B8B8C",
    rect_gp = gpar(col = "#8B8B8C"),
    row_names_gp = gpar(fontsize = fontsize),  
    column_names_gp = gpar(fontsize = fontsize, fontface = "plain"),
    column_names_side = "bottom",
    column_names_rot = column_names_rot,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = TRUE,
    show_column_names = TRUE,
    show_column_dend = TRUE,
    heatmap_legend_param = list(
      title = 'Pearson correlation',
      title_position = 'leftcenter-rot',
      legend_height = unit(3.5, 'cm'),
      legend_width = unit(0.5, 'cm'),
      border = '#8B8B8C',
      #legend_direction = 'horizontal',
      labels_gp = gpar(fontsize = fontsize)
    )
  )
  
  # Draw heatmap with title
  draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
  grid::grid.text(
    plot.title,
    x = 0.5, y = unit(1, "npc") - unit(2, "mm"),
    gp = gpar(fontsize = fontsize + 2, fontface = "bold")
  )
}


#' Plot Cluster Percentages
#'
#' This function generates a barplot or boxplot to visualize the percentage of 
#' different cell clusters within groups and samples.
#'
#' @param data A `Seurat` object or a data frame containing metadata.
#' @param cluster_col Character. Column name representing the cluster variable (default: "ann_level_3").
#' @param group_col Character. Column name representing the grouping variable (default: "group").
#' @param sample_col Character. Column name representing the sample variable (default: "sample").
#' @param sample_order_col Character. Column name for ordering samples (default: "sample_order").
#' @param sample_colors Named vector of colors for samples. If NULL, default colors are used.
#' @param group_colors Named vector of colors for groups. If NULL, default colors are used.
#' @param facet_ncol Integer. Number of columns for facet wrap (default: 10).
#' @param fontsize Numeric. Font size for plot text (default: 10).
#' @param show_contour Logical. Whether to show contour lines (default: TRUE).
#' @param theme_type Character. Theme type for the plot (default: "minimal").
#' @param plot_type Character. Either "barplot" or "boxplot" (default: "barplot").
#' @param x_angle Numeric. Angle for x-axis labels (default: 0).
#' @param check_normality Logical. If TRUE, performs normality checks (default: TRUE).
#' @param show_pvalue Logical. If TRUE, adds p-values to the plot (default: TRUE).
#' @param multi_p Logical. If TRUE, performs multiple comparisons (default: TRUE).
#' @param pairwise_test Logical. If TRUE, performs pairwise statistical tests (default: FALSE).
#' @param label Character. Label format for p-values ("p.signif" or "p.format", default: "p.signif").
#' @param label_size Numeric. Font size for p-value labels (default: 4).
#' @param legend Logical. Whether to display a legend (default: TRUE).
#' @param legend_ncol Integer. Number of columns in the legend (default: 1).
#' @param legend_title Character. Title for the legend (default: NULL).
#' @param plot_title Character. Title of the plot (default: NULL).
#' @param x_title Character. X-axis title (default: NULL).
#' @param y_title Character. Y-axis title (default: NULL).
#' @param ncol Integer. Number of columns for facet_wrap (default: 4).
#'
#' @return A `ggplot` object.
#' @export
#'
#' @examples
#' # Example usage with a Seurat object
#' p <- plot_cluster_percent(data = seurat_object, group_col = "Condition")
#' print(p)
#'
plot_cluster_percent <- function(data,
                                 cluster_col = "ann_level_3",
                                 group_col = "group",
                                 sample_col = "sample",
                                 sample_order_col = "sample_order",
                                 sample_colors = NULL,
                                 group_colors = NULL,
                                 facet_ncol = 10,
                                 fontsize = 10,
                                 show_contour = TRUE,
                                 theme_type = "minimal",
                                 plot_type = "barplot",
                                 x_angle = 0,
                                 check_normality = TRUE,
                                 show_pvalue = TRUE,
                                 multi_p = TRUE,
                                 pairwise_test = FALSE,
                                 label = "p.signif", #p.format
                                 label_size = 4,
                                 legend = TRUE,
                                 legend_ncol = 1,
                                 legend_title = NULL,
                                 plot_title = NULL,
                                 x_title = NULL,
                                 y_title = NULL,
                                 ncol = 4
) {
  require(Seurat)
  require(ggplot2)
  require(ggpubr)
  
  if (inherits(data, "Seurat")) {
    data <- data@meta.data
  }
  
  aggr <- aggregate(data[[cluster_col]],
                    by = list(data[[cluster_col]],
                              data[[group_col]],
                              data[[sample_col]]),
                    FUN = length)
  names(aggr) <- c("cluster", "group", "sample", "num")
  aggr$sample <- as.character(aggr$sample)
  
  batch <- aggregate(data[[sample_col]],
                     by = list(data[[sample_col]]),
                     FUN = length)
  names(batch) <- c("sample", "total_cells")
  batch$sample <- as.character(batch$sample)
  
  stat <- dplyr::left_join(aggr, batch, by = "sample")
  stat$freq <- (stat$num / stat$total_cells) * 100
  stat <- stat[!is.na(stat$freq), ]
  
  # Create plot
  if (plot_type == "boxplot") {
    p <- ggplot(stat, aes(x = group, y = freq, fill = group)) +
      geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.5, color = if (show_contour) "black" else NA, size = 0.1) +
      geom_jitter(aes(fill = sample), size = 1.5, shape = 21, stroke = 0.3, alpha = 0.8,
                  position = position_jitterdodge(jitter.width = 0.2)) #+
      #ggbeeswarm::geom_quasirandom()
  } else if (plot_type == "barplot") {
    p <- ggplot(stat, aes(x = group, y = freq, fill = group)) +
      geom_bar(stat = "summary", #fun = "mean",
               color = if (show_contour) "black" else NA, size = 0.1, alpha = 0.8) +
      geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2) +
      geom_jitter(aes(fill = sample), size = 1.5, shape = 21, stroke = 0.3, alpha = 0.8,
                  position = position_jitterdodge(jitter.width = 0.2))
  } else {
    stop("Invalid plot type. Choose either 'boxplot' or 'barplot'.")
  }
  
  stat$group <- factor(x = stat$group, levels = unique(data[[group_col]]))
  stat$sample <- factor(x = stat$sample, levels = levels(data[[sample_order_col]]))
  
  # Add statistical comparisons
  if (show_pvalue) {
    
    if (multi_p) {
      p <- p + stat_compare_means(comparisons = combn(levels(stat$group), 2, simplify = FALSE),
                                  size = label_size, bracket.nudge.y = 0.5) +
        stat_compare_means(size = label_size, label = "p.format", 
                           vjust = -7, 
                           hjust = -0.5,
                           tip.length = 0, 
                           step.increase = 0.5
        ) 
    } else {
      p <- p + stat_compare_means(size = label_size, label = "p.format", 
                                  vjust = -2, 
                                  hjust = -0.5,
                                  tip.length = 0, 
                                  step.increase = 0.5
      ) 
    }
  }
  
  # Apply default colors if none are provided
  if (is.null(group_colors)) {
    group_colors <- ggpubr::get_palette("jco", length(unique(data[[group_col]])))
    names(group_colors) <- unique(data[[group_col]])
  }
  if (is.null(sample_colors)) {
    sample_colors <- ggpubr::get_palette("npg", length(unique(data[[sample_col]])))
    names(sample_colors) <- unique(data[[sample_col]])
  }
  
  if (!is.null(sample_colors)) {
    p <- p + scale_color_manual(values = sample_colors)
  }
  
  p <- p + plot_theme(theme_type = theme_type, font_size = fontsize, x_angle = x_angle) +
    guides(fill = guide_legend(ncol = legend_ncol)) +
    labs(x = x_title, y = y_title, fill = legend_title) +
    scale_fill_manual(values = c(group_colors, sample_colors)) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.3)))
  
  p <- p + facet_wrap(~ cluster, scales = "free_y", ncol = ncol) +
    theme(strip.text = element_text(face = "bold.italic", size = fontsize))
  
  if (!legend) {
    p <- p & NoLegend()
  }
  
  return(p)
}


#' Gene Ontology (GO) enrichment analysis for clusters
#'
#' This function performs GO enrichment analysis for each cluster in a differential expression (DE) table,
#' using the clusterProfiler package, and saves the results and plots for each cluster.
#'
#' @param DE A data.frame or tibble containing differential expression results, including gene names, cluster identities, and statistics.
#' @param ident_col Name of the column in \code{DE} with cluster identities. Default is "cluster".
#' @param gene_col Name of the column in \code{DE} with gene symbols. Default is "gene".
#' @param logFC_col Name of the column in \code{DE} with log fold change values. Default is "avg_log2FC".
#' @param pval_col Name of the column in \code{DE} with adjusted p-values. Default is "p_val_adj".
#' @param org Organism: "human" (default) or "mouse".
#' @param ont Ontology: "BP" (Biological Process), "MF" (Molecular Function), or "CC" (Cellular Component). Default is "BP".
#' @param wrap_length Integer, maximum line length for GO term labels. Default is 50.
#' @param category Number of top GO terms to plot per cluster. Default is 30.
#' @param out.dir Output directory to save results and plots.
#' @param out.name Output name prefix for files.
#' @param ... Additional arguments passed to \code{clusterProfiler::enrichGO}.
#'
#' @return No return value. The function saves RDS files, PDF plots, and a TSV summary table in the specified output directory.
#'
#' @details
#' For each cluster, the function performs GO enrichment analysis, saves the results as RDS, generates a barplot of the top GO terms,
#' and writes a summary table for all clusters.
#'
#' @import clusterProfiler
#' @import org.Hs.eg.db
#' @import org.Mm.eg.db
#' @import dplyr
#' @import ggplot2
#' @import stringr
#' @import forcats
#' @import colorspace
#' @export
Enrich_GO <- function(DE, 
                      ident_col = "cluster",
                      gene_col = "gene",
                      logFC_col = "avg_log2FC",
                      pval_col = "p_val_adj",
                      org = "human", 
                      ont = "BP", 
                      wrap_length = 50,
                      category = 30,
                      out.dir,
                      out.name,...) {
  #require(EnsDb)
  pkg_name <- ifelse(org == "human", "org.Hs.eg.db", "org.Mm.eg.db")
  
  if (!requireNamespace(pkg_name, quietly = TRUE)) {
    stop(paste("Package", pkg_name, "needed for this function to work. Please install it."),
         call. = FALSE)
  }
  
  if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
    stop(paste("Package \"clusterProfiler\" needed for this function to work. Please install it."),
         call. = FALSE)
  }
  
  
  joined <- data.frame()
  cluster_names <- as.vector(unique(DE[[ident_col]]))
  
  for(i in 1:length(cluster_names)){
    cluster_name <- cluster_names[i]
    cat("[", i, "/", length(cluster_names),
        "] GSEA working on: ", cluster_name, " ...\n")
    
    gene_list <- DE %>% 
      dplyr::filter(.data[[ident_col]] == cluster_name) %>% 
      dplyr::arrange(.data[[pval_col]]) %>% 
      #head(topn) %>% 
      dplyr::pull(.data[[gene_col]])
    
    db <- if(org == "human") org.Hs.eg.db::org.Hs.eg.db else org.Mm.eg.db::org.Mm.eg.db
    
    go_enrich <- clusterProfiler::enrichGO(gene = gene_list, 
                                           OrgDb = db, 
                                           ont = ont,
                                           keyType = "SYMBOL", ...)
    
    dir <- paste(out.dir, ont, out.name, "/", sep = "/")
    if(!dir.exists(dir)){
      dir.create(file.path(dir), recursive = TRUE, showWarnings = FALSE)
    }
    
    go_enrich@result$cluster_name <- replicate(nrow(go_enrich@result),paste(cluster_name))
    saveRDS(go_enrich, paste(dir, cluster_name, "_GO_", ont, ".rds", sep = ""))
    
    df <- go_enrich@result
    df$cluster_name <- replicate(nrow(df),paste(cluster_name))
    rownames(df) <- c()
    joined <- rbind(joined, df)
    
    df <- as_tibble(go_enrich@result) %>% 
      arrange(.data$p.adjust) %>% 
      head(category) %>% 
      dplyr::mutate(cluster = cluster_name) %>% 
      dplyr::mutate(#Description = stringr::str_to_title(.data$Description)
        Description = stringr::str_to_upper(.data$Description)) %>% 
      dplyr::mutate(Description = forcats::fct_reorder(.data$Description, dplyr::desc(.data$p.adjust))) %>% 
      
      # Wrap long GO terms
      #df$Description <- stringr::str_wrap(df$Description, width = wrap_length)
      
      ggplot(df, mapping = aes(x = .data$Description, y = -log10(.data$p.adjust))) + 
      geom_bar(aes(fill = .data$Count), 
               stat = "identity") + 
      scale_fill_gradientn("Gene Count", 
                           colours = colorspace::diverge_hcl(7), 
                           guide = "colourbar") +
      coord_flip() + 
      #geom_hline(yintercept = -log10(0.05), linetype = "dashed") + 
      xlab("Gene Ontology") + 
      ylab(bquote("-log"[10] ~ " adjusted p-value")) +
      theme_bw() +
      theme(axis.text = element_text(size = 8, color = "black"),
            axis.title = element_text(size = 10, color = "black"),
            legend.title=element_text(size = 8, color = "black")) +
      ggtitle(cluster_name)
    
    saveRDS(go_enrich, paste(dir, cluster_name, "_GO_", ont, ".rds", sep = ""))
    
    ggsave(paste(dir, cluster_name, "_GO_", ont, ".pdf", sep = ""), width = 8, height = 8)
    
  }
  
  write.table(joined, file = paste(dir, "all_res_GO_", ont, ".tsv", sep = ""),
              sep = "\t", quote = F, row.names = F, col.names = T)
  
  cat("GO analysis completed. Results saved in: ", out.dir)
  
}


#' Plot Gene Ontology (GO) enrichment results
#'
#' This function creates a barplot of the top enriched GO terms from a data frame, with options to filter, select, and customize the output.
#'
#' @param df A data.frame or tibble containing GO enrichment results, including columns 'Description', 'p.adjust', and 'Count'.
#' @param category Number of top GO terms to display. Default is 10.
#' @param width Width of the output plot (in inches). Default is 7.
#' @param height Height of the output plot (in inches). Default is 8.
#' @param wrap_length Integer, maximum line length for GO term labels. Default is 30.
#' @param selected_terms Character vector of patterns; only GO terms containing these patterns will be included. Default is NULL.
#' @param exclude_terms Character vector of patterns; GO terms containing these patterns will be excluded. Default is NULL.
#' @param out.dir Output directory to save the plot. If NULL, the plot is not saved. Default is NULL.
#' @param cluster_name Name of the cluster for plot title and file naming. Default is NULL.
#' @param ont Ontology type (e.g., "BP", "MF", "CC"). Default is "BP".
#' @param base_size Base font size for plot text. Default is 10.
#' @param legend.text.size Font size for legend text. Default is 8.
#'
#' @return A ggplot object representing the GO enrichment barplot. Optionally saves the plot as a PDF if \code{out.dir} is provided.
#'
#' @details
#' The function filters and arranges GO terms, wraps long labels, and generates a horizontal barplot of -log10(adjusted p-value) for each term.
#' The plot can be saved as a PDF file.
#'
#' @import ggplot2
#' @import dplyr
#' @import stringr
#' @import forcats
#' @import colorspace
#' @export
Plot_GO_Enrichment <- function(df, 
                               category = 10, 
                               width = 7, 
                               height = 8, 
                               wrap_length = 30,
                               selected_terms = NULL, 
                               exclude_terms = NULL, 
                               out.dir = NULL, 
                               cluster_name = NULL, 
                               ont = "BP",
                               base_size = 10,
                               legend.text.size = 8) {
  
  # df <- df %>% 
  #   arrange(.data$p.adjust) %>% 
  #   head(category)
  
  # Convert Description to uppercase for consistent filtering
  df$Description <- toupper(df$Description)
  
  # Exclude terms that contain any of the patterns in exclude_terms
  if (!is.null(exclude_terms)) {
    pattern_exclude <- paste(exclude_terms, collapse = "|")
    df <- df %>% dplyr::filter(!grepl(pattern_exclude, .data$Description))
  }
  
  # Select terms that contain any of the patterns in selected_terms
  if (!is.null(selected_terms)) {
    pattern_include <- paste(selected_terms, collapse = "|")
    df <- df %>% dplyr::filter(grepl(pattern_include, .data$Description))
  }
  
  # Check if there are any remaining terms
  if (nrow(df) == 0) {
    warning("Aucun terme GO correspondant aux critères fournis.")
    return(NULL)
  }
  
  # Wrap long GO terms
  df$Description <- stringr::str_wrap(df$Description, width = wrap_length)
  
  df <- df %>% 
    arrange(.data$p.adjust) %>% 
    head(category) %>% 
    dplyr::mutate(cluster = cluster_name) %>% 
    dplyr::mutate(Description = forcats::fct_reorder(.data$Description, dplyr::desc(.data$p.adjust))) 
  
  # Create the plot
  plot <- ggplot(df, mapping = aes(x = .data$Description, y = -log10(.data$p.adjust))) + 
    geom_bar(aes(fill = .data$Count), stat = "identity", color = "black", size = 0.3) + 
    scale_fill_gradientn("Gene count", colours = rev(colorspace::sequential_hcl(5, palette = "Burg")), guide = "colourbar") +
    coord_flip() + 
    xlab("Gene ontology") + 
    ylab(bquote("-log"[10] ~ " adjusted p-value")) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5, size = base_size*1.5, face = "bold"),
      axis.text = element_text(color = "black", size = base_size),
          axis.title = element_text(color = "black", size = base_size),
          legend.title = element_text(size = legend.text.size, color = "black"),
          legend.frame = element_rect(color = "black"),  # Black border around legend
          legend.key.height = unit(0.5, 'cm'), 
          legend.key.width = unit(0.4, 'cm'),
          axis.ticks = element_line(color = "black")) +  # Black axis ticks
    ggtitle(cluster_name) 
  
  # Save the plot if output directory is provided
  if (!is.null(out.dir) && !is.null(cluster_name)) {
    dir.create(out.dir, recursive = TRUE, showWarnings = FALSE)
    ggsave(paste(out.dir, "/", cluster_name, "_GO_", ont, ".pdf", sep = ""), plot, width = width, height = height)
  }
  
  return(plot)
}

